<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TSL Compute Shaders: Interactive Guide</title>
    <link rel="stylesheet" href="/src/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  </head>
  <body>
    <header class="header">
      <div class="container">
        <h1 class="header-title">TSL Compute Shaders: Introduction</h1>
      </div>
    </header>

    <main class="main">
      <div class="container">
        
        <!-- Basic Example Section -->
        <section id="basic-example" class="section">
          
          <p class="section-intro">Let's start with a simple compute shader that multiplies an array of numbers by 2. This demonstrates the fundamental workflow of TSL compute shaders. We'll build it step-by-step.</p>
          
          <h4>Step 1: Setup Renderer and Buffers</h4>
          <p>The first step in any GPU computation is to prepare the data. We need a WebGPU renderer to communicate with the GPU and buffers to hold our data.</p>
          <pre class="code-block"><code class="language-typescript">// Initialize WebGPU renderer
const renderer = new THREE.WebGPURenderer()
await renderer.init()

// Create buffers for 10 float values
const count = 10
const inputBuffer = instancedArray(count, 'float')
const outputBuffer = instancedArray(count, 'float')</code></pre>

          <div class="concept-item">
            <p><code>instancedArray(count, type)</code> is a TSL helper that creates a GPU buffer. Think of it as a specialized array that lives in the GPU's high-speed memory, making it directly accessible to shader programs.</p>
            <ul class="param-list">
              <li><strong>count:</strong> The number of elements in the buffer.</li>
              <li><strong>type:</strong> The data type for each element (e.g., 'float', 'int', 'vec2', 'vec3'). This maps directly to data types in the underlying shader language (WGSL/GLSL).</li>
            </ul>
            <p>This buffer is "instanced" because each of the thousands of GPU threads (or instances) that run in parallel can be assigned a unique element from this array to work on, which is the foundation of data parallelism on the GPU.</p>
          </div>
          <h4>Step 2: Define the Compute Logic</h4>
          <p>With our buffers ready, we define the actual computation to be performed on the GPU. This is done by creating a TSL function.</p>
          <pre class="code-block"><code class="language-typescript">// Main computation: multiply each value by 2
const multiplyCompute = Fn(() => {
  const input = inputBuffer.element(instanceIndex)
  const output = outputBuffer.element(instanceIndex)
  output.assign(input.mul(2))
})()</code></pre>
          
          <div class="concept-item">
            <p><strong><code>Fn(() => { ... })</code></strong> is the heart of TSL. The JavaScript code you write inside this function is not executed directly by the CPU. Instead, TSL parses this code and compiles it into a low-level shader program (like WGSL) that can run on the GPU. This allows you to write GPU logic using familiar JavaScript-like syntax.</p>
            <p><strong><code>instanceIndex</code></strong> is a special variable provided by TSL within a compute shader. It represents the unique ID of the current thread, ranging from 0 to N-1 (where N is the total number of threads launched). Each thread gets a different <code>instanceIndex</code>, allowing it to work on a different piece of data. Here, we use it as an index to get the specific element this thread is responsible for from our <code>inputBuffer</code> and <code>outputBuffer</code>.</p>
          </div>

          <p>We also need a small function to initialize our input data with values from 1 to 10. This uses the same principles.</p>
           <pre class="code-block"><code class="language-typescript">// Initialize input data: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
const initCompute = Fn(() => {
  const input = inputBuffer.element(instanceIndex)
  input.assign(instanceIndex.add(1).toFloat())
})()</code></pre>

          <h4>Step 3: Execute and Retrieve Data</h4>
          <p>Now we tell the GPU to run our compiled functions and then we retrieve the results.</p>
          <pre class="code-block"><code class="language-typescript">// Execute compute shaders
await renderer.computeAsync(initCompute.compute(count))
await renderer.computeAsync(multiplyCompute.compute(count))

// Read results back to CPU
const inputArray = await renderer.getArrayBufferAsync(inputBuffer.value)
const outputArray = await renderer.getArrayBufferAsync(outputBuffer.value)</code></pre>
          
          <div class="concept-item">
            <p><strong><code>renderer.computeAsync(shader.compute(count))</code></strong> is the command that dispatches the workload to the GPU. The <code>.compute(count)</code> part tells the GPU to launch 10 threads in parallel. The operation is asynchronous (hence `computeAsync` and `await`) because the CPU sends the command and moves on. The `await` ensures our JavaScript code pauses until the GPU signals that it has finished its work.</p>
            <p><strong><code>renderer.getArrayBufferAsync(buffer)</code></strong> is how we get data back from the GPU. It copies the specified GPU buffer into a standard JavaScript <code>ArrayBuffer</code> on the CPU. This read-back operation can be a performance bottleneck as it requires synchronization between the CPU and GPU, so it should be used only when necessary.</p>
          </div>

          <p>Here is the live output from the running code. As you can see, each number in the input array has been successfully multiplied by 2.</p>
          <div class="example-output">
            <div id="basic-output" class="output-box">
              <div class="loading">Running compute shader...</div>
            </div>
          </div>

          <p>And here is the complete, self-contained function that accomplishes the task. The code below is what's actually running on this page.</p>
          <pre class="code-block"><code class="language-typescript">import * as THREE from 'three/webgpu'
import { Fn, instancedArray, instanceIndex } from 'three/tsl'

async function initComputeShader() {
  // Initialize WebGPU renderer
  const renderer = new THREE.WebGPURenderer()
  await renderer.init()
  
  // Create buffers for 10 float values
  const count = 10
  const inputBuffer = instancedArray(count, 'float')
  const outputBuffer = instancedArray(count, 'float')
  
  // Initialize input data: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  const initCompute = Fn(() => {
    const input = inputBuffer.element(instanceIndex)
    input.assign(instanceIndex.add(1).toFloat())
  })()
  
  // Main computation: multiply each value by 2
  const multiplyCompute = Fn(() => {
    const input = inputBuffer.element(instanceIndex)
    const output = outputBuffer.element(instanceIndex)
    output.assign(input.mul(2))
  })()
  
  // Execute compute shaders
  await renderer.computeAsync(initCompute.compute(count))
  await renderer.computeAsync(multiplyCompute.compute(count))
  
  // Read results back to CPU
  const inputArray = await renderer.getArrayBufferAsync(inputBuffer.value)
  const outputArray = await renderer.getArrayBufferAsync(outputBuffer.value)
  
  return {
    input: Array.from(new Float32Array(inputArray)),
    output: Array.from(new Float32Array(outputArray))
  }
}</code></pre>
          
        </section>

        <!-- Game of Life Section -->
        <section id="game-of-life" class="section">
          <p class="section-intro">Now let's see something more complex: a complete implementation of Conway's Game of Life running entirely on the GPU. This showcases 2D array processing, neighbor counting, and conditional logic, all built step-by-step.</p>

          <h4>Step 1: Setup Grid and Buffers</h4>
          <p>We start by setting up our simulation environment. This includes defining the grid size and creating two GPU buffers with <code>instancedArray</code>: one to hold the current state of the cells (<code>currentGeneration</code>) and another for the next state (<code>nextGeneration</code>). We use two buffers to avoid race conditions, where a cell's new state might incorrectly influence its neighbors' calculations in the same step.</p>
          <pre class="code-block"><code class="language-typescript">// Grid dimensions - 64x64 = 4,096 cells total
const gridWidth = 64;
const gridHeight = 64;
const totalCells = gridWidth * gridHeight;

// Create buffers for current and next generation (using integers: 0 for dead, 1 for alive)
const currentGeneration = instancedArray(totalCells, 'int');
const nextGeneration = instancedArray(totalCells, 'int');</code></pre>
          <div class="concept-item">
            <h3>Core Concept: Double Buffering</h3>
            <p>Using two buffers is a common and essential technique in simulations. All reads for a given step come from a single source (<code>currentGeneration</code>), and all writes go to a separate destination (<code>nextGeneration</code>). After the step is complete, the buffers are "swapped" for the next iteration. This ensures that the calculation for each cell is based on a consistent snapshot of the grid from the beginning of the step.</p>
          </div>

          <h4>Step 2: 2D to 1D Mapping</h4>
          <p>GPU buffers are linear, one-dimensional arrays. To simulate a 2D grid, we need helper functions to convert (x, y) coordinates into a 1D index. We also create a helper to get a cell's state with "toroidal" or "wrapping" boundaries, where the grid's edges connect to each other.</p>
          <pre class="code-block"><code class="language-typescript">// Helper function to convert 2D coordinates to a 1D index
const getIndex = Fn(([x, y]) => {
  return y.mul(gridWidth).add(x);
});

// Helper function to get cell state with boundary wrapping
const getCell = Fn(([buffer, x, y]) => {
  // Wrap coordinates for toroidal topology (edges connect)
  const wrappedX = x.add(gridWidth).mod(gridWidth);
  const wrappedY = y.add(gridHeight).mod(gridHeight);
  const index = getIndex(wrappedX, wrappedY);
  return buffer.element(index);
});</code></pre>
          <div class="concept-item">
            <h3>Core Concept: Working with Grids on the GPU</h3>
            <p>Since GPU memory is a flat list, we use a standard formula to access 2D data: <code>index = y * width + x</code>. In TSL, this translates to <code>y.mul(gridWidth).add(x)</code>. The modulo operator (<code>.mod()</code>) is a powerful tool for creating seamless, wrapping boundaries, which is a common pattern in simulations like this.</p>
          </div>

          <h4>Step 3: Initializing the Grid</h4>
          <p>To start the simulation, we need an initial pattern. We'll write a compute shader that gives each cell a 30% chance of being "alive." We use TSL's built-in <code>hash()</code> function to generate a pseudo-random value for each cell based on its <code>instanceIndex</code>.</p>
          <pre class="code-block"><code class="language-typescript">// Initialize grid with a random pattern
const initializeGrid = Fn(() => {
  const currentCell = currentGeneration.element(instanceIndex);

  // Use hash function for pseudo-random initialization
  const randomValue = hash(instanceIndex.add(12345)); // Add a seed

  // 30% chance for a cell to be alive initially
  If(randomValue.lessThan(0.3), () => {
    currentCell.assign(1); // Alive
  }).Else(() => {
    currentCell.assign(0); // Dead
  });
})();</code></pre>

          <h4>Step 4: The Game of Life Update Logic</h4>
          <p>This is the core of the simulation. For each cell, we count its eight living neighbors. Then, we apply the classic rules of Conway's Game of Life using TSL's <code>If().ElseIf().Else()</code> structure to determine if the cell should be alive or dead in the next generation.</p>
          <pre class="code-block"><code class="language-typescript">const updateGeneration = Fn(() => {
  // Convert 1D thread index to 2D grid coordinates
  const x = instanceIndex.mod(gridWidth);
  const y = instanceIndex.div(gridWidth).toInt();

  // Count living neighbors
  const neighbors = int(0).toVar();
  neighbors.addAssign(getCell(currentGeneration, x.sub(1), y.sub(1)));
  neighbors.addAssign(getCell(currentGeneration, x.sub(1), y));
  neighbors.addAssign(getCell(currentGeneration, x.sub(1), y.add(1)));
  neighbors.addAssign(getCell(currentGeneration, x, y.sub(1)));
  neighbors.addAssign(getCell(currentGeneration, x, y.add(1)));
  neighbors.addAssign(getCell(currentGeneration, x.add(1), y.sub(1)));
  neighbors.addAssign(getCell(currentGeneration, x.add(1), y));
  neighbors.addAssign(getCell(currentGeneration, x.add(1), y.add(1)));

  const currentCell = currentGeneration.element(instanceIndex);
  const nextCell = nextGeneration.element(instanceIndex);

  // Apply Conway's Game of Life rules
  If(currentCell.equal(1), () => { // Current cell is alive
    If(neighbors.lessThan(2).or(neighbors.greaterThan(3)), () => {
      nextCell.assign(0); // Dies from under/overpopulation
    }).Else(() => {
      nextCell.assign(1); // Survives
    });
  }).Else(() => { // Current cell is dead
    If(neighbors.equal(3), () => {
      nextCell.assign(1); // Birth
    }).Else(() => {
      nextCell.assign(0); // Stays dead
    });
  });
})();</code></pre>
          
          <h4>Step 5: Running the Simulation</h4>
          <p>Finally, we orchestrate the simulation. We first run the <code>initializeGrid</code> shader once to set up the initial state. Then, we provide a button to run the simulation step-by-step. Each click will execute the <code>updateGeneration</code> shader to calculate the new state, followed by a <code>copyGeneration</code> shader to copy the results from <code>nextGeneration</code> back to <code>currentGeneration</code>, preparing it for the next iteration.</p>
          <pre class="code-block"><code class="language-typescript">// Copy next generation to current generation for the next iteration
const copyGeneration = Fn(() => {
  currentGeneration.element(instanceIndex).assign(nextGeneration.element(instanceIndex));
})();

// Initialize the grid with a random pattern
await renderer.computeAsync(initializeGrid.compute(totalCells));

// Run simulation for multiple generations
for (let step = 0; step &lt; 10; step++) {
  // Calculate next generation and write to the second buffer
  await renderer.computeAsync(updateGeneration.compute(totalCells));
  // Copy the new state back to the first buffer for the next read
  await renderer.computeAsync(copyGeneration.compute(totalCells));
}</code></pre>

          <h4>Live Simulation</h4>
          <p>Here is the live simulation. Press the button to advance the Game of Life by one generation and see the simulation evolve.</p>
          <div class="example-output">
            <div id="game-of-life-output" class="output-box">
              <div class="loading">Initializing Game of Life...</div>
            </div>
          </div>
          <h4>Complete Code</h4>
          <p>And here is the complete, self-contained function. The code below is what's actually running on this page.</p>
          <pre class="code-block"><code class="language-typescript">import * as THREE from 'three/webgpu'
import { Fn, instancedArray, instanceIndex, int, hash, If } from 'three/tsl'

async function initGameOfLife() {
  // Initialize WebGPU renderer
  const renderer = new THREE.WebGPURenderer()
  await renderer.init()
  
  // Grid dimensions - 64x64 = 4,096 cells total
  const gridWidth = 64
  const gridHeight = 64
  const totalCells = gridWidth * gridHeight
  
  // Create buffers for current and next generation
  const currentGeneration = instancedArray(totalCells, 'int')
  const nextGeneration = instancedArray(totalCells, 'int')
  
  // Helper function to convert 2D coordinates to 1D index
  const getIndex = Fn(([x, y]: any) => {
    return y.mul(gridWidth).add(x)
  })
  
  // Helper function to get cell state with boundary wrapping
  const getCell = Fn(([buffer, x, y]: any) => {
    // Wrap coordinates for toroidal topology (edges connect)
    const wrappedX = x.add(gridWidth).mod(gridWidth)
    const wrappedY = y.add(gridHeight).mod(gridHeight)
    const index = getIndex(wrappedX, wrappedY)
    return buffer.element(index)
  })
  
  // Initialize grid with random pattern
  const initializeGrid = Fn(() => {
    const currentCell = currentGeneration.element(instanceIndex)
    
    // Use hash function for pseudo-random initialization
    const randomValue = hash(instanceIndex.add(12345))
    
    // 30% chance for a cell to be alive initially
    If(randomValue.lessThan(0.3), () => {
      currentCell.assign(1) // Alive
    }).Else(() => {
      currentCell.assign(0) // Dead
    })
  })()
  
  // Game of Life update logic - the heart of the simulation
  const updateGeneration = Fn(() => {
    // Convert 1D thread index to 2D grid coordinates
    const x = instanceIndex.mod(gridWidth)
    const y = instanceIndex.div(gridWidth).toInt()
    
    // Count living neighbors (all 8 surrounding cells)
    const neighbors = int(0).toVar()
    
    // Check all 8 neighboring cells manually
    // (TSL doesn't support dynamic loops over arrays)
    neighbors.addAssign(getCell(currentGeneration, x.sub(1), y.sub(1)))
    neighbors.addAssign(getCell(currentGeneration, x.sub(1), y))
    neighbors.addAssign(getCell(currentGeneration, x.sub(1), y.add(1)))
    neighbors.addAssign(getCell(currentGeneration, x, y.sub(1)))
    neighbors.addAssign(getCell(currentGeneration, x, y.add(1)))
    neighbors.addAssign(getCell(currentGeneration, x.add(1), y.sub(1)))
    neighbors.addAssign(getCell(currentGeneration, x.add(1), y))
    neighbors.addAssign(getCell(currentGeneration, x.add(1), y.add(1)))
    
    // Get current cell state and prepare next state
    const currentCell = currentGeneration.element(instanceIndex)
    const nextCell = nextGeneration.element(instanceIndex)
    
    // Apply Conway's Game of Life rules
    If(currentCell.equal(1), () => {
      // Current cell is alive
      If(neighbors.lessThan(2), () => {
        nextCell.assign(0) // Dies from underpopulation
      }).ElseIf(neighbors.greaterThan(3), () => {
        nextCell.assign(0) // Dies from overpopulation
      }).Else(() => {
        nextCell.assign(1) // Survives (2 or 3 neighbors)
      })
    }).Else(() => {
      // Current cell is dead
      If(neighbors.equal(3), () => {
        nextCell.assign(1) // Birth (exactly 3 neighbors)
      }).Else(() => {
        nextCell.assign(0) // Stays dead
      })
    })
  })()
  
  // Copy next generation to current generation for next iteration
  const copyGeneration = Fn(() => {
    const current = currentGeneration.element(instanceIndex)
    const next = nextGeneration.element(instanceIndex)
    current.assign(next)
  })()
  
  // Initialize the grid with random pattern
  await renderer.computeAsync(initializeGrid.compute(totalCells))
  
  // Run simulation for multiple generations
  for (let step = 0; step &lt; 10; step++) {
    // Calculate next generation
    await renderer.computeAsync(updateGeneration.compute(totalCells))
    // Copy next generation to current
    await renderer.computeAsync(copyGeneration.compute(totalCells))
  }
  
  return {
    renderer,
    currentGeneration,
    nextGeneration,
    gridWidth,
    gridHeight,
    updateGeneration,
    copyGeneration
  }
}</code></pre>
        </section>

        <!-- Visualization Section -->
        <section id="visualization" class="section">
          <p class="section-intro">We've run the entire Game of Life simulation on the GPU. Now, how do we see it? A key advantage of TSL is its seamless integration with the Three.js rendering pipeline. We can visualize our simulation results without ever needing to bring the data back to the CPU, allowing for high-performance, real-time graphics.</p>
          
          <h4>Step 1: From Buffers to Pixels with <code>InstancedMesh</code></h4>
          <p>Our simulation involves 4,096 cells, and we need to draw a quad for each one. Creating and managing 4,096 separate objects would be very inefficient for the CPU. The solution is <code>THREE.InstancedMesh</code>, a special object that allows us to draw thousands of identical geometries in a single command, each with unique properties like position and color.</p>
          <pre class="code-block"><code class="language-typescript">// Create scene and camera for a 2D orthographic view
const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, 0.1, 10);
camera.position.z = 1;

// A single, small plane geometry will be used for all cells
const geometry = new THREE.PlaneGeometry(1 / gridWidth, 1 / gridHeight);

// Use an instanced mesh to draw all 4,096 cells in one efficient command
const mesh = new THREE.InstancedMesh(geometry, undefined, totalCells);
scene.add(mesh);</code></pre>
          <div class="concept-item">
            <h3>Core Concept: Instanced Rendering</h3>
            <p>Instanced rendering is a GPU technique for drawing many copies of the same object at once. You provide one set of vertices (the <code>PlaneGeometry</code>) and then an array of per-instance data (like position and color). The GPU's parallel processors then render all the copies in a single "draw call," dramatically improving performance compared to telling the CPU to issue thousands of separate draw calls.</p>
          </div>

          <h4>Step 2: Positioning Each Cell with a TSL Vertex Shader</h4>
          <p>Now that we have an <code>InstancedMesh</code>, we need to tell the GPU where to place each of the 4,096 plane instances. We do this with a TSL function assigned to the material's <code>positionNode</code>. This function is effectively a vertex shader that runs on the GPU. It uses the built-in <code>instanceIndex</code> to calculate a unique position for each instance, arranging them in a grid.</p>
          <pre class="code-block"><code class="language-typescript">// A TSL-powered material
const material = new THREE.MeshBasicNodeMaterial();
mesh.material = material;

// The positionNode is a TSL function that runs for every vertex of every instance.
// It's a vertex shader written in TSL!
material.positionNode = Fn(() => {
  // Calculate 2D grid position (x, y) from the 1D instanceIndex
  const x = instanceIndex.mod(gridWidth);
  const y = instanceIndex.div(gridWidth).toInt();

  // Normalize coordinates to the range [-0.5, 0.5] to fit our camera view
  const uvX = x.toFloat().add(0.5).div(gridWidth).sub(0.5);
  const uvY = y.toFloat().add(0.5).div(gridHeight).sub(0.5);

  // Add this calculated per-instance offset to the geometry's local vertex position
  const finalPosition = positionLocal.add(vec4(uvX, uvY, 0, 0));

  return finalPosition;
})();</code></pre>
          <div class="concept-item">
            <p><strong><code>positionNode</code></strong> is a property of TSL materials that lets you define the final position of each vertex using a TSL function. This function compiles into a vertex shader.</p>
            <p><strong><code>positionLocal</code></strong> is a TSL variable representing the original position of a vertex from the geometry buffer (our small plane). We add our calculated offset to it to move the entire plane instance to its correct spot on the grid.</p>
          </div>

          <h4>Step 3: Coloring Each Cell with a Compute Shader</h4>
          <p>This is the crucial step that connects our compute simulation to our visual rendering. We create a new compute shader whose sole job is to read the state of each cell from our <code>currentGeneration</code> buffer and write a corresponding color into a new <code>colorBuffer</code>. This <code>colorBuffer</code> is then fed directly into the material's <code>colorNode</code>, telling the rendering pipeline what color to make each instance.</p>
          <pre class="code-block"><code class="language-typescript">// Step 3.1: Create a new buffer to hold per-instance color data
const colorBuffer = instancedArray(totalCells, 'vec4');

// Step 3.2: Create a compute shader to populate the color buffer
const updateColors = Fn(() => {
  const cellState = currentGeneration.element(instanceIndex);
  const outputColor = colorBuffer.element(instanceIndex);

  const aliveColor = vec4(0.0, 1.0, 0.0, 1.0); // Green
  const deadColor = vec4(0.0, 0.0, 0.0, 1.0);  // Black

  // If cell is alive (state == 1), output green. Otherwise, black.
  outputColor.assign(deadColor);
  If(cellState.equal(1), () => {
    outputColor.assign(aliveColor);
  });
})();

// Step 3.3: Pipe the color buffer directly into the material's color node
material.colorNode = colorBuffer.toAttribute();</code></pre>
           <div class="concept-item">
            <h3>Core Concept: GPU Data Flow</h3>
            <p>This demonstrates a powerful GPU-only data pipeline. The data flows from one GPU process to the next without any CPU intervention:
            <br/>1. <strong>GOL State:</strong> The <code>currentGeneration</code> buffer is updated by the main simulation compute shader.
            <br/>2. <strong>Coloring:</strong> The <code>updateColors</code> compute shader reads from <code>currentGeneration</code> and writes to <code>colorBuffer</code>.
            <br/>3. <strong>Rendering:</strong> The material's <code>colorNode</code> reads from <code>colorBuffer</code> as a vertex attribute to color the final pixels.
            <br/>This "zero-copy" approach is extremely efficient and is key to real-time graphics.</p>
          </div>

          <h4>Step 4: The Animation Loop: Tying It All Together</h4>
          <p>The final piece is the animation loop, which orchestrates all our GPU tasks frame by frame. On each frame, we execute our compute shaders in sequence and then render the final scene. All of this happens on the GPU, coordinated by a few asynchronous commands from the CPU.</p>
          <pre class="code-block"><code class="language-typescript">// The main animation loop, managed by the renderer
renderer.setAnimationLoop(async () => {
  // 1. Run one step of the Game of Life simulation
  await runGameOfLifeStep(); // This runs updateGeneration and copyGeneration

  // 2. Update the color buffer based on the new simulation state
  await renderer.computeAsync(updateColors.compute(totalCells));

  // 3. Render the scene. The GPU now has all the data it needs.
  renderer.render(scene, camera);
});</code></pre>
          <div class="concept-item">
            <h3>Core Concept: Defining vs. Dispatching a Shader</h3>
            <p>You might be wondering about the syntax <code>updateColors.compute(totalCells)</code>. It's a key concept in TSL that separates the <em>definition</em> of a compute shader from its <em>execution</em>.</p>
            <ul class="param-list">
              <li><strong><code>updateColors</code></strong>: This variable holds the TSL function node we defined earlier using <code>Fn(() => { ... })</code>. It's the blueprint for our shader—it contains the logic, but it hasn't been run yet.</li>
              <li><strong><code>.compute(totalCells)</code></strong>: This is a method on the TSL function node. It doesn't run the computation itself. Instead, it creates a "dispatch configuration" object. It packages our shader blueprint together with the number of times it should be executed (the workload size, in this case <code>totalCells</code>).</li>
              <li><strong><code>renderer.computeAsync(...)</code></strong>: This function takes the dispatch configuration object created by <code>.compute()</code> and sends it to the GPU to be executed.</li>
            </ul>
            <p>Think of it like this: <code>updateColors</code> is the recipe for a cake. <code>.compute(4096)</code> is the instruction "prepare to bake 4,096 cakes." And <code>renderer.computeAsync()</code> is the final command to "start baking." This separation allows the same shader logic to be reused with different workload sizes if needed.</p>
          </div>
          <p>With this, we have a complete, high-performance, GPU-powered simulation and visualization of Conway's Game of Life. The interactive canvas you saw in the previous section is rendered using exactly these techniques.</p>
        </section>

      </div>
    </main>

    <footer class="footer">
      <div class="container">
        <p>&copy; 2025 TSL Compute Shaders Guide. Built with Three.js and TSL.</p>
        <div class="footer-links">
          <a href="https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language" target="_blank">TSL Documentation</a>
          <a href="https://threejs.org/examples/" target="_blank">Three.js Examples</a>
          <a href="https://www.w3.org/TR/webgpu/#compute-shaders" target="_blank">WebGPU Spec</a>
        </div>
      </div>
    </footer>

    <script type="module" src="/src/website.ts"></script>
  </body>
</html>