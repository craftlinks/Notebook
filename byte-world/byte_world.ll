; ModuleID = 'byte_world'
source_filename = "byte_world"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

%..string = type { ptr, i64 }
%"runtime::Default_Temp_Allocator" = type { %"runtime::Arena" }
%"runtime::Arena" = type { %"runtime::Allocator", ptr, i64, i64, i64, i64 }
%"runtime::Allocator" = type { ptr, ptr }
%"runtime::Thread_Local_Cleaner" = type { ptr, i64 }
%"utf8::Accept_Range" = type { i8, i8 }
%"strconv::Float_Info" = type { i64, i64, i64 }
%"runtime::Type_Info" = type { i64, i64, i32, [4 x i8], i64, { [9 x i64], i64 } }
%"runtime::Type_Info_Struct" = type { ptr, ptr, ptr, ptr, ptr, i32, i8, i8, [2 x i8], i32, [4 x i8], ptr, ptr }
%"runtime::Type_Info_Procedure" = type { ptr, ptr, i8, i8, [6 x i8] }
%"runtime::Type_Info_Integer" = type { i8, i8 }
%"runtime::Type_Info_Named" = type { %..string, ptr, %..string, ptr }
%"runtime::Type_Info_Parameters" = type { { ptr, i64 }, { ptr, i64 } }
%"runtime::Type_Info_Enum" = type { ptr, { ptr, i64 }, { ptr, i64 } }
%"runtime::Type_Info_Boolean" = type {}
%"runtime::Type_Info_Pointer" = type { ptr }
%"runtime::Type_Info_Float" = type { i8 }
%"runtime::Type_Info_Slice" = type { ptr, i64 }
%"runtime::Type_Info_Complex" = type {}
%"runtime::Type_Info_String" = type { i8, i8 }
%"runtime::Type_Info_Multi_Pointer" = type { ptr }
%"runtime::Type_Info_Bit_Set" = type { ptr, ptr, i64, i64 }
%"runtime::Type_Info_Union" = type { { ptr, i64 }, i64, ptr, ptr, i8, i8, i8, [5 x i8] }
%"runtime::Type_Info_Type_Id" = type {}
%"runtime::Type_Info_Rune" = type {}
%"runtime::Source_Code_Location" = type { %..string, i32, i32, %..string }
%"runtime::Default_Random_State" = type { i64, i64 }
%"main::Byte_World" = type { i64, i64, { ptr, i64 }, { ptr, i64 }, %"main::Spark_Buffer", %"main::Spark_Buffer", { ptr, i64 }, i32, i32, i8, [7 x i8], i64 }
%"main::Spark_Buffer" = type { { ptr, i64 }, i64 }
%"runtime::Map_Cell_Info" = type { i64, i64, i64, i64 }
%"io::Stream" = type { ptr, ptr }
%"linux::Time_Spec" = type { i64, i64 }
%"time::Time" = type { i64 }
%"sync::Sema" = type { %"sync::[primitives_internal.odin]::_Sema" }
%"sync::[primitives_internal.odin]::_Sema" = type { %"sync::Atomic_Sema" }
%"sync::Atomic_Sema" = type { i32 }
%"os::Error" = type { i32, i32 }
%"posix::pthread_attr_t" = type { [7 x i64] }
%"posix::rlimit" = type { i64, i64 }
%"posix::sched_param" = type { i32, i32, [4 x i64], i32, [4 x i8] }
%"runtime::Context" = type { %"runtime::Allocator", %"runtime::Allocator", ptr, %"runtime::Logger", %"runtime::Random_Generator", ptr, i64, ptr }
%"runtime::Logger" = type { ptr, ptr, i64, i16, [6 x i8] }
%"runtime::Random_Generator" = type { ptr, ptr }
%"thread::Thread" = type { %"thread::[thread_unix.odin]::Thread_Os_Specific", i8, [7 x i8], i64, ptr, ptr, i64, [8 x ptr], %"runtime::Maybe(T:$runtime::Context)", %"runtime::Allocator" }
%"thread::[thread_unix.odin]::Thread_Os_Specific" = type { i64, %"sync::Sema", [4 x i8] }
%"runtime::Maybe(T:$runtime::Context)" = type { %"runtime::Context", i64 }
%"bufio::Writer" = type { { ptr, i64 }, %"runtime::Allocator", %"io::Stream", i64, i32, [4 x i8], i64 }
%"runtime::Memory_Block" = type { ptr, %"runtime::Allocator", ptr, i64, i64 }
%"strconv_decimal::Decimal" = type { [384 x i8], i64, i64, i8, i8, [6 x i8] }
%"strconv::Decimal_Slice" = type { { ptr, i64 }, i64, i64, i8, [7 x i8] }
%"runtime::Arena_Temp" = type { ptr, ptr, i64 }
%..string16 = type { ptr, i64 }
%"strconv::format_digits::Buffer::$1" = type { { ptr, i64 }, i64 }
%"strings::Builder" = type { { ptr, i64, i64, %"runtime::Allocator" } }
%"main::Pattern" = type { i64, i64, { ptr, i64 }, { ptr, i64, i64, %"runtime::Allocator" } }
%"main::Detected_Blob" = type { %"raylib::Rectangle", float, [4 x i8], i64 }
%"raylib::Rectangle" = type { float, float, float, float }
%"runtime::Type_Info_Soa_Pointer" = type { ptr }
%"runtime::Type_Info_Array" = type { ptr, i64, i64 }
%"runtime::Type_Info_Enumerated_Array" = type { ptr, ptr, i64, i64, i64, i64, i8, [7 x i8] }
%"runtime::Type_Info_Dynamic_Array" = type { ptr, i64 }
%"runtime::Type_Info_Map" = type { ptr, ptr, ptr }
%"runtime::Type_Info_Bit_Field" = type { ptr, ptr, ptr, ptr, ptr, ptr, i64 }
%"runtime::Type_Info_Simd_Vector" = type { ptr, i64, i64 }
%"runtime::Type_Info_Matrix" = type { ptr, i64, i64, i64, i64, i8, [7 x i8] }
%"runtime::Raw_Dynamic_Array" = type { ptr, i64, i64, %"runtime::Allocator" }
%"runtime::Raw_Map" = type { i64, i64, %"runtime::Allocator" }
%"main::Spark" = type { i64, i64, i64, i64, float, i8, [3 x i8], i64, i64, [4 x i8], [4 x i8] }
%"runtime::Map_Info" = type { ptr, ptr, ptr, ptr }
%"runtime::Raw_Slice" = type { ptr, i64 }
%"main::Attempt_Result" = type { i8, [7 x i8], %"main::Spark", i64, i64, i64, i8, [7 x i8], i64, i8, [7 x i8], i64, i8, i8, [6 x i8], %"main::Spark" }
%..any = type { ptr, i64 }
%"runtime::Raw_Soa_Pointer" = type { ptr, i64 }
%"raylib::Image" = type { ptr, i32, i32, i32, i32 }
%"raylib::Texture" = type { i32, i32, i32, i32, i32 }

@"__$type_info_data" = private constant [431 x ptr] [ptr @"__$ti-0", ptr bitcast (ptr @"__$ti-1" to ptr), ptr null, ptr bitcast (ptr @"__$ti-3" to ptr), ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-10" to ptr), ptr bitcast (ptr @"__$ti-11" to ptr), ptr bitcast (ptr @"__$ti-12" to ptr), ptr bitcast (ptr @"__$ti-13" to ptr), ptr bitcast (ptr @"__$ti-14" to ptr), ptr bitcast (ptr @"__$ti-15" to ptr), ptr bitcast (ptr @"__$ti-16" to ptr), ptr bitcast (ptr @"__$ti-17" to ptr), ptr bitcast (ptr @"__$ti-18" to ptr), ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-27" to ptr), ptr bitcast (ptr @"__$ti-28" to ptr), ptr bitcast (ptr @"__$ti-29" to ptr), ptr bitcast (ptr @"__$ti-30" to ptr), ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-34" to ptr), ptr null, ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-39" to ptr), ptr null, ptr bitcast (ptr @"__$ti-41" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-44" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-47" to ptr), ptr bitcast (ptr @"__$ti-48" to ptr), ptr bitcast (ptr @"__$ti-49" to ptr), ptr bitcast (ptr @"__$ti-50" to ptr), ptr bitcast (ptr @"__$ti-51" to ptr), ptr bitcast (ptr @"__$ti-52" to ptr), ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-56" to ptr), ptr bitcast (ptr @"__$ti-57" to ptr), ptr bitcast (ptr @"__$ti-58" to ptr), ptr bitcast (ptr @"__$ti-59" to ptr), ptr bitcast (ptr @"__$ti-60" to ptr), ptr bitcast (ptr @"__$ti-61" to ptr), ptr bitcast (ptr @"__$ti-62" to ptr), ptr bitcast (ptr @"__$ti-63" to ptr), ptr bitcast (ptr @"__$ti-64" to ptr), ptr bitcast (ptr @"__$ti-65" to ptr), ptr bitcast (ptr @"__$ti-66" to ptr), ptr bitcast (ptr @"__$ti-67" to ptr), ptr bitcast (ptr @"__$ti-68" to ptr), ptr bitcast (ptr @"__$ti-69" to ptr), ptr bitcast (ptr @"__$ti-70" to ptr), ptr bitcast (ptr @"__$ti-71" to ptr), ptr bitcast (ptr @"__$ti-72" to ptr), ptr bitcast (ptr @"__$ti-73" to ptr), ptr bitcast (ptr @"__$ti-74" to ptr), ptr bitcast (ptr @"__$ti-75" to ptr), ptr bitcast (ptr @"__$ti-76" to ptr), ptr null, ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-80" to ptr), ptr bitcast (ptr @"__$ti-81" to ptr), ptr bitcast (ptr @"__$ti-82" to ptr), ptr null, ptr bitcast (ptr @"__$ti-84" to ptr), ptr bitcast (ptr @"__$ti-85" to ptr), ptr bitcast (ptr @"__$ti-86" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-89" to ptr), ptr null, ptr bitcast (ptr @"__$ti-91" to ptr), ptr null, ptr null, ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-97" to ptr), ptr null, ptr bitcast (ptr @"__$ti-99" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-102" to ptr), ptr null, ptr bitcast (ptr @"__$ti-104" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-107" to ptr), ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-111" to ptr), ptr bitcast (ptr @"__$ti-112" to ptr), ptr bitcast (ptr @"__$ti-113" to ptr), ptr bitcast (ptr @"__$ti-114" to ptr), ptr bitcast (ptr @"__$ti-115" to ptr), ptr bitcast (ptr @"__$ti-116" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-119" to ptr), ptr bitcast (ptr @"__$ti-120" to ptr), ptr bitcast (ptr @"__$ti-121" to ptr), ptr bitcast (ptr @"__$ti-122" to ptr), ptr bitcast (ptr @"__$ti-123" to ptr), ptr bitcast (ptr @"__$ti-124" to ptr), ptr null, ptr bitcast (ptr @"__$ti-126" to ptr), ptr bitcast (ptr @"__$ti-127" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-130" to ptr), ptr null, ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-135" to ptr), ptr bitcast (ptr @"__$ti-136" to ptr), ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-140" to ptr), ptr bitcast (ptr @"__$ti-141" to ptr), ptr bitcast (ptr @"__$ti-142" to ptr), ptr bitcast (ptr @"__$ti-143" to ptr), ptr bitcast (ptr @"__$ti-144" to ptr), ptr bitcast (ptr @"__$ti-145" to ptr), ptr bitcast (ptr @"__$ti-146" to ptr), ptr bitcast (ptr @"__$ti-147" to ptr), ptr bitcast (ptr @"__$ti-148" to ptr), ptr bitcast (ptr @"__$ti-149" to ptr), ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-157" to ptr), ptr bitcast (ptr @"__$ti-158" to ptr), ptr bitcast (ptr @"__$ti-159" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-162" to ptr), ptr null, ptr bitcast (ptr @"__$ti-164" to ptr), ptr bitcast (ptr @"__$ti-165" to ptr), ptr bitcast (ptr @"__$ti-166" to ptr), ptr bitcast (ptr @"__$ti-167" to ptr), ptr null, ptr bitcast (ptr @"__$ti-169" to ptr), ptr bitcast (ptr @"__$ti-170" to ptr), ptr bitcast (ptr @"__$ti-171" to ptr), ptr bitcast (ptr @"__$ti-172" to ptr), ptr bitcast (ptr @"__$ti-173" to ptr), ptr null, ptr bitcast (ptr @"__$ti-175" to ptr), ptr bitcast (ptr @"__$ti-176" to ptr), ptr bitcast (ptr @"__$ti-177" to ptr), ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-185" to ptr), ptr bitcast (ptr @"__$ti-186" to ptr), ptr bitcast (ptr @"__$ti-187" to ptr), ptr null, ptr bitcast (ptr @"__$ti-189" to ptr), ptr bitcast (ptr @"__$ti-190" to ptr), ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-203" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-206" to ptr), ptr bitcast (ptr @"__$ti-207" to ptr), ptr bitcast (ptr @"__$ti-208" to ptr), ptr null, ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-213" to ptr), ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-220" to ptr), ptr bitcast (ptr @"__$ti-221" to ptr), ptr bitcast (ptr @"__$ti-222" to ptr), ptr bitcast (ptr @"__$ti-223" to ptr), ptr bitcast (ptr @"__$ti-224" to ptr), ptr bitcast (ptr @"__$ti-225" to ptr), ptr bitcast (ptr @"__$ti-226" to ptr), ptr bitcast (ptr @"__$ti-227" to ptr), ptr bitcast (ptr @"__$ti-228" to ptr), ptr bitcast (ptr @"__$ti-229" to ptr), ptr bitcast (ptr @"__$ti-230" to ptr), ptr null, ptr bitcast (ptr @"__$ti-232" to ptr), ptr null, ptr bitcast (ptr @"__$ti-234" to ptr), ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-242" to ptr), ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-246" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-249" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-252" to ptr), ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-256" to ptr), ptr bitcast (ptr @"__$ti-257" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-260" to ptr), ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-264" to ptr), ptr bitcast (ptr @"__$ti-265" to ptr), ptr bitcast (ptr @"__$ti-266" to ptr), ptr null, ptr bitcast (ptr @"__$ti-268" to ptr), ptr null, ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-273" to ptr), ptr null, ptr bitcast (ptr @"__$ti-275" to ptr), ptr bitcast (ptr @"__$ti-276" to ptr), ptr bitcast (ptr @"__$ti-277" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-280" to ptr), ptr bitcast (ptr @"__$ti-281" to ptr), ptr bitcast (ptr @"__$ti-282" to ptr), ptr bitcast (ptr @"__$ti-283" to ptr), ptr bitcast (ptr @"__$ti-284" to ptr), ptr null, ptr bitcast (ptr @"__$ti-286" to ptr), ptr null, ptr bitcast (ptr @"__$ti-288" to ptr), ptr null, ptr bitcast (ptr @"__$ti-290" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-293" to ptr), ptr bitcast (ptr @"__$ti-294" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-297" to ptr), ptr bitcast (ptr @"__$ti-298" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-301" to ptr), ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-314" to ptr), ptr null, ptr bitcast (ptr @"__$ti-316" to ptr), ptr null, ptr bitcast (ptr @"__$ti-318" to ptr), ptr bitcast (ptr @"__$ti-319" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-322" to ptr), ptr bitcast (ptr @"__$ti-323" to ptr), ptr bitcast (ptr @"__$ti-324" to ptr), ptr null, ptr bitcast (ptr @"__$ti-326" to ptr), ptr bitcast (ptr @"__$ti-327" to ptr), ptr bitcast (ptr @"__$ti-328" to ptr), ptr null, ptr bitcast (ptr @"__$ti-330" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-333" to ptr), ptr bitcast (ptr @"__$ti-334" to ptr), ptr bitcast (ptr @"__$ti-335" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-338" to ptr), ptr null, ptr bitcast (ptr @"__$ti-340" to ptr), ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-344" to ptr), ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-348" to ptr), ptr bitcast (ptr @"__$ti-349" to ptr), ptr bitcast (ptr @"__$ti-350" to ptr), ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-354" to ptr), ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-358" to ptr), ptr null, ptr bitcast (ptr @"__$ti-360" to ptr), ptr null, ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-365" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-368" to ptr), ptr null, ptr bitcast (ptr @"__$ti-370" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-373" to ptr), ptr bitcast (ptr @"__$ti-374" to ptr), ptr bitcast (ptr @"__$ti-375" to ptr), ptr bitcast (ptr @"__$ti-376" to ptr), ptr bitcast (ptr @"__$ti-377" to ptr), ptr bitcast (ptr @"__$ti-378" to ptr), ptr bitcast (ptr @"__$ti-379" to ptr), ptr null, ptr null, ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-385" to ptr), ptr bitcast (ptr @"__$ti-386" to ptr), ptr bitcast (ptr @"__$ti-387" to ptr), ptr null, ptr null, ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-393" to ptr), ptr null, ptr bitcast (ptr @"__$ti-395" to ptr), ptr bitcast (ptr @"__$ti-396" to ptr), ptr bitcast (ptr @"__$ti-397" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-400" to ptr), ptr bitcast (ptr @"__$ti-401" to ptr), ptr bitcast (ptr @"__$ti-402" to ptr), ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-406" to ptr), ptr bitcast (ptr @"__$ti-407" to ptr), ptr null, ptr null, ptr bitcast (ptr @"__$ti-410" to ptr), ptr bitcast (ptr @"__$ti-411" to ptr), ptr bitcast (ptr @"__$ti-412" to ptr), ptr bitcast (ptr @"__$ti-413" to ptr), ptr null, ptr null, ptr null, ptr bitcast (ptr @"__$ti-417" to ptr), ptr bitcast (ptr @"__$ti-418" to ptr), ptr bitcast (ptr @"__$ti-419" to ptr), ptr bitcast (ptr @"__$ti-420" to ptr), ptr bitcast (ptr @"__$ti-421" to ptr), ptr bitcast (ptr @"__$ti-422" to ptr), ptr bitcast (ptr @"__$ti-423" to ptr), ptr bitcast (ptr @"__$ti-424" to ptr), ptr bitcast (ptr @"__$ti-425" to ptr), ptr bitcast (ptr @"__$ti-426" to ptr), ptr bitcast (ptr @"__$ti-427" to ptr), ptr null, ptr null, ptr null], section ".odinti"
@"__$type_info_types_data" = private constant [168 x ptr] [ptr bitcast (ptr @"__$ti-82" to ptr), ptr bitcast (ptr @"__$ti-59" to ptr), ptr bitcast (ptr @"__$ti-104" to ptr), ptr bitcast (ptr @"__$ti-104" to ptr), ptr bitcast (ptr @"__$ti-104" to ptr), ptr bitcast (ptr @"__$ti-85" to ptr), ptr bitcast (ptr @"__$ti-223" to ptr), ptr bitcast (ptr @"__$ti-323" to ptr), ptr bitcast (ptr @"__$ti-273" to ptr), ptr bitcast (ptr @"__$ti-104" to ptr), ptr bitcast (ptr @"__$ti-370" to ptr), ptr bitcast (ptr @"__$ti-223" to ptr), ptr bitcast (ptr @"__$ti-422" to ptr), ptr bitcast (ptr @"__$ti-422" to ptr), ptr bitcast (ptr @"__$ti-223" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-59" to ptr), ptr bitcast (ptr @"__$ti-326" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-177" to ptr), ptr bitcast (ptr @"__$ti-115" to ptr), ptr bitcast (ptr @"__$ti-264" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-206" to ptr), ptr bitcast (ptr @"__$ti-348" to ptr), ptr bitcast (ptr @"__$ti-344" to ptr), ptr bitcast (ptr @"__$ti-344" to ptr), ptr bitcast (ptr @"__$ti-206" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-397" to ptr), ptr bitcast (ptr @"__$ti-221" to ptr), ptr bitcast (ptr @"__$ti-284" to ptr), ptr bitcast (ptr @"__$ti-354" to ptr), ptr bitcast (ptr @"__$ti-223" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-223" to ptr), ptr bitcast (ptr @"__$ti-281" to ptr), ptr bitcast (ptr @"__$ti-34" to ptr), ptr bitcast (ptr @"__$ti-34" to ptr), ptr bitcast (ptr @"__$ti-423" to ptr), ptr bitcast (ptr @"__$ti-18" to ptr), ptr bitcast (ptr @"__$ti-370" to ptr), ptr bitcast (ptr @"__$ti-190" to ptr), ptr bitcast (ptr @"__$ti-104" to ptr), ptr bitcast (ptr @"__$ti-119" to ptr), ptr bitcast (ptr @"__$ti-249" to ptr), ptr bitcast (ptr @"__$ti-260" to ptr), ptr bitcast (ptr @"__$ti-420" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-282" to ptr), ptr bitcast (ptr @"__$ti-282" to ptr), ptr bitcast (ptr @"__$ti-119" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-172" to ptr), ptr bitcast (ptr @"__$ti-52" to ptr), ptr bitcast (ptr @"__$ti-52" to ptr), ptr bitcast (ptr @"__$ti-227" to ptr), ptr bitcast (ptr @"__$ti-142" to ptr), ptr bitcast (ptr @"__$ti-232" to ptr), ptr bitcast (ptr @"__$ti-104" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-104" to ptr), ptr bitcast (ptr @"__$ti-223" to ptr), ptr bitcast (ptr @"__$ti-223" to ptr), ptr bitcast (ptr @"__$ti-273" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-213" to ptr), ptr bitcast (ptr @"__$ti-348" to ptr), ptr bitcast (ptr @"__$ti-206" to ptr), ptr bitcast (ptr @"__$ti-344" to ptr), ptr bitcast (ptr @"__$ti-71" to ptr), ptr bitcast (ptr @"__$ti-206" to ptr), ptr bitcast (ptr @"__$ti-422" to ptr), ptr bitcast (ptr @"__$ti-318" to ptr), ptr bitcast (ptr @"__$ti-157" to ptr), ptr bitcast (ptr @"__$ti-422" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-377" to ptr), ptr bitcast (ptr @"__$ti-419" to ptr), ptr bitcast (ptr @"__$ti-104" to ptr), ptr bitcast (ptr @"__$ti-104" to ptr), ptr bitcast (ptr @"__$ti-15" to ptr), ptr bitcast (ptr @"__$ti-297" to ptr), ptr bitcast (ptr @"__$ti-112" to ptr), ptr bitcast (ptr @"__$ti-48" to ptr), ptr bitcast (ptr @"__$ti-365" to ptr), ptr bitcast (ptr @"__$ti-143" to ptr), ptr bitcast (ptr @"__$ti-70" to ptr), ptr bitcast (ptr @"__$ti-123" to ptr), ptr bitcast (ptr @"__$ti-61" to ptr), ptr bitcast (ptr @"__$ti-286" to ptr), ptr bitcast (ptr @"__$ti-349" to ptr), ptr bitcast (ptr @"__$ti-426" to ptr), ptr bitcast (ptr @"__$ti-298" to ptr), ptr bitcast (ptr @"__$ti-252" to ptr), ptr bitcast (ptr @"__$ti-396" to ptr), ptr bitcast (ptr @"__$ti-64" to ptr), ptr bitcast (ptr @"__$ti-412" to ptr), ptr bitcast (ptr @"__$ti-319" to ptr), ptr bitcast (ptr @"__$ti-57" to ptr), ptr bitcast (ptr @"__$ti-107" to ptr), ptr bitcast (ptr @"__$ti-266" to ptr), ptr bitcast (ptr @"__$ti-294" to ptr), ptr bitcast (ptr @"__$ti-81" to ptr), ptr bitcast (ptr @"__$ti-395" to ptr), ptr bitcast (ptr @"__$ti-410" to ptr), ptr bitcast (ptr @"__$ti-144" to ptr), ptr bitcast (ptr @"__$ti-91" to ptr), ptr bitcast (ptr @"__$ti-225" to ptr), ptr bitcast (ptr @"__$ti-284" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-427" to ptr), ptr bitcast (ptr @"__$ti-104" to ptr), ptr bitcast (ptr @"__$ti-85" to ptr), ptr bitcast (ptr @"__$ti-323" to ptr), ptr bitcast (ptr @"__$ti-119" to ptr), ptr bitcast (ptr @"__$ti-172" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-119" to ptr), ptr bitcast (ptr @"__$ti-338" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-419" to ptr), ptr bitcast (ptr @"__$ti-419" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-75" to ptr), ptr bitcast (ptr @"__$ti-82" to ptr), ptr bitcast (ptr @"__$ti-370" to ptr), ptr bitcast (ptr @"__$ti-79" to ptr), ptr bitcast (ptr @"__$ti-377" to ptr), ptr bitcast (ptr @"__$ti-119" to ptr), ptr bitcast (ptr @"__$ti-119" to ptr), ptr bitcast (ptr @"__$ti-119" to ptr), ptr bitcast (ptr @"__$ti-104" to ptr), ptr bitcast (ptr @"__$ti-12" to ptr), ptr bitcast (ptr @"__$ti-225" to ptr), ptr bitcast (ptr @"__$ti-149" to ptr), ptr bitcast (ptr @"__$ti-72" to ptr), ptr bitcast (ptr @"__$ti-104" to ptr), ptr bitcast (ptr @"__$ti-149" to ptr), ptr bitcast (ptr @"__$ti-104" to ptr), ptr bitcast (ptr @"__$ti-39" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-104" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-273" to ptr), ptr bitcast (ptr @"__$ti-78" to ptr), ptr bitcast (ptr @"__$ti-370" to ptr), ptr bitcast (ptr @"__$ti-370" to ptr), ptr bitcast (ptr @"__$ti-370" to ptr), ptr bitcast (ptr @"__$ti-370" to ptr), ptr bitcast (ptr @"__$ti-119" to ptr)], section ".odinti"
@"__$type_info_names_data" = private constant [168 x %..string] [%..string { ptr @"csbs$byte_world$42", i64 5 }, %..string { ptr @"csbs$byte_world$43", i64 5 }, %..string { ptr @"csbs$byte_world$47", i64 3 }, %..string { ptr @"csbs$byte_world$48", i64 3 }, %..string { ptr @"csbs$byte_world$4f", i64 4 }, %..string { ptr @"csbs$byte_world$50", i64 5 }, %..string { ptr @"csbs$byte_world$51", i64 4 }, %..string { ptr @"csbs$byte_world$52", i64 7 }, %..string { ptr @"csbs$byte_world$53", i64 8 }, %..string { ptr @"csbs$byte_world$54", i64 3 }, %..string { ptr @"csbs$byte_world$55", i64 4 }, %..string { ptr @"csbs$byte_world$67", i64 9 }, %..string { ptr @"csbs$byte_world$68", i64 4 }, %..string { ptr @"csbs$byte_world$69", i64 6 }, %..string { ptr @"csbs$byte_world$6a", i64 9 }, %..string { ptr @"csbs$byte_world$6c", i64 4 }, %..string { ptr @"csbs$byte_world$6d", i64 4 }, %..string { ptr @"csbs$byte_world$43", i64 5 }, %..string { ptr @"csbs$byte_world$6e", i64 6 }, %..string { ptr @"csbs$byte_world$79", i64 4 }, %..string { ptr @"csbs$byte_world$7a", i64 5 }, %..string { ptr @"csbs$byte_world$7b", i64 5 }, %..string { ptr @"csbs$byte_world$7c", i64 2 }, %..string { ptr @"csbs$byte_world$7d", i64 7 }, %..string { ptr @"csbs$byte_world$89", i64 12 }, %..string { ptr @"csbs$byte_world$43", i64 5 }, %..string { ptr @"csbs$byte_world$42", i64 5 }, %..string { ptr @"csbs$byte_world$8b", i64 9 }, %..string { ptr @"csbs$byte_world$8c", i64 11 }, %..string { ptr @"csbs$byte_world$8d", i64 4 }, %..string { ptr @"csbs$byte_world$8e", i64 11 }, %..string { ptr @"csbs$byte_world$6c", i64 4 }, %..string { ptr @"csbs$byte_world$8f", i64 9 }, %..string { ptr @"csbs$byte_world$90", i64 5 }, %..string { ptr @"csbs$byte_world$95", i64 4 }, %..string { ptr @"csbs$byte_world$6d", i64 4 }, %..string { ptr @"csbs$byte_world$96", i64 3 }, %..string { ptr @"csbs$byte_world$97", i64 3 }, %..string { ptr @"csbs$byte_world$9f", i64 2 }, %..string { ptr @"csbs$byte_world$a0", i64 2 }, %..string { ptr @"csbs$byte_world$a1", i64 10 }, %..string { ptr @"csbs$byte_world$a2", i64 9 }, %..string zeroinitializer, %..string { ptr @"csbs$byte_world$6a", i64 9 }, %..string { ptr @"csbs$byte_world$4f", i64 4 }, %..string { ptr @"csbs$byte_world$bc", i64 10 }, %..string { ptr @"csbs$byte_world$bd", i64 8 }, %..string { ptr @"csbs$byte_world$6c", i64 4 }, %..string { ptr @"csbs$byte_world$c8", i64 5 }, %..string { ptr @"csbs$byte_world$8f", i64 9 }, %..string { ptr @"csbs$byte_world$90", i64 5 }, %..string { ptr @"csbs$byte_world$c9", i64 9 }, %..string { ptr @"csbs$byte_world$ca", i64 9 }, %..string { ptr @"csbs$byte_world$cb", i64 9 }, %..string { ptr @"csbs$byte_world$d1", i64 1 }, %..string { ptr @"csbs$byte_world$d5", i64 10 }, %..string { ptr @"csbs$byte_world$da", i64 9 }, %..string { ptr @"csbs$byte_world$db", i64 14 }, %..string { ptr @"csbs$byte_world$dc", i64 22 }, %..string { ptr @"csbs$byte_world$dd", i64 6 }, %..string { ptr @"csbs$byte_world$de", i64 16 }, %..string { ptr @"csbs$byte_world$df", i64 8 }, %..string { ptr @"csbs$byte_world$e0", i64 10 }, %..string { ptr @"csbs$byte_world$e1", i64 9 }, %..string { ptr @"csbs$byte_world$e2", i64 6 }, %..string { ptr @"csbs$byte_world$e3", i64 7 }, %..string { ptr @"csbs$byte_world$97", i64 3 }, %..string { ptr @"csbs$byte_world$6c", i64 4 }, %..string { ptr @"csbs$byte_world$8f", i64 9 }, %..string { ptr @"csbs$byte_world$e5", i64 11 }, %..string { ptr @"csbs$byte_world$e6", i64 9 }, %..string { ptr @"csbs$byte_world$e7", i64 12 }, %..string { ptr @"csbs$byte_world$e8", i64 6 }, %..string { ptr @"csbs$byte_world$42", i64 5 }, %..string { ptr @"csbs$byte_world$43", i64 5 }, %..string { ptr @"csbs$byte_world$ef", i64 7 }, %..string { ptr @"csbs$byte_world$f0", i64 6 }, %..string { ptr @"csbs$byte_world$8d", i64 4 }, %..string { ptr @"csbs$byte_world$8e", i64 11 }, %..string { ptr @"csbs$byte_world$7b", i64 5 }, %..string { ptr @"csbs$byte_world$f1", i64 8 }, %..string { ptr @"csbs$byte_world$f2", i64 7 }, %..string { ptr @"csbs$byte_world$f3", i64 13 }, %..string { ptr @"csbs$byte_world$f4", i64 5 }, %..string { ptr @"csbs$byte_world$f6", i64 5 }, %..string { ptr @"csbs$byte_world$f9", i64 1 }, %..string { ptr @"csbs$byte_world$f9", i64 1 }, %..string zeroinitializer, %..string zeroinitializer, %..string { ptr @"csbs$byte_world$6c", i64 4 }, %..string { ptr @"csbs$byte_world$8f", i64 9 }, %..string { ptr @"csbs$byte_world$6a", i64 9 }, %..string { ptr @"csbs$byte_world$4f", i64 4 }, %..string { ptr @"csbs$byte_world$10b", i64 12 }, %..string { ptr @"csbs$byte_world$52", i64 7 }, %..string { ptr @"csbs$byte_world$194", i64 6 }, %..string { ptr @"csbs$byte_world$d5", i64 10 }, %..string { ptr @"csbs$byte_world$197", i64 6 }, %..string { ptr @"csbs$byte_world$198", i64 7 }, %..string { ptr @"csbs$byte_world$199", i64 8 }, %..string { ptr @"csbs$byte_world$19a", i64 10 }, %..string { ptr @"csbs$byte_world$6c", i64 4 }, %..string { ptr @"csbs$byte_world$19b", i64 10 }, %..string { ptr @"csbs$byte_world$19c", i64 5 }, %..string { ptr @"csbs$byte_world$19d", i64 5 }, %..string { ptr @"csbs$byte_world$54", i64 3 }, %..string { ptr @"csbs$byte_world$19e", i64 5 }, %..string { ptr @"csbs$byte_world$19f", i64 8 }, %..string { ptr @"csbs$byte_world$1a0", i64 8 }, %..string { ptr @"csbs$byte_world$1a1", i64 10 }, %..string { ptr @"csbs$byte_world$1a2", i64 8 }, %..string { ptr @"csbs$byte_world$f4", i64 5 }, %..string { ptr @"csbs$byte_world$1a3", i64 12 }, %..string { ptr @"csbs$byte_world$1a4", i64 6 }, %..string { ptr @"csbs$byte_world$1a5", i64 10 }, %..string { ptr @"csbs$byte_world$4f", i64 4 }, %..string { ptr @"csbs$byte_world$1a6", i64 4 }, %..string { ptr @"csbs$byte_world$1a7", i64 1 }, %..string { ptr @"csbs$byte_world$6a", i64 9 }, %..string { ptr @"csbs$byte_world$4f", i64 4 }, %..string { ptr @"csbs$byte_world$d1", i64 1 }, %..string { ptr @"csbs$byte_world$1b9", i64 14 }, %..string { ptr @"csbs$byte_world$1a6", i64 4 }, %..string { ptr @"csbs$byte_world$79", i64 4 }, %..string { ptr @"csbs$byte_world$1ba", i64 9 }, %..string { ptr @"csbs$byte_world$1bb", i64 10 }, %..string { ptr @"csbs$byte_world$1bc", i64 8 }, %..string { ptr @"csbs$byte_world$53", i64 8 }, %..string { ptr @"csbs$byte_world$1c8", i64 12 }, %..string { ptr @"csbs$byte_world$1c9", i64 13 }, %..string { ptr @"csbs$byte_world$1ca", i64 12 }, %..string { ptr @"csbs$byte_world$1cb", i64 17 }, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer], section ".odinti"
@"__$type_info_offsets_data" = private constant [168 x i64] [i64 0, i64 16, i64 0, i64 16, i64 20, i64 24, i64 0, i64 0, i64 8, i64 24, i64 0, i64 8, i64 16, i64 24, i64 32, i64 0, i64 8, i64 16, i64 24, i64 32, i64 40, i64 48, i64 0, i64 8, i64 16, i64 0, i64 16, i64 24, i64 40, i64 0, i64 8, i64 16, i64 24, i64 0, i64 8, i64 0, i64 1, i64 0, i64 8, i64 16, i64 24, i64 32, i64 40, i64 48, i64 0, i64 0, i64 16, i64 32, i64 40, i64 72, i64 88, i64 96, i64 104, i64 0, i64 8, i64 16, i64 24, i64 32, i64 40, i64 0, i64 8, i64 16, i64 24, i64 32, i64 40, i64 44, i64 45, i64 48, i64 56, i64 64, i64 0, i64 0, i64 8, i64 0, i64 8, i64 16, i64 24, i64 0, i64 1, i64 0, i64 8, i64 16, i64 17, i64 0, i64 8, i64 16, i64 24, i64 0, i64 8, i64 16, i64 0, i64 16, i64 24, i64 32, i64 40, i64 41, i64 42, i64 0, i64 8, i64 0, i64 8, i64 16, i64 24, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0, i64 0], section ".odinti"
@"__$type_info_usings_data" = private constant [168 x i8] zeroinitializer, section ".odinti"
@"__$type_info_tags_data" = private constant [168 x %..string] [%..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string { ptr @"csbs$byte_world$8a", i64 19 }, %..string { ptr @"csbs$byte_world$8a", i64 19 }, %..string { ptr @"csbs$byte_world$8a", i64 19 }, %..string { ptr @"csbs$byte_world$8a", i64 19 }, %..string { ptr @"csbs$byte_world$8a", i64 19 }, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string { ptr @"csbs$byte_world$8a", i64 19 }, %..string { ptr @"csbs$byte_world$8a", i64 19 }, %..string { ptr @"csbs$byte_world$8a", i64 19 }, %..string { ptr @"csbs$byte_world$8a", i64 19 }, %..string { ptr @"csbs$byte_world$8a", i64 19 }, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer, %..string zeroinitializer], section ".odinti"
@"runtime::type_table" = internal constant { ptr, i64 } { ptr @"__$type_info_data", i64 431 }, align 8
@"runtime::args__" = internal global { ptr, i64 } zeroinitializer, align 8
@"runtime::global_default_temp_allocator_data" = internal thread_local global %"runtime::Default_Temp_Allocator" zeroinitializer, align 8
@"csbs$byte_world$0" = private constant [37 x i8] c"0123456789abcdefghijklmnopqrstuvwxyz\00", align 1
@"runtime::[print.odin]::_INTEGER_DIGITS_VAR" = internal global %..string { ptr @"csbs$byte_world$0", i64 36 }, align 8
@"runtime::[thread_management.odin]::thread_local_cleaners" = internal global [8 x %"runtime::Thread_Local_Cleaner"] zeroinitializer, align 8
@"main::RANGE_VOID_MAX" = internal global i8 63, align 1
@"main::RANGE_WALL_MAX" = internal global i8 127, align 1
@"main::RANGE_SOLAR_MAX" = internal global i8 -65, align 1
@"main::COST_MOVE" = internal global float 0x3FC99999A0000000, align 4
@"main::COST_WRITE" = internal global float 1.000000e+00, align 4
@"main::COST_WRITE_WALL" = internal global float 2.000000e+00, align 4
@"main::COST_SPLIT" = internal global float 6.000000e+00, align 4
@"main::COST_MATH" = internal global float 0x3FB99999A0000000, align 4
@"main::PENALTY_HIT" = internal global float 5.000000e-01, align 4
@"main::PENALTY_BLOCKED" = internal global float 5.000000e-01, align 4
@"main::SOLAR_BASE_GAIN" = internal global float 0.000000e+00, align 4
@"main::solar_bonus_max_setting" = internal global float 2.000000e+01, align 4
@"main::solar_bonus_max" = internal global float 2.000000e+01, align 4
@"main::SOLAR_DRAIN_PER_HARVEST" = internal global i8 2, align 1
@"main::ENERGY_CAP" = internal global float 5.000000e+02, align 4
@"main::ALPHA_DECAY_PER_TICK" = internal global float 0x3F60624DE0000000, align 4
@"main::ALPHA_GAIN_ON_VISIT" = internal global float 0x3FB70A3D80000000, align 4
@"main::RANDOMIZE_THRESHOLD" = internal global float 0x3FA99999A0000000, align 4
@"main::RANDOMIZE_CHANCE" = internal global float 5.000000e-01, align 4
@"main::OP_LOAD" = internal global i8 -56, align 1
@"main::OP_STORE" = internal global i8 -55, align 1
@"main::OP_SPLIT" = internal global i8 -54, align 1
@"main::OP_LEFT" = internal global i8 -53, align 1
@"main::OP_RIGHT" = internal global i8 -52, align 1
@"main::OP_INC" = internal global i8 -51, align 1
@"main::OP_DEC" = internal global i8 -50, align 1
@"main::OP_BRANCH" = internal global i8 -49, align 1
@"main::OP_SWAP" = internal global i8 -48, align 1
@"main::SPARK_COUNT_MIN" = internal global i64 150000, align 8
@"main::SPARK_MAX_AGE_TICKS" = internal global i64 500, align 8
@"main::SPARK_MAX_SOLAR_WRITES" = internal global i64 2, align 8
@"main::detected_blobs" = internal global { ptr, i64, i64, %"runtime::Allocator" } zeroinitializer, align 8
@"main::detect_alpha_threshold" = internal global float 0x3FBEB851E0000000, align 4
@"main::min_blob_size" = internal global i64 4, align 8
@"main::max_blob_size" = internal global i64 512, align 8
@"main::min_pixel_count" = internal global i64 128, align 8
@"time::days_before" = internal constant [13 x i32] [i32 0, i32 31, i32 59, i32 90, i32 120, i32 151, i32 181, i32 212, i32 243, i32 273, i32 304, i32 334, i32 365], align 4
@"os::args" = internal global { ptr, i64 } zeroinitializer, align 8
@"os::stdout" = internal global i32 1, align 4
@"fmt::_user_formatters" = internal global ptr null, align 8
@"csbs$byte_world$1" = private constant [27 x i8] c" b kib mib gib tib pib eib\00", align 1
@"fmt::__MEMORY_LOWER" = internal global %..string { ptr @"csbs$byte_world$1", i64 26 }, align 8
@"csbs$byte_world$2" = private constant [27 x i8] c" B KiB MiB GiB TiB PiB EiB\00", align 1
@"fmt::__MEMORY_UPPER" = internal global %..string { ptr @"csbs$byte_world$2", i64 26 }, align 8
@"csbs$byte_world$3" = private constant [18 x i8] c"0123456789abcdefx\00", align 1
@"fmt::__DIGITS_LOWER" = internal global %..string { ptr @"csbs$byte_world$3", i64 17 }, align 8
@"csbs$byte_world$4" = private constant [18 x i8] c"0123456789ABCDEFX\00", align 1
@"fmt::__DIGITS_UPPER" = internal global %..string { ptr @"csbs$byte_world$4", i64 17 }, align 8
@"io::[util.odin]::DIGITS_LOWER" = internal global %..string { ptr @"csbs$byte_world$3", i64 17 }, align 8
@"utf8::accept_ranges" = internal global [5 x %"utf8::Accept_Range"] [%"utf8::Accept_Range" { i8 -128, i8 -65 }, %"utf8::Accept_Range" { i8 -96, i8 -65 }, %"utf8::Accept_Range" { i8 -128, i8 -97 }, %"utf8::Accept_Range" { i8 -112, i8 -65 }, %"utf8::Accept_Range" { i8 -128, i8 -113 }], align 1
@"utf8::accept_sizes" = internal global [256 x i8] c"\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F0\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\02\13\03\03\03\03\03\03\03\03\03\03\03\03#\03\034\04\04\04D\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1\F1", align 1
@"strconv::_f16_info" = internal global %"strconv::Float_Info" { i64 10, i64 5, i64 -15 }, align 8
@"strconv::_f32_info" = internal global %"strconv::Float_Info" { i64 23, i64 8, i64 -127 }, align 8
@"strconv::_f64_info" = internal global %"strconv::Float_Info" { i64 52, i64 11, i64 -1023 }, align 8
@"strconv::digits" = internal global %..string { ptr @"csbs$byte_world$0", i64 36 }, align 8
@"csbs$byte_world$5" = private constant [1 x i8] zeroinitializer, align 1
@"csbs$byte_world$6" = private constant [2 x i8] c"5\00", align 1
@"csbs$byte_world$7" = private constant [3 x i8] c"25\00", align 1
@"csbs$byte_world$8" = private constant [4 x i8] c"125\00", align 1
@"csbs$byte_world$9" = private constant [4 x i8] c"625\00", align 1
@"csbs$byte_world$a" = private constant [5 x i8] c"3125\00", align 1
@"csbs$byte_world$b" = private constant [6 x i8] c"15625\00", align 1
@"csbs$byte_world$c" = private constant [6 x i8] c"78125\00", align 1
@"csbs$byte_world$d" = private constant [7 x i8] c"390625\00", align 1
@"csbs$byte_world$e" = private constant [8 x i8] c"1953125\00", align 1
@"csbs$byte_world$f" = private constant [8 x i8] c"9765625\00", align 1
@"csbs$byte_world$10" = private constant [9 x i8] c"48828125\00", align 1
@"csbs$byte_world$11" = private constant [10 x i8] c"244140625\00", align 1
@"csbs$byte_world$12" = private constant [11 x i8] c"1220703125\00", align 1
@"csbs$byte_world$13" = private constant [11 x i8] c"6103515625\00", align 1
@"csbs$byte_world$14" = private constant [12 x i8] c"30517578125\00", align 1
@"csbs$byte_world$15" = private constant [13 x i8] c"152587890625\00", align 1
@"csbs$byte_world$16" = private constant [13 x i8] c"762939453125\00", align 1
@"csbs$byte_world$17" = private constant [14 x i8] c"3814697265625\00", align 1
@"csbs$byte_world$18" = private constant [15 x i8] c"19073486328125\00", align 1
@"csbs$byte_world$19" = private constant [15 x i8] c"95367431640625\00", align 1
@"csbs$byte_world$1a" = private constant [16 x i8] c"476837158203125\00", align 1
@"csbs$byte_world$1b" = private constant [17 x i8] c"2384185791015625\00", align 1
@"csbs$byte_world$1c" = private constant [18 x i8] c"11920928955078125\00", align 1
@"csbs$byte_world$1d" = private constant [18 x i8] c"59604644775390625\00", align 1
@"csbs$byte_world$1e" = private constant [19 x i8] c"298023223876953125\00", align 1
@"csbs$byte_world$1f" = private constant [20 x i8] c"1490116119384765625\00", align 1
@"csbs$byte_world$20" = private constant [20 x i8] c"7450580596923828125\00", align 1
@"csbs$byte_world$21" = private constant [21 x i8] c"37252902984619140625\00", align 1
@"csbs$byte_world$22" = private constant [22 x i8] c"186264514923095703125\00", align 1
@"csbs$byte_world$23" = private constant [22 x i8] c"931322574615478515625\00", align 1
@"csbs$byte_world$24" = private constant [23 x i8] c"4656612873077392578125\00", align 1
@"csbs$byte_world$25" = private constant [24 x i8] c"23283064365386962890625\00", align 1
@"csbs$byte_world$26" = private constant [25 x i8] c"116415321826934814453125\00", align 1
@"csbs$byte_world$27" = private constant [25 x i8] c"582076609134674072265625\00", align 1
@"csbs$byte_world$28" = private constant [26 x i8] c"2910383045673370361328125\00", align 1
@"csbs$byte_world$29" = private constant [27 x i8] c"14551915228366851806640625\00", align 1
@"csbs$byte_world$2a" = private constant [27 x i8] c"72759576141834259033203125\00", align 1
@"csbs$byte_world$2b" = private constant [28 x i8] c"363797880709171295166015625\00", align 1
@"csbs$byte_world$2c" = private constant [29 x i8] c"1818989403545856475830078125\00", align 1
@"csbs$byte_world$2d" = private constant [29 x i8] c"9094947017729282379150390625\00", align 1
@"csbs$byte_world$2e" = private constant [30 x i8] c"45474735088646411895751953125\00", align 1
@"csbs$byte_world$2f" = private constant [31 x i8] c"227373675443232059478759765625\00", align 1
@"csbs$byte_world$30" = private constant [32 x i8] c"1136868377216160297393798828125\00", align 1
@"csbs$byte_world$31" = private constant [32 x i8] c"5684341886080801486968994140625\00", align 1
@"csbs$byte_world$32" = private constant [33 x i8] c"28421709430404007434844970703125\00", align 1
@"csbs$byte_world$33" = private constant [34 x i8] c"142108547152020037174224853515625\00", align 1
@"csbs$byte_world$34" = private constant [34 x i8] c"710542735760100185871124267578125\00", align 1
@"csbs$byte_world$35" = private constant [35 x i8] c"3552713678800500929355621337890625\00", align 1
@"csbs$byte_world$36" = private constant [36 x i8] c"17763568394002504646778106689453125\00", align 1
@"csbs$byte_world$37" = private constant [36 x i8] c"88817841970012523233890533447265625\00", align 1
@"csbs$byte_world$38" = private constant [37 x i8] c"444089209850062616169452667236328125\00", align 1
@"csbs$byte_world$39" = private constant [38 x i8] c"2220446049250313080847263336181640625\00", align 1
@"csbs$byte_world$3a" = private constant [39 x i8] c"11102230246251565404236316680908203125\00", align 1
@"csbs$byte_world$3b" = private constant [39 x i8] c"55511151231257827021181583404541015625\00", align 1
@"csbs$byte_world$3c" = private constant [40 x i8] c"277555756156289135105907917022705078125\00", align 1
@"csbs$byte_world$3d" = private constant [41 x i8] c"1387778780781445675529539585113525390625\00", align 1
@"csbs$byte_world$3e" = private constant [41 x i8] c"6938893903907228377647697925567626953125\00", align 1
@"csbs$byte_world$3f" = private constant [42 x i8] c"34694469519536141888238489627838134765625\00", align 1
@"csbs$byte_world$40" = private constant [43 x i8] c"173472347597680709441192448139190673828125\00", align 1
@"csbs$byte_world$41" = private constant [43 x i8] c"867361737988403547205962240695953369140625\00", align 1
@"strconv_decimal::[decimal.odin]::_shift_left_offsets" = internal global [61 x { i64, %..string }] [{ i64, %..string } zeroinitializer, { i64, %..string } { i64 1, %..string { ptr @"csbs$byte_world$6", i64 1 } }, { i64, %..string } { i64 1, %..string { ptr @"csbs$byte_world$7", i64 2 } }, { i64, %..string } { i64 1, %..string { ptr @"csbs$byte_world$8", i64 3 } }, { i64, %..string } { i64 2, %..string { ptr @"csbs$byte_world$9", i64 3 } }, { i64, %..string } { i64 2, %..string { ptr @"csbs$byte_world$a", i64 4 } }, { i64, %..string } { i64 2, %..string { ptr @"csbs$byte_world$b", i64 5 } }, { i64, %..string } { i64 3, %..string { ptr @"csbs$byte_world$c", i64 5 } }, { i64, %..string } { i64 3, %..string { ptr @"csbs$byte_world$d", i64 6 } }, { i64, %..string } { i64 3, %..string { ptr @"csbs$byte_world$e", i64 7 } }, { i64, %..string } { i64 4, %..string { ptr @"csbs$byte_world$f", i64 7 } }, { i64, %..string } { i64 4, %..string { ptr @"csbs$byte_world$10", i64 8 } }, { i64, %..string } { i64 4, %..string { ptr @"csbs$byte_world$11", i64 9 } }, { i64, %..string } { i64 4, %..string { ptr @"csbs$byte_world$12", i64 10 } }, { i64, %..string } { i64 5, %..string { ptr @"csbs$byte_world$13", i64 10 } }, { i64, %..string } { i64 5, %..string { ptr @"csbs$byte_world$14", i64 11 } }, { i64, %..string } { i64 5, %..string { ptr @"csbs$byte_world$15", i64 12 } }, { i64, %..string } { i64 6, %..string { ptr @"csbs$byte_world$16", i64 12 } }, { i64, %..string } { i64 6, %..string { ptr @"csbs$byte_world$17", i64 13 } }, { i64, %..string } { i64 6, %..string { ptr @"csbs$byte_world$18", i64 14 } }, { i64, %..string } { i64 7, %..string { ptr @"csbs$byte_world$19", i64 14 } }, { i64, %..string } { i64 7, %..string { ptr @"csbs$byte_world$1a", i64 15 } }, { i64, %..string } { i64 7, %..string { ptr @"csbs$byte_world$1b", i64 16 } }, { i64, %..string } { i64 7, %..string { ptr @"csbs$byte_world$1c", i64 17 } }, { i64, %..string } { i64 8, %..string { ptr @"csbs$byte_world$1d", i64 17 } }, { i64, %..string } { i64 8, %..string { ptr @"csbs$byte_world$1e", i64 18 } }, { i64, %..string } { i64 8, %..string { ptr @"csbs$byte_world$1f", i64 19 } }, { i64, %..string } { i64 9, %..string { ptr @"csbs$byte_world$20", i64 19 } }, { i64, %..string } { i64 9, %..string { ptr @"csbs$byte_world$21", i64 20 } }, { i64, %..string } { i64 9, %..string { ptr @"csbs$byte_world$22", i64 21 } }, { i64, %..string } { i64 10, %..string { ptr @"csbs$byte_world$23", i64 21 } }, { i64, %..string } { i64 10, %..string { ptr @"csbs$byte_world$24", i64 22 } }, { i64, %..string } { i64 10, %..string { ptr @"csbs$byte_world$25", i64 23 } }, { i64, %..string } { i64 10, %..string { ptr @"csbs$byte_world$26", i64 24 } }, { i64, %..string } { i64 11, %..string { ptr @"csbs$byte_world$27", i64 24 } }, { i64, %..string } { i64 11, %..string { ptr @"csbs$byte_world$28", i64 25 } }, { i64, %..string } { i64 11, %..string { ptr @"csbs$byte_world$29", i64 26 } }, { i64, %..string } { i64 12, %..string { ptr @"csbs$byte_world$2a", i64 26 } }, { i64, %..string } { i64 12, %..string { ptr @"csbs$byte_world$2b", i64 27 } }, { i64, %..string } { i64 12, %..string { ptr @"csbs$byte_world$2c", i64 28 } }, { i64, %..string } { i64 13, %..string { ptr @"csbs$byte_world$2d", i64 28 } }, { i64, %..string } { i64 13, %..string { ptr @"csbs$byte_world$2e", i64 29 } }, { i64, %..string } { i64 13, %..string { ptr @"csbs$byte_world$2f", i64 30 } }, { i64, %..string } { i64 13, %..string { ptr @"csbs$byte_world$30", i64 31 } }, { i64, %..string } { i64 14, %..string { ptr @"csbs$byte_world$31", i64 31 } }, { i64, %..string } { i64 14, %..string { ptr @"csbs$byte_world$32", i64 32 } }, { i64, %..string } { i64 14, %..string { ptr @"csbs$byte_world$33", i64 33 } }, { i64, %..string } { i64 15, %..string { ptr @"csbs$byte_world$34", i64 33 } }, { i64, %..string } { i64 15, %..string { ptr @"csbs$byte_world$35", i64 34 } }, { i64, %..string } { i64 15, %..string { ptr @"csbs$byte_world$36", i64 35 } }, { i64, %..string } { i64 16, %..string { ptr @"csbs$byte_world$37", i64 35 } }, { i64, %..string } { i64 16, %..string { ptr @"csbs$byte_world$38", i64 36 } }, { i64, %..string } { i64 16, %..string { ptr @"csbs$byte_world$39", i64 37 } }, { i64, %..string } { i64 16, %..string { ptr @"csbs$byte_world$3a", i64 38 } }, { i64, %..string } { i64 17, %..string { ptr @"csbs$byte_world$3b", i64 38 } }, { i64, %..string } { i64 17, %..string { ptr @"csbs$byte_world$3c", i64 39 } }, { i64, %..string } { i64 17, %..string { ptr @"csbs$byte_world$3d", i64 40 } }, { i64, %..string } { i64 18, %..string { ptr @"csbs$byte_world$3e", i64 40 } }, { i64, %..string } { i64 18, %..string { ptr @"csbs$byte_world$3f", i64 41 } }, { i64, %..string } { i64 18, %..string { ptr @"csbs$byte_world$40", i64 42 } }, { i64, %..string } { i64 19, %..string { ptr @"csbs$byte_world$41", i64 42 } }], align 8
@"__$ti-0" = private constant %"runtime::Type_Info" zeroinitializer, section ".odinti"
@"__$ti-1" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 32, i64 8, i32 0, i32 0, i64 -6754473761714560891, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr @"__$type_info_types_data", ptr @"__$type_info_names_data", ptr @"__$type_info_offsets_data", ptr @"__$type_info_usings_data", ptr @"__$type_info_tags_data", i32 2, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-3" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 5071037445314999350, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> <{ %"runtime::Type_Info_Procedure" { ptr null, ptr null, i8 0, i8 2, [6 x i8] zeroinitializer }, [48 x i8] zeroinitializer, i64 13 }> }, section ".odinti"
@"__$ti-10" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 2, i64 2, i32 3, i32 0, i64 1794441955442150916, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 0, i8 1 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-11" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 16, i64 16, i32 3, i32 0, i64 6456938839694704040, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 1, i8 2 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-12" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -4477858244961563476, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$46", i64 21 }, ptr bitcast (ptr @"__$ti-277" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[8879]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-13" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> } { i64 16, i64 8, i32 0, i32 0, i64 5351883198283916430, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> <{ %"runtime::Type_Info_Parameters" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 2), i64 2 }, { ptr, i64 } { ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 2), i64 2 } }, [40 x i8] zeroinitializer, i64 18 }> }, section ".odinti"
@"__$ti-14" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 -1368669801029944614, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-424" to ptr), { ptr, i64 } { ptr @"$enum_names-14", i64 5 }, { ptr, i64 } { ptr @"$enum_values-14", i64 5 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-15" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 48, i64 8, i32 1, i32 0, i64 -228572935251753258, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$4e", i64 15 }, ptr bitcast (ptr @"__$ti-89" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[1778]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-16" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Boolean", [72 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 -28046234913368976, <{ %"runtime::Type_Info_Boolean", [72 x i8], i64 }> <{ %"runtime::Type_Info_Boolean" zeroinitializer, [72 x i8] zeroinitializer, i64 8 }> }, section ".odinti"
@"__$ti-17" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> } { i64 80, i64 8, i32 0, i32 0, i64 8225483402072788119, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> <{ %"runtime::Type_Info_Parameters" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 4), i64 5 }, { ptr, i64 } { ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 4), i64 5 } }, [40 x i8] zeroinitializer, i64 18 }> }, section ".odinti"
@"__$ti-18" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -5873018755720606788, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> <{ %"runtime::Type_Info_Procedure" { ptr bitcast (ptr @"__$ti-13" to ptr), ptr bitcast (ptr @"__$ti-417" to ptr), i8 0, i8 2, [6 x i8] zeroinitializer }, [48 x i8] zeroinitializer, i64 13 }> }, section ".odinti"
@"__$ti-27" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -6897960621469323869, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> <{ %"runtime::Type_Info_Procedure" { ptr bitcast (ptr @"__$ti-333" to ptr), ptr null, i8 0, i8 1, [6 x i8] zeroinitializer }, [48 x i8] zeroinitializer, i64 13 }> }, section ".odinti"
@"__$ti-28" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 5228172967694261231, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 0, i8 2 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-29" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> } { i64 16, i64 8, i32 0, i32 0, i64 -5899132812929167358, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> <{ %"runtime::Type_Info_Parameters" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 9), i64 2 }, { ptr, i64 } { ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 9), i64 2 } }, [40 x i8] zeroinitializer, i64 18 }> }, section ".odinti"
@"__$ti-30" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 8972221258932963553, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-158" to ptr), { ptr, i64 } { ptr @"$enum_names-30", i64 17 }, { ptr, i64 } { ptr @"$enum_values-30", i64 17 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-34" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -7344066247721787767, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> <{ %"runtime::Type_Info_Pointer" { ptr bitcast (ptr @"__$ti-379" to ptr) }, [64 x i8] zeroinitializer, i64 11 }> }, section ".odinti"
@"__$ti-39" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 504559183004898814, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$66", i64 14 }, ptr bitcast (ptr @"__$ti-374" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[7301]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-41" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 16, i64 16, i32 3, i32 0, i64 -685200143679238842, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 0, i8 1 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-44" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 40, i64 8, i32 1, i32 0, i64 -2021252358283990103, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 11), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 11), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 2), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 2), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 2), i32 4, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr @"__$equal-16425491715425561513" }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-47" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 4128981603702996129, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" zeroinitializer, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-48" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 1572704920415854741, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$6b", i64 15 }, ptr bitcast (ptr @"__$ti-176" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[2000]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-49" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 -9038425911605975260, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 0, i8 2 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-50" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -8361281380547813534, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 15), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 15), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 6), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 6), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 6), i32 1, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-51" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 40, i64 8, i32 0, i32 0, i64 -6903915933165422840, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 16), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 16), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 7), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 7), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 7), i32 3, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-52" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 16, i64 8, i32 3, i32 0, i64 -1237939156007145500, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$6f", i64 9 }, ptr bitcast (ptr @"__$ti-360" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[8066]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-56" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 627981701265227156, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 1, i8 0 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-57" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 72, i64 8, i32 3, i32 0, i64 6787164657529017328, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$70", i64 16 }, ptr bitcast (ptr @"__$ti-228" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[3385]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-58" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> } { i64 4, i64 4, i32 1, i32 0, i64 8772878353840857269, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> <{ %"runtime::Type_Info_Float" { i8 2 }, [71 x i8] zeroinitializer, i64 4 }> }, section ".odinti"
@"__$ti-59" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Slice", [56 x i8], i64 }> } { i64 16, i64 8, i32 0, i32 0, i64 -5341896402994095400, <{ %"runtime::Type_Info_Slice", [56 x i8], i64 }> <{ %"runtime::Type_Info_Slice" { ptr bitcast (ptr @"__$ti-223" to ptr), i64 16 }, [56 x i8] zeroinitializer, i64 17 }> }, section ".odinti"
@"__$ti-60" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 5563585020063213298, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" zeroinitializer, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-61" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 0, i64 1, i32 3, i32 0, i64 1925566659224994301, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$71", i64 13 }, ptr bitcast (ptr @"__$ti-256" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[2259]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-62" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 1125346318406038797, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$72", i64 13 }, ptr bitcast (ptr @"__$ti-67" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[8441]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-63" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Complex", [72 x i8], i64 }> } { i64 8, i64 4, i32 1, i32 0, i64 7312419464253483109, <{ %"runtime::Type_Info_Complex", [72 x i8], i64 }> <{ %"runtime::Type_Info_Complex" zeroinitializer, [72 x i8] zeroinitializer, i64 5 }> }, section ".odinti"
@"__$ti-64" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 16, i64 8, i32 3, i32 0, i64 -5912920500250652312, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$73", i64 23 }, ptr bitcast (ptr @"__$ti-288" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[2933]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-65" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 8754543357277165910, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-47" to ptr), { ptr, i64 } { ptr @"$enum_names-65", i64 5 }, { ptr, i64 } { ptr @"$enum_values-65", i64 5 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-66" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 112, i64 8, i32 0, i32 0, i64 -5836036215382700881, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 19), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 19), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 10), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 10), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 10), i32 5, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-67" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -7083746222495577804, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-78" to ptr), { ptr, i64 } { ptr @"$enum_names-67", i64 9 }, { ptr, i64 } { ptr @"$enum_values-67", i64 9 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-68" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -2706828863077372834, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> <{ %"runtime::Type_Info_Procedure" { ptr bitcast (ptr @"__$ti-385" to ptr), ptr bitcast (ptr @"__$ti-265" to ptr), i8 0, i8 1, [6 x i8] zeroinitializer }, [48 x i8] zeroinitializer, i64 13 }> }, section ".odinti"
@"__$ti-69" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_String", [70 x i8], i64 }> } { i64 8, i64 8, i32 1, i32 0, i64 -1464970187221192565, <{ %"runtime::Type_Info_String", [70 x i8], i64 }> <{ %"runtime::Type_Info_String" { i8 1, i8 0 }, [70 x i8] zeroinitializer, i64 7 }> }, section ".odinti"
@"__$ti-70" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 2, i64 1, i32 3, i32 0, i64 -767000295292509400, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$87", i64 16 }, ptr bitcast (ptr @"__$ti-135" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[2133]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-71" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Multi_Pointer", [64 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 8947959708906198199, <{ %"runtime::Type_Info_Multi_Pointer", [64 x i8], i64 }> <{ %"runtime::Type_Info_Multi_Pointer" { ptr bitcast (ptr @"__$ti-119" to ptr) }, [64 x i8] zeroinitializer, i64 12 }> }, section ".odinti"
@"__$ti-72" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 7054410602389480549, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$88", i64 14 }, ptr bitcast (ptr @"__$ti-68" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[7767]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-73" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 56, i64 8, i32 3, i32 0, i64 -7961805728895535790, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 24), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 24), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 15), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 15), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 15), i32 7, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-74" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Bit_Set", [40 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -3336134048266864149, <{ %"runtime::Type_Info_Bit_Set", [40 x i8], i64 }> <{ %"runtime::Type_Info_Bit_Set" { ptr bitcast (ptr @"__$ti-78" to ptr), ptr null, i64 0, i64 63 }, [40 x i8] zeroinitializer, i64 23 }> }, section ".odinti"
@"__$ti-75" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -1261732677558126796, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> <{ %"runtime::Type_Info_Pointer" { ptr bitcast (ptr @"__$ti-80" to ptr) }, [64 x i8] zeroinitializer, i64 11 }> }, section ".odinti"
@"__$ti-76" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 24, i64 8, i32 3, i32 0, i64 -250611587075137892, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 31), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 31), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 22), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 22), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 22), i32 3, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-78" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 3143511548502526014, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 1, i8 0 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-79" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 5425056217122873212, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> <{ %"runtime::Type_Info_Pointer" { ptr bitcast (ptr @"__$ti-340" to ptr) }, [64 x i8] zeroinitializer, i64 11 }> }, section ".odinti"
@"__$ti-80" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 32, i64 8, i32 3, i32 0, i64 -4981770210676301280, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$92", i64 8 }, ptr bitcast (ptr @"__$ti-121" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[12485]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-81" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 32, i64 8, i32 3, i32 0, i64 1629818188697642811, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$93", i64 17 }, ptr bitcast (ptr @"__$ti-324" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[4480]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-82" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Slice", [56 x i8], i64 }> } { i64 16, i64 8, i32 0, i32 0, i64 -335353627107927300, <{ %"runtime::Type_Info_Slice", [56 x i8], i64 }> <{ %"runtime::Type_Info_Slice" { ptr bitcast (ptr @"__$ti-79" to ptr), i64 8 }, [56 x i8] zeroinitializer, i64 17 }> }, section ".odinti"
@"__$ti-84" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Union", [24 x i8], i64 }> } { i64 8, i64 4, i32 1, i32 0, i64 1905637414496559711, <{ %"runtime::Type_Info_Union", [24 x i8], i64 }> <{ %"runtime::Type_Info_Union" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 34), i64 4 }, i64 4, ptr bitcast (ptr @"__$ti-158" to ptr), ptr @"__$equal-1905637414496559711", i8 0, i8 0, i8 1, [5 x i8] zeroinitializer }, [24 x i8] zeroinitializer, i64 20 }> }, section ".odinti"
@"__$ti-85" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 2573987627620921434, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$94", i64 12 }, ptr bitcast (ptr @"__$ti-65" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[8336]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-86" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 2, i64 2, i32 3, i32 0, i64 -5490794129068716592, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 1, i8 1 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-89" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 48, i64 8, i32 1, i32 0, i64 7674627286601529764, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 38), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 34), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 25), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 25), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 25), i32 4, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr @"__$equal-7674627286601529764" }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-91" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 56, i64 8, i32 3, i32 0, i64 2895188154287741119, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$98", i64 19 }, ptr bitcast (ptr @"__$ti-73" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[5091]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-97" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 16, i64 8, i32 0, i32 0, i64 -1803775106185419827, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" zeroinitializer, [24 x i8] zeroinitializer, i64 9 }> }, section ".odinti"
@"__$ti-99" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -4373431679319052159, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> <{ %"runtime::Type_Info_Procedure" { ptr bitcast (ptr @"__$ti-17" to ptr), ptr null, i8 0, i8 1, [6 x i8] zeroinitializer }, [48 x i8] zeroinitializer, i64 13 }> }, section ".odinti"
@"__$ti-102" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -7001683558490961466, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> <{ %"runtime::Type_Info_Procedure" { ptr null, ptr null, i8 0, i8 1, [6 x i8] zeroinitializer }, [48 x i8] zeroinitializer, i64 13 }> }, section ".odinti"
@"__$ti-104" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 6926310670301449333, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> <{ %"runtime::Type_Info_Pointer" zeroinitializer, [64 x i8] zeroinitializer, i64 11 }> }, section ".odinti"
@"__$ti-107" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 48, i64 8, i32 0, i32 0, i64 -9078679547274190364, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$99", i64 15 }, ptr bitcast (ptr @"__$ti-328" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[4001]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-111" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_String", [70 x i8], i64 }> } { i64 16, i64 8, i32 1, i32 0, i64 1875228532289990663, <{ %"runtime::Type_Info_String", [70 x i8], i64 }> <{ %"runtime::Type_Info_String" { i8 0, i8 1 }, [70 x i8] zeroinitializer, i64 7 }> }, section ".odinti"
@"__$ti-112" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 0, i64 1, i32 3, i32 0, i64 8239322296867315277, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$9a", i64 14 }, ptr bitcast (ptr @"__$ti-256" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[1966]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-113" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 2963598964332556101, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-424" to ptr), { ptr, i64 } { ptr @"$enum_names-113", i64 2 }, { ptr, i64 } { ptr @"$enum_values-113", i64 2 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-114" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 16, i64 8, i32 3, i32 0, i64 -6367375062013229273, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$9e", i64 13 }, ptr bitcast (ptr @"__$ti-386" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[61]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-115" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Type_Id", [72 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 7569159263750975288, <{ %"runtime::Type_Info_Type_Id", [72 x i8], i64 }> <{ %"runtime::Type_Info_Type_Id" zeroinitializer, [72 x i8] zeroinitializer, i64 10 }> }, section ".odinti"
@"__$ti-116" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Bit_Set", [40 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 7801516760065285173, <{ %"runtime::Type_Info_Bit_Set", [40 x i8], i64 }> <{ %"runtime::Type_Info_Bit_Set" { ptr bitcast (ptr @"__$ti-418" to ptr), ptr bitcast (ptr @"__$ti-424" to ptr), i64 0, i64 3 }, [40 x i8] zeroinitializer, i64 23 }> }, section ".odinti"
@"__$ti-119" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Boolean", [72 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 -3661474206510476099, <{ %"runtime::Type_Info_Boolean", [72 x i8], i64 }> <{ %"runtime::Type_Info_Boolean" zeroinitializer, [72 x i8] zeroinitializer, i64 8 }> }, section ".odinti"
@"__$ti-120" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 5706570790469228042, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 1, i8 1 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-121" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 32, i64 8, i32 3, i32 0, i64 -3839131486338858648, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 42), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 38), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 29), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 29), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 29), i32 4, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-122" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 -6749875568849071660, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-422" to ptr), { ptr, i64 } { ptr @"$enum_names-122", i64 16 }, { ptr, i64 } { ptr @"$enum_values-122", i64 16 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-123" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 0, i64 1, i32 3, i32 0, i64 3459824800776741135, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$b2", i64 17 }, ptr bitcast (ptr @"__$ti-256" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[2225]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-124" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 -1716045033917819454, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-424" to ptr), { ptr, i64 } { ptr @"$enum_names-124", i64 10 }, { ptr, i64 } { ptr @"$enum_values-124", i64 10 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-126" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> } { i64 8, i64 8, i32 0, i32 0, i64 7665722624199734016, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> <{ %"runtime::Type_Info_Parameters" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 46), i64 1 }, { ptr, i64 } { ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 42), i64 1 } }, [40 x i8] zeroinitializer, i64 18 }> }, section ".odinti"
@"__$ti-127" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 16, i64 8, i32 3, i32 0, i64 5904239340651058567, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 47), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 43), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 33), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 33), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 33), i32 2, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-130" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -7511125261060209526, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> <{ %"runtime::Type_Info_Procedure" { ptr bitcast (ptr @"__$ti-257" to ptr), ptr bitcast (ptr @"__$ti-417" to ptr), i8 0, i8 2, [6 x i8] zeroinitializer }, [48 x i8] zeroinitializer, i64 13 }> }, section ".odinti"
@"__$ti-135" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 2, i64 1, i32 3, i32 0, i64 8717449847940158842, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 49), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 45), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 35), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 35), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 35), i32 2, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-136" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Union", [24 x i8], i64 }> } { i64 16, i64 8, i32 1, i32 0, i64 -6025775406284868334, <{ %"runtime::Type_Info_Union", [24 x i8], i64 }> <{ %"runtime::Type_Info_Union" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 51), i64 2 }, i64 8, ptr bitcast (ptr @"__$ti-60" to ptr), ptr @"__$equal-12420968667424683282", i8 0, i8 0, i8 1, [5 x i8] zeroinitializer }, [24 x i8] zeroinitializer, i64 20 }> }, section ".odinti"
@"__$ti-140" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Boolean", [72 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -30838994448457241, <{ %"runtime::Type_Info_Boolean", [72 x i8], i64 }> <{ %"runtime::Type_Info_Boolean" zeroinitializer, [72 x i8] zeroinitializer, i64 8 }> }, section ".odinti"
@"__$ti-141" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> } { i64 2, i64 2, i32 1, i32 0, i64 -2496036423222030390, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> <{ %"runtime::Type_Info_Float" zeroinitializer, [71 x i8] zeroinitializer, i64 4 }> }, section ".odinti"
@"__$ti-142" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 32, i64 8, i32 3, i32 0, i64 -3071475290372096365, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$be", i64 6 }, ptr bitcast (ptr @"__$ti-301" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[8745]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-143" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 0, i64 1, i32 3, i32 0, i64 -6837063262542311331, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$bf", i64 20 }, ptr bitcast (ptr @"__$ti-256" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[2099]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-144" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 3637780174786766564, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$c0", i64 21 }, ptr bitcast (ptr @"__$ti-50" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[5036]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-145" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -4927224781414164743, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$80", i64 4 }, ptr bitcast (ptr @"__$ti-242" to ptr), %..string { ptr @"csbs$byte_world$c1", i64 4 }, ptr @"scl$[1343]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-146" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -342511356521754101, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 1, i8 2 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-147" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 2, i64 2, i32 3, i32 0, i64 1803998910512668678, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 0, i8 2 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-148" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 -759826189381930289, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$c5", i64 13 }, ptr bitcast (ptr @"__$ti-407" to ptr), %..string { ptr @"csbs$byte_world$c3", i64 6 }, ptr @"scl$[37936]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-149" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 112, i64 8, i32 3, i32 0, i64 5965079329712793378, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$c6", i64 7 }, ptr bitcast (ptr @"__$ti-187" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[9315]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-157" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 3521069050933063413, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$c7", i64 25 }, ptr bitcast (ptr @"__$ti-283" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[1590]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-158" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 5560783464435099345, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" zeroinitializer, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-159" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 32, i64 8, i32 1, i32 0, i64 -4591387458462580390, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" zeroinitializer, [24 x i8] zeroinitializer, i64 6 }> }, section ".odinti"
@"__$ti-162" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> } { i64 4, i64 4, i32 1, i32 0, i64 8774580397840949447, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> <{ %"runtime::Type_Info_Float" { i8 1 }, [71 x i8] zeroinitializer, i64 4 }> }, section ".odinti"
@"__$ti-164" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 56, i64 8, i32 3, i32 0, i64 -8111629371959644262, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 53), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 47), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 37), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 37), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 37), i32 7, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-165" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 16, i64 4, i32 1, i32 0, i64 -6426609804413768290, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" zeroinitializer, [24 x i8] zeroinitializer, i64 6 }> }, section ".odinti"
@"__$ti-166" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 1205768703186031456, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-424" to ptr), { ptr, i64 } { ptr @"$enum_names-166", i64 3 }, { ptr, i64 } { ptr @"$enum_values-166", i64 3 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-167" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -5835746284579901746, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> <{ %"runtime::Type_Info_Pointer" { ptr bitcast (ptr @"__$ti-282" to ptr) }, [64 x i8] zeroinitializer, i64 11 }> }, section ".odinti"
@"__$ti-169" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 5241424281834811053, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 0, i8 1 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-170" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 16, i64 8, i32 1, i32 0, i64 6869193224051083778, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$d0", i64 20 }, ptr bitcast (ptr @"__$ti-136" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[132]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-171" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> } { i64 8, i64 8, i32 0, i32 0, i64 2828459884955685441, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> <{ %"runtime::Type_Info_Parameters" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 60), i64 1 }, { ptr, i64 } { ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 54), i64 1 } }, [40 x i8] zeroinitializer, i64 18 }> }, section ".odinti"
@"__$ti-172" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 -7606085935668424491, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$d2", i64 19 }, ptr bitcast (ptr @"__$ti-166" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[1222]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-173" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 2, i32 1, i32 0, i64 -894390372112463185, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" zeroinitializer, [24 x i8] zeroinitializer, i64 6 }> }, section ".odinti"
@"__$ti-175" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 4, i32 1, i32 0, i64 2903949826564588487, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$77", i64 5 }, ptr bitcast (ptr @"__$ti-84" to ptr), %..string { ptr @"csbs$byte_world$d3", i64 2 }, ptr @"scl$[656]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-176" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 -8269810219996629248, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 61), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 55), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 44), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 44), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 44), i32 1, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-177" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 -8011167291195661540, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$d6", i64 15 }, ptr bitcast (ptr @"__$ti-234" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[5505]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-185" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 8882076021127209538, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$d9", i64 15 }, ptr bitcast (ptr @"__$ti-425" to ptr), %..string { ptr @"csbs$byte_world$d7", i64 6 }, ptr @"scl$[2768]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-186" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 -9028868956535457498, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 0, i8 1 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-187" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 112, i64 8, i32 3, i32 0, i64 -8055220795849993594, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 62), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 56), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 45), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 45), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 45), i32 8, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-189" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> } { i64 72, i64 8, i32 0, i32 0, i64 -7526787321581704868, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> <{ %"runtime::Type_Info_Parameters" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 70), i64 3 }, { ptr, i64 } { ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 64), i64 3 } }, [40 x i8] zeroinitializer, i64 18 }> }, section ".odinti"
@"__$ti-190" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -6254128994311399285, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$e4", i64 21 }, ptr bitcast (ptr @"__$ti-27" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[9137]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-203" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 48, i64 8, i32 3, i32 0, i64 1372608273476069439, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 73), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 67), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 53), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 53), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 53), i32 6, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-206" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Multi_Pointer", [64 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -4187549304265154778, <{ %"runtime::Type_Info_Multi_Pointer", [64 x i8], i64 }> <{ %"runtime::Type_Info_Multi_Pointer" { ptr bitcast (ptr @"__$ti-223" to ptr) }, [64 x i8] zeroinitializer, i64 12 }> }, section ".odinti"
@"__$ti-207" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Bit_Set", [40 x i8], i64 }> } { i64 16, i64 16, i32 3, i32 0, i64 3827518644811168468, <{ %"runtime::Type_Info_Bit_Set", [40 x i8], i64 }> <{ %"runtime::Type_Info_Bit_Set" { ptr bitcast (ptr @"__$ti-78" to ptr), ptr null, i64 0, i64 127 }, [40 x i8] zeroinitializer, i64 23 }> }, section ".odinti"
@"__$ti-208" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 16, i64 16, i32 3, i32 0, i64 3038384678923028557, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 1, i8 0 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-213" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 3014293232690284256, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-424" to ptr), { ptr, i64 } { ptr @"$enum_names-213", i64 2 }, { ptr, i64 } { ptr @"$enum_values-213", i64 2 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-220" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 5704578475399288160, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 1, i8 2 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-221" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 -3036838855858074187, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$77", i64 5 }, ptr bitcast (ptr @"__$ti-122" to ptr), %..string { ptr @"csbs$byte_world$eb", i64 2 }, ptr @"scl$[471]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-222" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 2, i64 2, i32 3, i32 0, i64 3092775683940386555, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 1, i8 0 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-223" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_String", [70 x i8], i64 }> } { i64 16, i64 8, i32 1, i32 0, i64 8091808378024623192, <{ %"runtime::Type_Info_String", [70 x i8], i64 }> <{ %"runtime::Type_Info_String" zeroinitializer, [70 x i8] zeroinitializer, i64 7 }> }, section ".odinti"
@"__$ti-224" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 5531955249332666048, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$ed", i64 8 }, ptr bitcast (ptr @"__$ti-419" to ptr), %..string { ptr @"csbs$byte_world$c1", i64 4 }, ptr @"scl$[303]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-225" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Slice", [56 x i8], i64 }> } { i64 16, i64 8, i32 0, i32 0, i64 8189758979006548568, <{ %"runtime::Type_Info_Slice", [56 x i8], i64 }> <{ %"runtime::Type_Info_Slice" { ptr bitcast (ptr @"__$ti-424" to ptr), i64 1 }, [56 x i8] zeroinitializer, i64 17 }> }, section ".odinti"
@"__$ti-226" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> } { i64 2, i64 2, i32 1, i32 0, i64 6098685678959812405, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> <{ %"runtime::Type_Info_Float" { i8 1 }, [71 x i8] zeroinitializer, i64 4 }> }, section ".odinti"
@"__$ti-227" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -8622787093137705099, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$ee", i64 22 }, ptr bitcast (ptr @"__$ti-375" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[7186]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-228" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 72, i64 8, i32 3, i32 0, i64 -7578267308568530800, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 79), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 73), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 59), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 59), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 59), i32 11, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-229" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 2, i64 2, i32 3, i32 0, i64 -5489083288975598726, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 1, i8 2 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-230" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -4340557334141282772, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> <{ %"runtime::Type_Info_Pointer" { ptr bitcast (ptr @"__$ti-424" to ptr) }, [64 x i8] zeroinitializer, i64 11 }> }, section ".odinti"
@"__$ti-232" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 16, i64 8, i32 3, i32 0, i64 -4809644901941133586, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$f5", i64 16 }, ptr bitcast (ptr @"__$ti-127" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[9228]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-234" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Bit_Set", [40 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 5462593274662478896, <{ %"runtime::Type_Info_Bit_Set", [40 x i8], i64 }> <{ %"runtime::Type_Info_Bit_Set" { ptr bitcast (ptr @"__$ti-400" to ptr), ptr bitcast (ptr @"__$ti-158" to ptr), i64 0, i64 1 }, [40 x i8] zeroinitializer, i64 23 }> }, section ".odinti"
@"__$ti-242" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 8328321933338296725, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 90), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 84), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 70), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 70), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 70), i32 1, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-246" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 16, i64 16, i32 3, i32 0, i64 -7748246461440303887, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" zeroinitializer, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-249" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 311182081283165179, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$f7", i64 30 }, ptr bitcast (ptr @"__$ti-113" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[1688]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-252" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 24, i64 8, i32 3, i32 0, i64 -2176389202967631082, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$f8", i64 15 }, ptr bitcast (ptr @"__$ti-76" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[2636]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-256" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 0, i64 1, i32 3, i32 0, i64 -5287523713842883884, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" zeroinitializer, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-257" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> } { i64 16, i64 8, i32 0, i32 0, i64 -5116398791991610056, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> <{ %"runtime::Type_Info_Parameters" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 91), i64 2 }, { ptr, i64 } { ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 85), i64 2 } }, [40 x i8] zeroinitializer, i64 18 }> }, section ".odinti"
@"__$ti-260" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -2233271250242477013, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$fa", i64 25 }, ptr bitcast (ptr @"__$ti-102" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[17]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-264" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Union", [24 x i8], i64 }> } { i64 80, i64 8, i32 0, i32 0, i64 -8076902416644092719, <{ %"runtime::Type_Info_Union", [24 x i8], i64 }> <{ %"runtime::Type_Info_Union" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 93), i64 27 }, i64 72, ptr bitcast (ptr @"__$ti-60" to ptr), ptr null, i8 0, i8 0, i8 0, [5 x i8] zeroinitializer }, [24 x i8] zeroinitializer, i64 20 }> }, section ".odinti"
@"__$ti-265" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> } { i64 24, i64 8, i32 0, i32 0, i64 4064647455633717689, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> <{ %"runtime::Type_Info_Parameters" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 120), i64 2 }, { ptr, i64 } { ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 87), i64 2 } }, [40 x i8] zeroinitializer, i64 18 }> }, section ".odinti"
@"__$ti-266" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 40, i64 8, i32 0, i32 0, i64 -9183709048140332208, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$fb", i64 14 }, ptr bitcast (ptr @"__$ti-51" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[4282]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-268" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> } { i64 8, i64 8, i32 1, i32 0, i64 -8566459419728032662, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> <{ %"runtime::Type_Info_Float" { i8 2 }, [71 x i8] zeroinitializer, i64 4 }> }, section ".odinti"
@"__$ti-273" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 40, i64 8, i32 1, i32 0, i64 -7533162545490611512, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$fc", i64 20 }, ptr bitcast (ptr @"__$ti-44" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[6906]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-275" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Boolean", [72 x i8], i64 }> } { i64 2, i64 2, i32 3, i32 0, i64 -29994569518180418, <{ %"runtime::Type_Info_Boolean", [72 x i8], i64 }> <{ %"runtime::Type_Info_Boolean" zeroinitializer, [72 x i8] zeroinitializer, i64 8 }> }, section ".odinti"
@"__$ti-276" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Rune", [72 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 -4616803010531017251, <{ %"runtime::Type_Info_Rune", [72 x i8], i64 }> <{ %"runtime::Type_Info_Rune" zeroinitializer, [72 x i8] zeroinitializer, i64 3 }> }, section ".odinti"
@"__$ti-277" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 4270605247652560521, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-78" to ptr), { ptr, i64 } { ptr @"$enum_names-277", i64 3 }, { ptr, i64 } { ptr @"$enum_values-277", i64 3 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-280" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 5618157543797037372, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> <{ %"runtime::Type_Info_Pointer" { ptr bitcast (ptr @"__$ti-223" to ptr) }, [64 x i8] zeroinitializer, i64 11 }> }, section ".odinti"
@"__$ti-281" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 1671974356739140268, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> <{ %"runtime::Type_Info_Pointer" { ptr bitcast (ptr @"__$ti-273" to ptr) }, [64 x i8] zeroinitializer, i64 11 }> }, section ".odinti"
@"__$ti-282" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 8949045234305628450, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$100", i64 20 }, ptr bitcast (ptr @"__$ti-419" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[1184]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-283" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 -7635343206086087214, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-424" to ptr), { ptr, i64 } { ptr @"$enum_names-283", i64 4 }, { ptr, i64 } { ptr @"$enum_values-283", i64 4 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-284" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 -6836742183969237883, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$104", i64 15 }, ptr bitcast (ptr @"__$ti-14" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[7598]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-286" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 0, i64 1, i32 3, i32 0, i64 4818779845041926011, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$105", i64 17 }, ptr bitcast (ptr @"__$ti-256" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[2293]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-288" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 16, i64 8, i32 3, i32 0, i64 1619574599761705728, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 122), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 89), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 71), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 71), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 71), i32 2, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-290" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 2, i64 2, i32 3, i32 0, i64 5558799945458185151, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" zeroinitializer, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-293" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 150677948587936458, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-424" to ptr), { ptr, i64 } { ptr @"$enum_names-293", i64 2 }, { ptr, i64 } { ptr @"$enum_values-293", i64 2 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-294" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 24, i64 8, i32 3, i32 0, i64 4494207241471850241, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$108", i64 13 }, ptr bitcast (ptr @"__$ti-327" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[4384]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-297" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 2, i64 1, i32 3, i32 0, i64 2026878093866007509, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$109", i64 17 }, ptr bitcast (ptr @"__$ti-316" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[1887]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-298" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 24, i64 8, i32 3, i32 0, i64 3627989382107460510, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$10a", i64 19 }, ptr bitcast (ptr @"__$ti-322" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[2452]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-301" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 32, i64 8, i32 3, i32 0, i64 8390571117059637944, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 124), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 91), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 73), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 73), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 73), i32 4, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-314" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 6872105800277894661, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-422" to ptr), { ptr, i64 } { ptr @"$enum_names-314", i64 136 }, { ptr, i64 } { ptr @"$enum_values-314", i64 136 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-316" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 2, i64 1, i32 3, i32 0, i64 7437556291411436906, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 128), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 95), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 77), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 77), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 77), i32 2, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-318" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 8521887457303563268, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$195", i64 22 }, ptr bitcast (ptr @"__$ti-116" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[3213]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-319" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 32, i64 8, i32 0, i32 0, i64 -4545763294955837399, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$196", i64 20 }, ptr bitcast (ptr @"__$ti-1" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[3072]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-322" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 24, i64 8, i32 3, i32 0, i64 1811419144668706434, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 130), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 97), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 79), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 79), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 79), i32 4, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-323" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Bit_Set", [40 x i8], i64 }> } { i64 2, i64 2, i32 3, i32 0, i64 -7047052737882839865, <{ %"runtime::Type_Info_Bit_Set", [40 x i8], i64 }> <{ %"runtime::Type_Info_Bit_Set" { ptr bitcast (ptr @"__$ti-62" to ptr), ptr null, i64 0, i64 8 }, [40 x i8] zeroinitializer, i64 23 }> }, section ".odinti"
@"__$ti-324" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 32, i64 8, i32 3, i32 0, i64 3315794030725732905, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 134), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 101), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 83), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 83), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 83), i32 4, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-326" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Slice", [56 x i8], i64 }> } { i64 16, i64 8, i32 0, i32 0, i64 8295680200074195106, <{ %"runtime::Type_Info_Slice", [56 x i8], i64 }> <{ %"runtime::Type_Info_Slice" { ptr bitcast (ptr @"__$ti-282" to ptr), i64 8 }, [56 x i8] zeroinitializer, i64 17 }> }, section ".odinti"
@"__$ti-327" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 24, i64 8, i32 3, i32 0, i64 -1215795017695673706, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 138), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 105), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 87), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 87), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 87), i32 3, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-328" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 48, i64 8, i32 0, i32 0, i64 -3193246346823873441, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 141), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 108), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 90), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 90), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 90), i32 7, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-330" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> } { i64 2, i64 2, i32 1, i32 0, i64 6100387722959904583, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> <{ %"runtime::Type_Info_Float" { i8 2 }, [71 x i8] zeroinitializer, i64 4 }> }, section ".odinti"
@"__$ti-333" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> } { i64 32, i64 8, i32 0, i32 0, i64 -6545206014204799319, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> <{ %"runtime::Type_Info_Parameters" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 148), i64 3 }, { ptr, i64 } { ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 115), i64 3 } }, [40 x i8] zeroinitializer, i64 18 }> }, section ".odinti"
@"__$ti-334" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 16, i64 16, i32 3, i32 0, i64 6443696321647179906, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 1, i8 1 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-335" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 16, i64 16, i32 3, i32 0, i64 -694757098749756604, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 0, i8 2 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-338" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 -658075659724328455, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1a8", i64 18 }, ptr bitcast (ptr @"__$ti-124" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[935]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-340" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 112, i64 8, i32 0, i32 0, i64 3774786951615569000, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1a9", i64 9 }, ptr bitcast (ptr @"__$ti-66" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[5563]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-344" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Multi_Pointer", [64 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 2306640535244086935, <{ %"runtime::Type_Info_Multi_Pointer", [64 x i8], i64 }> <{ %"runtime::Type_Info_Multi_Pointer" { ptr bitcast (ptr @"__$ti-370" to ptr) }, [64 x i8] zeroinitializer, i64 12 }> }, section ".odinti"
@"__$ti-348" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Multi_Pointer", [64 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 4795647917087221650, <{ %"runtime::Type_Info_Multi_Pointer", [64 x i8], i64 }> <{ %"runtime::Type_Info_Multi_Pointer" { ptr bitcast (ptr @"__$ti-79" to ptr) }, [64 x i8] zeroinitializer, i64 12 }> }, section ".odinti"
@"__$ti-349" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -6765785109079645766, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1aa", i64 17 }, ptr bitcast (ptr @"__$ti-50" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[2327]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-350" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 120, i64 8, i32 3, i32 0, i64 -3619814599248625929, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1ab", i64 17 }, ptr bitcast (ptr @"__$ti-358" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[61].1" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-354" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 4306411637679863235, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1ae", i64 5 }, ptr bitcast (ptr @"__$ti-314" to ptr), %..string { ptr @"csbs$byte_world$1ac", i64 5 }, ptr @"scl$[143]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-358" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Union", [24 x i8], i64 }> } { i64 120, i64 8, i32 3, i32 0, i64 -5978505103295007995, <{ %"runtime::Type_Info_Union", [24 x i8], i64 }> <{ %"runtime::Type_Info_Union" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 151), i64 1 }, i64 112, ptr bitcast (ptr @"__$ti-60" to ptr), ptr null, i8 0, i8 0, i8 0, [5 x i8] zeroinitializer }, [24 x i8] zeroinitializer, i64 20 }> }, section ".odinti"
@"__$ti-360" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 16, i64 8, i32 3, i32 0, i64 -9196629140785891209, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 152), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 118), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 97), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 97), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 97), i32 2, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-365" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 0, i64 1, i32 3, i32 0, i64 -5323552264683624825, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1af", i64 17 }, ptr bitcast (ptr @"__$ti-256" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[2065]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-368" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> } { i64 8, i64 8, i32 1, i32 0, i64 -8568451734797972544, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> <{ %"runtime::Type_Info_Float" { i8 1 }, [71 x i8] zeroinitializer, i64 4 }> }, section ".odinti"
@"__$ti-370" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -5248816158460668987, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" zeroinitializer, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-373" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 2249000193164672400, <{ %"runtime::Type_Info_Pointer", [64 x i8], i64 }> <{ %"runtime::Type_Info_Pointer" { ptr bitcast (ptr @"__$ti-79" to ptr) }, [64 x i8] zeroinitializer, i64 11 }> }, section ".odinti"
@"__$ti-374" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 4821730457388859810, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-424" to ptr), { ptr, i64 } { ptr @"$enum_names-374", i64 8 }, { ptr, i64 } { ptr @"$enum_values-374", i64 8 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-375" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 482123741790734250, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> <{ %"runtime::Type_Info_Procedure" { ptr bitcast (ptr @"__$ti-189" to ptr), ptr null, i8 0, i8 1, [6 x i8] zeroinitializer }, [48 x i8] zeroinitializer, i64 13 }> }, section ".odinti"
@"__$ti-376" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> } { i64 112, i64 8, i32 0, i32 0, i64 4263095683671146773, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> <{ %"runtime::Type_Info_Parameters" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 154), i64 1 }, { ptr, i64 } { ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 120), i64 1 } }, [40 x i8] zeroinitializer, i64 18 }> }, section ".odinti"
@"__$ti-377" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 6790047043783209078, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1b7", i64 10 }, ptr bitcast (ptr @"__$ti-130" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[1375]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-378" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> } { i64 8, i64 8, i32 1, i32 0, i64 -2489281023779626581, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> <{ %"runtime::Type_Info_Float" zeroinitializer, [71 x i8] zeroinitializer, i64 4 }> }, section ".odinti"
@"__$ti-379" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 32, i64 8, i32 3, i32 0, i64 -881617309323839347, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1b8", i64 13 }, ptr bitcast (ptr @"__$ti-411" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[4703]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-385" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> } { i64 88, i64 8, i32 0, i32 0, i64 -275718145825266877, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> <{ %"runtime::Type_Info_Parameters" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 155), i64 7 }, { ptr, i64 } { ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 121), i64 7 } }, [40 x i8] zeroinitializer, i64 18 }> }, section ".odinti"
@"__$ti-386" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Union", [24 x i8], i64 }> } { i64 16, i64 8, i32 3, i32 0, i64 -5877205008852246207, <{ %"runtime::Type_Info_Union", [24 x i8], i64 }> <{ %"runtime::Type_Info_Union" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 162), i64 1 }, i64 8, ptr bitcast (ptr @"__$ti-60" to ptr), ptr null, i8 0, i8 0, i8 0, [5 x i8] zeroinitializer }, [24 x i8] zeroinitializer, i64 20 }> }, section ".odinti"
@"__$ti-387" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Complex", [72 x i8], i64 }> } { i64 16, i64 8, i32 1, i32 0, i64 1605344753774012712, <{ %"runtime::Type_Info_Complex", [72 x i8], i64 }> <{ %"runtime::Type_Info_Complex" zeroinitializer, [72 x i8] zeroinitializer, i64 5 }> }, section ".odinti"
@"__$ti-393" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Complex", [72 x i8], i64 }> } { i64 4, i64 2, i32 1, i32 0, i64 7315392543695597978, <{ %"runtime::Type_Info_Complex", [72 x i8], i64 }> <{ %"runtime::Type_Info_Complex" zeroinitializer, [72 x i8] zeroinitializer, i64 5 }> }, section ".odinti"
@"__$ti-395" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 24, i64 8, i32 3, i32 0, i64 3428251375673520666, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1bd", i64 21 }, ptr bitcast (ptr @"__$ti-76" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[4614]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-396" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 56, i64 8, i32 3, i32 0, i64 -2029998269471661687, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1be", i64 26 }, ptr bitcast (ptr @"__$ti-164" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[2724]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-397" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 -625184764881012880, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1bf", i64 13 }, ptr bitcast (ptr @"__$ti-30" to ptr), %..string { ptr @"csbs$byte_world$d3", i64 2 }, ptr @"scl$[199]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-400" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 -7387078360393618937, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1c0", i64 14 }, ptr bitcast (ptr @"__$ti-293" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[5433]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-401" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_String", [70 x i8], i64 }> } { i64 8, i64 8, i32 1, i32 0, i64 2964516416227214120, <{ %"runtime::Type_Info_String", [70 x i8], i64 }> <{ %"runtime::Type_Info_String" { i8 1, i8 1 }, [70 x i8] zeroinitializer, i64 7 }> }, section ".odinti"
@"__$ti-402" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Boolean", [72 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 623198825683455431, <{ %"runtime::Type_Info_Boolean", [72 x i8], i64 }> <{ %"runtime::Type_Info_Boolean" zeroinitializer, [72 x i8] zeroinitializer, i64 8 }> }, section ".odinti"
@"__$ti-406" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> } { i64 4, i64 4, i32 1, i32 0, i64 -2494061700338141884, <{ %"runtime::Type_Info_Float", [71 x i8], i64 }> <{ %"runtime::Type_Info_Float" zeroinitializer, [71 x i8] zeroinitializer, i64 4 }> }, section ".odinti"
@"__$ti-407" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 2151690230237305730, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-422" to ptr), { ptr, i64 } { ptr @"$enum_names-407", i64 6 }, { ptr, i64 } { ptr @"$enum_values-407", i64 6 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-410" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 48, i64 8, i32 3, i32 0, i64 2855027981734026748, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1c7", i64 16 }, ptr bitcast (ptr @"__$ti-203" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[4711]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-411" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> } { i64 32, i64 8, i32 3, i32 0, i64 -5980246535520774772, <{ %"runtime::Type_Info_Struct", [0 x i8], i64 }> <{ %"runtime::Type_Info_Struct" { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 163), ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 128), ptr getelementptr ([168 x i64], ptr @"__$type_info_offsets_data", i64 0, i64 99), ptr getelementptr ([168 x i8], ptr @"__$type_info_usings_data", i64 0, i64 99), ptr getelementptr ([168 x %..string], ptr @"__$type_info_tags_data", i64 0, i64 99), i32 4, i8 0, i8 0, [2 x i8] zeroinitializer, i32 0, [4 x i8] zeroinitializer, ptr null, ptr null }, [0 x i8] zeroinitializer, i64 19 }> }, section ".odinti"
@"__$ti-412" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 16, i64 8, i32 3, i32 0, i64 -2381813495174307871, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1cc", i64 15 }, ptr bitcast (ptr @"__$ti-288" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[3002]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-413" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -336842274567833535, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 1, i8 1 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-417" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> } { i64 1, i64 1, i32 0, i32 0, i64 123260419838018488, <{ %"runtime::Type_Info_Parameters", [40 x i8], i64 }> <{ %"runtime::Type_Info_Parameters" { { ptr, i64 } { ptr getelementptr ([168 x ptr], ptr @"__$type_info_types_data", i64 0, i64 167), i64 1 }, { ptr, i64 } { ptr getelementptr ([168 x %..string], ptr @"__$type_info_names_data", i64 0, i64 132), i64 1 } }, [40 x i8] zeroinitializer, i64 18 }> }, section ".odinti"
@"__$ti-418" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 -2606718467991234145, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1cd", i64 21 }, ptr bitcast (ptr @"__$ti-421" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[3283]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-419" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 3089943341986682694, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 1, i8 0 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-420" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -3318546475047442985, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1ce", i64 32 }, ptr bitcast (ptr @"__$ti-3" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[67]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-421" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 2824810971285579043, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-424" to ptr), { ptr, i64 } { ptr @"$enum_names-421", i64 3 }, { ptr, i64 } { ptr @"$enum_values-421", i64 3 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-422" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 4, i64 4, i32 3, i32 0, i64 3094732814638223685, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" { i8 1, i8 0 }, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-423" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 517555340829290320, <{ %"runtime::Type_Info_Procedure", [48 x i8], i64 }> <{ %"runtime::Type_Info_Procedure" { ptr bitcast (ptr @"__$ti-29" to ptr), ptr bitcast (ptr @"__$ti-126" to ptr), i8 0, i8 2, [6 x i8] zeroinitializer }, [48 x i8] zeroinitializer, i64 13 }> }, section ".odinti"
@"__$ti-424" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> } { i64 1, i64 1, i32 3, i32 0, i64 631772817358541784, <{ %"runtime::Type_Info_Integer", [70 x i8], i64 }> <{ %"runtime::Type_Info_Integer" zeroinitializer, [70 x i8] zeroinitializer, i64 2 }> }, section ".odinti"
@"__$ti-425" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 3006480846599123308, <{ %"runtime::Type_Info_Enum", [32 x i8], i64 }> <{ %"runtime::Type_Info_Enum" { ptr bitcast (ptr @"__$ti-78" to ptr), { ptr, i64 } { ptr @"$enum_names-425", i64 3 }, { ptr, i64 } { ptr @"$enum_values-425", i64 3 } }, [32 x i8] zeroinitializer, i64 21 }> }, section ".odinti"
@"__$ti-426" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 6405070070830490356, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1d4", i64 23 }, ptr bitcast (ptr @"__$ti-50" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[2395]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"__$ti-427" = private constant { i64, i64, i32, i32, i64, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> } { i64 8, i64 8, i32 3, i32 0, i64 -3784209970177508972, <{ %"runtime::Type_Info_Named", [24 x i8], i64 }> <{ %"runtime::Type_Info_Named" { %..string { ptr @"csbs$byte_world$1d5", i64 11 }, ptr bitcast (ptr @"__$ti-99" to ptr), %..string { ptr @"csbs$byte_world$44", i64 7 }, ptr @"scl$[8614]" }, [24 x i8] zeroinitializer, i64 1 }> }, section ".odinti"
@"csbs$byte_world$42" = private constant [6 x i8] c"types\00", align 1
@"csbs$byte_world$43" = private constant [6 x i8] c"names\00", align 1
@"csbs$byte_world$44" = private constant [8 x i8] c"runtime\00", align 1
@"csbs$byte_world$45" = private constant [37 x i8] c"/usr/lib/odin/base/runtime/core.odin\00", align 1
@"scl$[8879]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 364, i32 1, %..string zeroinitializer }
@"csbs$byte_world$46" = private constant [22 x i8] c"Random_Generator_Mode\00", align 1
@"csbs$byte_world$47" = private constant [4 x i8] c"lhs\00", align 1
@"csbs$byte_world$48" = private constant [4 x i8] c"rhs\00", align 1
@"$enum_names-14" = private constant [5 x %..string] [%..string { ptr @"csbs$byte_world$49", i64 4 }, %..string { ptr @"csbs$byte_world$4a", i64 13 }, %..string { ptr @"csbs$byte_world$4b", i64 15 }, %..string { ptr @"csbs$byte_world$4c", i64 16 }, %..string { ptr @"csbs$byte_world$4d", i64 20 }], section ".odinti"
@"$enum_values-14" = private constant [5 x i64] [i64 0, i64 1, i64 2, i64 3, i64 4], section ".odinti"
@"csbs$byte_world$49" = private constant [5 x i8] c"None\00", align 1
@"csbs$byte_world$4a" = private constant [14 x i8] c"Out_Of_Memory\00", align 1
@"csbs$byte_world$4b" = private constant [16 x i8] c"Invalid_Pointer\00", align 1
@"csbs$byte_world$4c" = private constant [17 x i8] c"Invalid_Argument\00", align 1
@"csbs$byte_world$4d" = private constant [21 x i8] c"Mode_Not_Implemented\00", align 1
@"scl$[1778]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 70, i32 1, %..string zeroinitializer }
@"csbs$byte_world$4e" = private constant [16 x i8] c"Type_Info_Named\00", align 1
@"csbs$byte_world$4f" = private constant [5 x i8] c"data\00", align 1
@"csbs$byte_world$50" = private constant [6 x i8] c"level\00", align 1
@"csbs$byte_world$51" = private constant [5 x i8] c"text\00", align 1
@"csbs$byte_world$52" = private constant [8 x i8] c"options\00", align 1
@"csbs$byte_world$53" = private constant [9 x i8] c"location\00", align 1
@"csbs$byte_world$54" = private constant [4 x i8] c"key\00", align 1
@"csbs$byte_world$55" = private constant [5 x i8] c"seed\00", align 1
@"$enum_names-30" = private constant [17 x %..string] [%..string { ptr @"csbs$byte_world$49", i64 4 }, %..string { ptr @"csbs$byte_world$56", i64 17 }, %..string { ptr @"csbs$byte_world$57", i64 5 }, %..string { ptr @"csbs$byte_world$58", i64 9 }, %..string { ptr @"csbs$byte_world$59", i64 6 }, %..string { ptr @"csbs$byte_world$5a", i64 7 }, %..string { ptr @"csbs$byte_world$5b", i64 11 }, %..string { ptr @"csbs$byte_world$5c", i64 7 }, %..string { ptr @"csbs$byte_world$5d", i64 12 }, %..string { ptr @"csbs$byte_world$5e", i64 11 }, %..string { ptr @"csbs$byte_world$5f", i64 12 }, %..string { ptr @"csbs$byte_world$60", i64 16 }, %..string { ptr @"csbs$byte_world$61", i64 21 }, %..string { ptr @"csbs$byte_world$62", i64 11 }, %..string { ptr @"csbs$byte_world$63", i64 12 }, %..string { ptr @"csbs$byte_world$64", i64 7 }, %..string { ptr @"csbs$byte_world$65", i64 17 }], section ".odinti"
@"$enum_values-30" = private constant [17 x i64] [i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 15, i64 16], section ".odinti"
@"csbs$byte_world$56" = private constant [18 x i8] c"Permission_Denied\00", align 1
@"csbs$byte_world$57" = private constant [6 x i8] c"Exist\00", align 1
@"csbs$byte_world$58" = private constant [10 x i8] c"Not_Exist\00", align 1
@"csbs$byte_world$59" = private constant [7 x i8] c"Closed\00", align 1
@"csbs$byte_world$5a" = private constant [8 x i8] c"Timeout\00", align 1
@"csbs$byte_world$5b" = private constant [12 x i8] c"Broken_Pipe\00", align 1
@"csbs$byte_world$5c" = private constant [8 x i8] c"No_Size\00", align 1
@"csbs$byte_world$5d" = private constant [13 x i8] c"Invalid_File\00", align 1
@"csbs$byte_world$5e" = private constant [12 x i8] c"Invalid_Dir\00", align 1
@"csbs$byte_world$5f" = private constant [13 x i8] c"Invalid_Path\00", align 1
@"csbs$byte_world$60" = private constant [17 x i8] c"Invalid_Callback\00", align 1
@"csbs$byte_world$61" = private constant [22 x i8] c"Pattern_Has_Separator\00", align 1
@"csbs$byte_world$62" = private constant [12 x i8] c"Unsupported\00", align 1
@"csbs$byte_world$63" = private constant [13 x i8] c"File_Is_Pipe\00", align 1
@"csbs$byte_world$64" = private constant [8 x i8] c"Not_Dir\00", align 1
@"csbs$byte_world$65" = private constant [18 x i8] c"Env_Var_Not_Found\00", align 1
@"scl$[7301]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 287, i32 1, %..string zeroinitializer }
@"csbs$byte_world$66" = private constant [15 x i8] c"Allocator_Mode\00", align 1
@"csbs$byte_world$67" = private constant [10 x i8] c"file_path\00", align 1
@"csbs$byte_world$68" = private constant [5 x i8] c"line\00", align 1
@"csbs$byte_world$69" = private constant [7 x i8] c"column\00", align 1
@"csbs$byte_world$6a" = private constant [10 x i8] c"procedure\00", align 1
@"scl$[2000]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 78, i32 1, %..string zeroinitializer }
@"csbs$byte_world$6b" = private constant [16 x i8] c"Type_Info_Float\00", align 1
@"csbs$byte_world$6c" = private constant [5 x i8] c"elem\00", align 1
@"csbs$byte_world$6d" = private constant [5 x i8] c"base\00", align 1
@"csbs$byte_world$6e" = private constant [7 x i8] c"values\00", align 1
@"scl$[8066]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 318, i32 1, %..string zeroinitializer }
@"csbs$byte_world$6f" = private constant [10 x i8] c"Allocator\00", align 1
@"scl$[3385]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 127, i32 1, %..string zeroinitializer }
@"csbs$byte_world$70" = private constant [17 x i8] c"Type_Info_Struct\00", align 1
@"scl$[2259]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 83, i32 1, %..string zeroinitializer }
@"csbs$byte_world$71" = private constant [14 x i8] c"Type_Info_Any\00", align 1
@"scl$[8441]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 341, i32 1, %..string zeroinitializer }
@"csbs$byte_world$72" = private constant [14 x i8] c"Logger_Option\00", align 1
@"scl$[2933]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 111, i32 1, %..string zeroinitializer }
@"csbs$byte_world$73" = private constant [24 x i8] c"Type_Info_Dynamic_Array\00", align 1
@"$enum_names-65" = private constant [5 x %..string] [%..string { ptr @"csbs$byte_world$74", i64 5 }, %..string { ptr @"csbs$byte_world$75", i64 4 }, %..string { ptr @"csbs$byte_world$76", i64 7 }, %..string { ptr @"csbs$byte_world$77", i64 5 }, %..string { ptr @"csbs$byte_world$78", i64 5 }], section ".odinti"
@"$enum_values-65" = private constant [5 x i64] [i64 0, i64 10, i64 20, i64 30, i64 40], section ".odinti"
@"csbs$byte_world$74" = private constant [6 x i8] c"Debug\00", align 1
@"csbs$byte_world$75" = private constant [5 x i8] c"Info\00", align 1
@"csbs$byte_world$76" = private constant [8 x i8] c"Warning\00", align 1
@"csbs$byte_world$77" = private constant [6 x i8] c"Error\00", align 1
@"csbs$byte_world$78" = private constant [6 x i8] c"Fatal\00", align 1
@"csbs$byte_world$79" = private constant [5 x i8] c"size\00", align 1
@"csbs$byte_world$7a" = private constant [6 x i8] c"align\00", align 1
@"csbs$byte_world$7b" = private constant [6 x i8] c"flags\00", align 1
@"csbs$byte_world$7c" = private constant [3 x i8] c"id\00", align 1
@"csbs$byte_world$7d" = private constant [8 x i8] c"variant\00", align 1
@"$enum_names-67" = private constant [9 x %..string] [%..string { ptr @"csbs$byte_world$7e", i64 5 }, %..string { ptr @"csbs$byte_world$7f", i64 4 }, %..string { ptr @"csbs$byte_world$80", i64 4 }, %..string { ptr @"csbs$byte_world$81", i64 15 }, %..string { ptr @"csbs$byte_world$82", i64 14 }, %..string { ptr @"csbs$byte_world$83", i64 4 }, %..string { ptr @"csbs$byte_world$84", i64 9 }, %..string { ptr @"csbs$byte_world$85", i64 14 }, %..string { ptr @"csbs$byte_world$86", i64 9 }], section ".odinti"
@"$enum_values-67" = private constant [9 x i64] [i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8], section ".odinti"
@"csbs$byte_world$7e" = private constant [6 x i8] c"Level\00", align 1
@"csbs$byte_world$7f" = private constant [5 x i8] c"Date\00", align 1
@"csbs$byte_world$80" = private constant [5 x i8] c"Time\00", align 1
@"csbs$byte_world$81" = private constant [16 x i8] c"Short_File_Path\00", align 1
@"csbs$byte_world$82" = private constant [15 x i8] c"Long_File_Path\00", align 1
@"csbs$byte_world$83" = private constant [5 x i8] c"Line\00", align 1
@"csbs$byte_world$84" = private constant [10 x i8] c"Procedure\00", align 1
@"csbs$byte_world$85" = private constant [15 x i8] c"Terminal_Color\00", align 1
@"csbs$byte_world$86" = private constant [10 x i8] c"Thread_Id\00", align 1
@"scl$[2133]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 81, i32 1, %..string zeroinitializer }
@"csbs$byte_world$87" = private constant [17 x i8] c"Type_Info_String\00", align 1
@"scl$[7767]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 314, i32 1, %..string zeroinitializer }
@"csbs$byte_world$88" = private constant [15 x i8] c"Allocator_Proc\00", align 1
@"csbs$byte_world$89" = private constant [13 x i8] c"backing_type\00", align 1
@"csbs$byte_world$8a" = private constant [20 x i8] c"fmt:\22v,field_count\22\00", align 1
@"csbs$byte_world$8b" = private constant [10 x i8] c"bit_sizes\00", align 1
@"csbs$byte_world$8c" = private constant [12 x i8] c"bit_offsets\00", align 1
@"csbs$byte_world$8d" = private constant [5 x i8] c"tags\00", align 1
@"csbs$byte_world$8e" = private constant [12 x i8] c"field_count\00", align 1
@"csbs$byte_world$8f" = private constant [10 x i8] c"elem_size\00", align 1
@"csbs$byte_world$90" = private constant [6 x i8] c"count\00", align 1
@"csbs$byte_world$91" = private constant [53 x i8] c"/usr/lib/odin/base/runtime/dynamic_map_internal.odin\00", align 1
@"scl$[12485]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$91", i64 52 }, i32 298, i32 1, %..string zeroinitializer }
@"csbs$byte_world$92" = private constant [9 x i8] c"Map_Info\00", align 1
@"scl$[4480]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 167, i32 1, %..string zeroinitializer }
@"csbs$byte_world$93" = private constant [18 x i8] c"Type_Info_Bit_Set\00", align 1
@"scl$[8336]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 333, i32 1, %..string zeroinitializer }
@"csbs$byte_world$94" = private constant [13 x i8] c"Logger_Level\00", align 1
@"csbs$byte_world$95" = private constant [5 x i8] c"name\00", align 1
@"csbs$byte_world$96" = private constant [4 x i8] c"pkg\00", align 1
@"csbs$byte_world$97" = private constant [4 x i8] c"loc\00", align 1
@"scl$[5091]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 193, i32 1, %..string zeroinitializer }
@"csbs$byte_world$98" = private constant [20 x i8] c"Type_Info_Bit_Field\00", align 1
@"scl$[4001]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 146, i32 1, %..string zeroinitializer }
@"csbs$byte_world$99" = private constant [16 x i8] c"Type_Info_Union\00", align 1
@"scl$[1966]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 77, i32 1, %..string zeroinitializer }
@"csbs$byte_world$9a" = private constant [15 x i8] c"Type_Info_Rune\00", align 1
@"$enum_names-113" = private constant [2 x %..string] [%..string { ptr @"csbs$byte_world$9b", i64 5 }, %..string { ptr @"csbs$byte_world$9c", i64 6 }], section ".odinti"
@"$enum_values-113" = private constant [2 x i64] [i64 0, i64 1], section ".odinti"
@"csbs$byte_world$9b" = private constant [6 x i8] c"UTF_8\00", align 1
@"csbs$byte_world$9c" = private constant [7 x i8] c"UTF_16\00", align 1
@"csbs$byte_world$9d" = private constant [45 x i8] c"/usr/lib/odin/base/runtime/core_builtin.odin\00", align 1
@"scl$[61]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$9d", i64 44 }, i32 6, i32 10, %..string zeroinitializer }
@"csbs$byte_world$9e" = private constant [14 x i8] c"Maybe($T=int)\00", align 1
@"csbs$byte_world$9f" = private constant [3 x i8] c"ks\00", align 1
@"csbs$byte_world$a0" = private constant [3 x i8] c"vs\00", align 1
@"csbs$byte_world$a1" = private constant [11 x i8] c"key_hasher\00", align 1
@"csbs$byte_world$a2" = private constant [10 x i8] c"key_equal\00", align 1
@"$enum_names-122" = private constant [16 x %..string] [%..string { ptr @"csbs$byte_world$49", i64 4 }, %..string { ptr @"csbs$byte_world$a3", i64 3 }, %..string { ptr @"csbs$byte_world$a4", i64 14 }, %..string { ptr @"csbs$byte_world$a5", i64 11 }, %..string { ptr @"csbs$byte_world$a6", i64 13 }, %..string { ptr @"csbs$byte_world$a7", i64 12 }, %..string { ptr @"csbs$byte_world$a8", i64 11 }, %..string { ptr @"csbs$byte_world$a9", i64 14 }, %..string { ptr @"csbs$byte_world$aa", i64 14 }, %..string { ptr @"csbs$byte_world$ab", i64 14 }, %..string { ptr @"csbs$byte_world$ac", i64 13 }, %..string { ptr @"csbs$byte_world$ad", i64 14 }, %..string { ptr @"csbs$byte_world$ae", i64 14 }, %..string { ptr @"csbs$byte_world$af", i64 11 }, %..string { ptr @"csbs$byte_world$b0", i64 7 }, %..string { ptr @"csbs$byte_world$b1", i64 5 }], section ".odinti"
@"$enum_values-122" = private constant [16 x i64] [i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 -1], section ".odinti"
@"csbs$byte_world$a3" = private constant [4 x i8] c"EOF\00", align 1
@"csbs$byte_world$a4" = private constant [15 x i8] c"Unexpected_EOF\00", align 1
@"csbs$byte_world$a5" = private constant [12 x i8] c"Short_Write\00", align 1
@"csbs$byte_world$a6" = private constant [14 x i8] c"Invalid_Write\00", align 1
@"csbs$byte_world$a7" = private constant [13 x i8] c"Short_Buffer\00", align 1
@"csbs$byte_world$a8" = private constant [12 x i8] c"No_Progress\00", align 1
@"csbs$byte_world$a9" = private constant [15 x i8] c"Invalid_Whence\00", align 1
@"csbs$byte_world$aa" = private constant [15 x i8] c"Invalid_Offset\00", align 1
@"csbs$byte_world$ab" = private constant [15 x i8] c"Invalid_Unread\00", align 1
@"csbs$byte_world$ac" = private constant [14 x i8] c"Negative_Read\00", align 1
@"csbs$byte_world$ad" = private constant [15 x i8] c"Negative_Write\00", align 1
@"csbs$byte_world$ae" = private constant [15 x i8] c"Negative_Count\00", align 1
@"csbs$byte_world$af" = private constant [12 x i8] c"Buffer_Full\00", align 1
@"csbs$byte_world$b0" = private constant [8 x i8] c"Unknown\00", align 1
@"csbs$byte_world$b1" = private constant [6 x i8] c"Empty\00", align 1
@"scl$[2225]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 82, i32 1, %..string zeroinitializer }
@"csbs$byte_world$b2" = private constant [18 x i8] c"Type_Info_Boolean\00", align 1
@"$enum_names-124" = private constant [10 x %..string] [%..string { ptr @"csbs$byte_world$b3", i64 7 }, %..string { ptr @"csbs$byte_world$b4", i64 4 }, %..string { ptr @"csbs$byte_world$b5", i64 11 }, %..string { ptr @"csbs$byte_world$b6", i64 5 }, %..string { ptr @"csbs$byte_world$b7", i64 8 }, %..string { ptr @"csbs$byte_world$b8", i64 9 }, %..string { ptr @"csbs$byte_world$49", i64 4 }, %..string { ptr @"csbs$byte_world$b9", i64 5 }, %..string { ptr @"csbs$byte_world$ba", i64 5 }, %..string { ptr @"csbs$byte_world$bb", i64 4 }], section ".odinti"
@"$enum_values-124" = private constant [10 x i64] [i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 9, i64 10], section ".odinti"
@"csbs$byte_world$b3" = private constant [8 x i8] c"Invalid\00", align 1
@"csbs$byte_world$b4" = private constant [5 x i8] c"Odin\00", align 1
@"csbs$byte_world$b5" = private constant [12 x i8] c"Contextless\00", align 1
@"csbs$byte_world$b6" = private constant [6 x i8] c"CDecl\00", align 1
@"csbs$byte_world$b7" = private constant [9 x i8] c"Std_Call\00", align 1
@"csbs$byte_world$b8" = private constant [10 x i8] c"Fast_Call\00", align 1
@"csbs$byte_world$b9" = private constant [6 x i8] c"Naked\00", align 1
@"csbs$byte_world$ba" = private constant [6 x i8] c"Win64\00", align 1
@"csbs$byte_world$bb" = private constant [5 x i8] c"SysV\00", align 1
@"csbs$byte_world$bc" = private constant [11 x i8] c"is_cstring\00", align 1
@"csbs$byte_world$bd" = private constant [9 x i8] c"encoding\00", align 1
@"scl$[8745]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 356, i32 1, %..string zeroinitializer }
@"csbs$byte_world$be" = private constant [7 x i8] c"Logger\00", align 1
@"scl$[2099]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 80, i32 1, %..string zeroinitializer }
@"csbs$byte_world$bf" = private constant [21 x i8] c"Type_Info_Quaternion\00", align 1
@"scl$[5036]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 190, i32 1, %..string zeroinitializer }
@"csbs$byte_world$c0" = private constant [22 x i8] c"Type_Info_Soa_Pointer\00", align 1
@"csbs$byte_world$c1" = private constant [5 x i8] c"time\00", align 1
@"csbs$byte_world$c2" = private constant [34 x i8] c"/usr/lib/odin/core/time/time.odin\00", align 1
@"scl$[1343]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$c2", i64 33 }, i32 67, i32 1, %..string zeroinitializer }
@"csbs$byte_world$c3" = private constant [7 x i8] c"raylib\00", align 1
@"csbs$byte_world$c4" = private constant [40 x i8] c"/usr/lib/odin/vendor/raylib/raylib.odin\00", align 1
@"scl$[37936]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$c4", i64 39 }, i32 793, i32 1, %..string zeroinitializer }
@"csbs$byte_world$c5" = private constant [14 x i8] c"TextureFilter\00", align 1
@"scl$[9315]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 385, i32 1, %..string zeroinitializer }
@"csbs$byte_world$c6" = private constant [8 x i8] c"Context\00", align 1
@"scl$[1590]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 57, i32 1, %..string zeroinitializer }
@"csbs$byte_world$c7" = private constant [26 x i8] c"Type_Info_Struct_Soa_Kind\00", align 1
@"csbs$byte_world$c8" = private constant [6 x i8] c"index\00", align 1
@"csbs$byte_world$c9" = private constant [10 x i8] c"min_value\00", align 1
@"csbs$byte_world$ca" = private constant [10 x i8] c"max_value\00", align 1
@"csbs$byte_world$cb" = private constant [10 x i8] c"is_sparse\00", align 1
@"$enum_names-166" = private constant [3 x %..string] [%..string { ptr @"csbs$byte_world$cc", i64 8 }, %..string { ptr @"csbs$byte_world$cd", i64 6 }, %..string { ptr @"csbs$byte_world$ce", i64 3 }], section ".odinti"
@"$enum_values-166" = private constant [3 x i64] [i64 0, i64 1, i64 2], section ".odinti"
@"csbs$byte_world$cc" = private constant [9 x i8] c"Platform\00", align 1
@"csbs$byte_world$cd" = private constant [7 x i8] c"Little\00", align 1
@"csbs$byte_world$ce" = private constant [4 x i8] c"Big\00", align 1
@"csbs$byte_world$cf" = private constant [50 x i8] c"/usr/lib/odin/base/runtime/thread_management.odin\00", align 1
@"scl$[132]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$cf", i64 49 }, i32 6, i32 1, %..string zeroinitializer }
@"csbs$byte_world$d0" = private constant [21 x i8] c"Thread_Local_Cleaner\00", align 1
@"csbs$byte_world$d1" = private constant [2 x i8] c"T\00", align 1
@"scl$[1222]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 46, i32 1, %..string zeroinitializer }
@"csbs$byte_world$d2" = private constant [20 x i8] c"Platform_Endianness\00", align 1
@"csbs$byte_world$d3" = private constant [3 x i8] c"os\00", align 1
@"csbs$byte_world$d4" = private constant [34 x i8] c"/usr/lib/odin/core/os/errors.odin\00", align 1
@"scl$[656]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$d4", i64 33 }, i32 46, i32 1, %..string zeroinitializer }
@"csbs$byte_world$d5" = private constant [11 x i8] c"endianness\00", align 1
@"scl$[5505]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 207, i32 1, %..string zeroinitializer }
@"csbs$byte_world$d6" = private constant [16 x i8] c"Type_Info_Flags\00", align 1
@"csbs$byte_world$d7" = private constant [7 x i8] c"thread\00", align 1
@"csbs$byte_world$d8" = private constant [38 x i8] c"/usr/lib/odin/core/thread/thread.odin\00", align 1
@"scl$[2768]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$d8", i64 37 }, i32 90, i32 1, %..string zeroinitializer }
@"csbs$byte_world$d9" = private constant [16 x i8] c"Thread_Priority\00", align 1
@"csbs$byte_world$da" = private constant [10 x i8] c"allocator\00", align 1
@"csbs$byte_world$db" = private constant [15 x i8] c"temp_allocator\00", align 1
@"csbs$byte_world$dc" = private constant [23 x i8] c"assertion_failure_proc\00", align 1
@"csbs$byte_world$dd" = private constant [7 x i8] c"logger\00", align 1
@"csbs$byte_world$de" = private constant [17 x i8] c"random_generator\00", align 1
@"csbs$byte_world$df" = private constant [9 x i8] c"user_ptr\00", align 1
@"csbs$byte_world$e0" = private constant [11 x i8] c"user_index\00", align 1
@"csbs$byte_world$e1" = private constant [10 x i8] c"_internal\00", align 1
@"csbs$byte_world$e2" = private constant [7 x i8] c"prefix\00", align 1
@"csbs$byte_world$e3" = private constant [8 x i8] c"message\00", align 1
@"scl$[9137]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 378, i32 1, %..string zeroinitializer }
@"csbs$byte_world$e4" = private constant [22 x i8] c"Random_Generator_Proc\00", align 1
@"csbs$byte_world$e5" = private constant [12 x i8] c"elem_stride\00", align 1
@"csbs$byte_world$e6" = private constant [10 x i8] c"row_count\00", align 1
@"csbs$byte_world$e7" = private constant [13 x i8] c"column_count\00", align 1
@"csbs$byte_world$e8" = private constant [7 x i8] c"layout\00", align 1
@"$enum_names-213" = private constant [2 x %..string] [%..string { ptr @"csbs$byte_world$e9", i64 12 }, %..string { ptr @"csbs$byte_world$ea", i64 9 }], section ".odinti"
@"$enum_values-213" = private constant [2 x i64] [i64 0, i64 1], section ".odinti"
@"csbs$byte_world$e9" = private constant [13 x i8] c"Column_Major\00", align 1
@"csbs$byte_world$ea" = private constant [10 x i8] c"Row_Major\00", align 1
@"csbs$byte_world$eb" = private constant [3 x i8] c"io\00", align 1
@"csbs$byte_world$ec" = private constant [30 x i8] c"/usr/lib/odin/core/io/io.odin\00", align 1
@"scl$[471]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$ec", i64 29 }, i32 17, i32 1, %..string zeroinitializer }
@"scl$[303]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$c2", i64 33 }, i32 11, i32 1, %..string zeroinitializer }
@"csbs$byte_world$ed" = private constant [9 x i8] c"Duration\00", align 1
@"scl$[7186]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 284, i32 1, %..string zeroinitializer }
@"csbs$byte_world$ee" = private constant [23 x i8] c"Assertion_Failure_Proc\00", align 1
@"csbs$byte_world$ef" = private constant [8 x i8] c"offsets\00", align 1
@"csbs$byte_world$f0" = private constant [7 x i8] c"usings\00", align 1
@"csbs$byte_world$f1" = private constant [9 x i8] c"soa_kind\00", align 1
@"csbs$byte_world$f2" = private constant [8 x i8] c"soa_len\00", align 1
@"csbs$byte_world$f3" = private constant [14 x i8] c"soa_base_type\00", align 1
@"csbs$byte_world$f4" = private constant [6 x i8] c"equal\00", align 1
@"scl$[9228]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 380, i32 1, %..string zeroinitializer }
@"csbs$byte_world$f5" = private constant [17 x i8] c"Random_Generator\00", align 1
@"csbs$byte_world$f6" = private constant [6 x i8] c"_nsec\00", align 1
@"scl$[1688]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 64, i32 1, %..string zeroinitializer }
@"csbs$byte_world$f7" = private constant [31 x i8] c"Type_Info_String_Encoding_Kind\00", align 1
@"scl$[2636]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 97, i32 1, %..string zeroinitializer }
@"csbs$byte_world$f8" = private constant [16 x i8] c"Type_Info_Array\00", align 1
@"csbs$byte_world$f9" = private constant [2 x i8] c"_\00", align 1
@"scl$[17]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$cf", i64 49 }, i32 3, i32 1, %..string zeroinitializer }
@"csbs$byte_world$fa" = private constant [26 x i8] c"Thread_Local_Cleaner_Odin\00", align 1
@"scl$[4282]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 157, i32 1, %..string zeroinitializer }
@"csbs$byte_world$fb" = private constant [15 x i8] c"Type_Info_Enum\00", align 1
@"scl$[6906]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 270, i32 1, %..string zeroinitializer }
@"csbs$byte_world$fc" = private constant [21 x i8] c"Source_Code_Location\00", align 1
@"$enum_names-277" = private constant [3 x %..string] [%..string { ptr @"csbs$byte_world$fd", i64 4 }, %..string { ptr @"csbs$byte_world$fe", i64 5 }, %..string { ptr @"csbs$byte_world$ff", i64 10 }], section ".odinti"
@"$enum_values-277" = private constant [3 x i64] [i64 0, i64 1, i64 2], section ".odinti"
@"csbs$byte_world$fd" = private constant [5 x i8] c"Read\00", align 1
@"csbs$byte_world$fe" = private constant [6 x i8] c"Reset\00", align 1
@"csbs$byte_world$ff" = private constant [11 x i8] c"Query_Info\00", align 1
@"scl$[1184]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 44, i32 1, %..string zeroinitializer }
@"csbs$byte_world$100" = private constant [21 x i8] c"Type_Info_Enum_Value\00", align 1
@"$enum_names-283" = private constant [4 x %..string] [%..string { ptr @"csbs$byte_world$49", i64 4 }, %..string { ptr @"csbs$byte_world$101", i64 5 }, %..string { ptr @"csbs$byte_world$102", i64 5 }, %..string { ptr @"csbs$byte_world$103", i64 7 }], section ".odinti"
@"$enum_values-283" = private constant [4 x i64] [i64 0, i64 1, i64 2, i64 3], section ".odinti"
@"csbs$byte_world$101" = private constant [6 x i8] c"Fixed\00", align 1
@"csbs$byte_world$102" = private constant [6 x i8] c"Slice\00", align 1
@"csbs$byte_world$103" = private constant [8 x i8] c"Dynamic\00", align 1
@"scl$[7598]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 306, i32 1, %..string zeroinitializer }
@"csbs$byte_world$104" = private constant [16 x i8] c"Allocator_Error\00", align 1
@"scl$[2293]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 84, i32 1, %..string zeroinitializer }
@"csbs$byte_world$105" = private constant [18 x i8] c"Type_Info_Type_Id\00", align 1
@"$enum_names-293" = private constant [2 x %..string] [%..string { ptr @"csbs$byte_world$106", i64 10 }, %..string { ptr @"csbs$byte_world$107", i64 14 }], section ".odinti"
@"$enum_values-293" = private constant [2 x i64] [i64 0, i64 1], section ".odinti"
@"csbs$byte_world$106" = private constant [11 x i8] c"Comparable\00", align 1
@"csbs$byte_world$107" = private constant [15 x i8] c"Simple_Compare\00", align 1
@"scl$[4384]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 162, i32 1, %..string zeroinitializer }
@"csbs$byte_world$108" = private constant [14 x i8] c"Type_Info_Map\00", align 1
@"scl$[1887]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 76, i32 1, %..string zeroinitializer }
@"csbs$byte_world$109" = private constant [18 x i8] c"Type_Info_Integer\00", align 1
@"scl$[2452]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 91, i32 1, %..string zeroinitializer }
@"csbs$byte_world$10a" = private constant [20 x i8] c"Type_Info_Procedure\00", align 1
@"csbs$byte_world$10b" = private constant [13 x i8] c"lowest_level\00", align 1
@"$enum_names-314" = private constant [136 x %..string] [%..string { ptr @"csbs$byte_world$10c", i64 4 }, %..string { ptr @"csbs$byte_world$10d", i64 5 }, %..string { ptr @"csbs$byte_world$10e", i64 6 }, %..string { ptr @"csbs$byte_world$10f", i64 5 }, %..string { ptr @"csbs$byte_world$110", i64 5 }, %..string { ptr @"csbs$byte_world$111", i64 3 }, %..string { ptr @"csbs$byte_world$112", i64 5 }, %..string { ptr @"csbs$byte_world$113", i64 5 }, %..string { ptr @"csbs$byte_world$114", i64 7 }, %..string { ptr @"csbs$byte_world$115", i64 5 }, %..string { ptr @"csbs$byte_world$116", i64 6 }, %..string { ptr @"csbs$byte_world$117", i64 6 }, %..string { ptr @"csbs$byte_world$118", i64 6 }, %..string { ptr @"csbs$byte_world$119", i64 6 }, %..string { ptr @"csbs$byte_world$11a", i64 6 }, %..string { ptr @"csbs$byte_world$11b", i64 7 }, %..string { ptr @"csbs$byte_world$11c", i64 5 }, %..string { ptr @"csbs$byte_world$11d", i64 6 }, %..string { ptr @"csbs$byte_world$11e", i64 5 }, %..string { ptr @"csbs$byte_world$11f", i64 6 }, %..string { ptr @"csbs$byte_world$120", i64 7 }, %..string { ptr @"csbs$byte_world$121", i64 6 }, %..string { ptr @"csbs$byte_world$122", i64 6 }, %..string { ptr @"csbs$byte_world$123", i64 6 }, %..string { ptr @"csbs$byte_world$124", i64 6 }, %..string { ptr @"csbs$byte_world$125", i64 6 }, %..string { ptr @"csbs$byte_world$126", i64 7 }, %..string { ptr @"csbs$byte_world$127", i64 5 }, %..string { ptr @"csbs$byte_world$128", i64 6 }, %..string { ptr @"csbs$byte_world$129", i64 6 }, %..string { ptr @"csbs$byte_world$12a", i64 5 }, %..string { ptr @"csbs$byte_world$12b", i64 6 }, %..string { ptr @"csbs$byte_world$12c", i64 5 }, %..string { ptr @"csbs$byte_world$12d", i64 4 }, %..string { ptr @"csbs$byte_world$12e", i64 6 }, %..string { ptr @"csbs$byte_world$12f", i64 7 }, %..string { ptr @"csbs$byte_world$130", i64 12 }, %..string { ptr @"csbs$byte_world$131", i64 6 }, %..string { ptr @"csbs$byte_world$132", i64 6 }, %..string { ptr @"csbs$byte_world$133", i64 9 }, %..string { ptr @"csbs$byte_world$134", i64 5 }, %..string { ptr @"csbs$byte_world$135", i64 11 }, %..string { ptr @"csbs$byte_world$136", i64 6 }, %..string { ptr @"csbs$byte_world$137", i64 5 }, %..string { ptr @"csbs$byte_world$138", i64 6 }, %..string { ptr @"csbs$byte_world$139", i64 8 }, %..string { ptr @"csbs$byte_world$13a", i64 6 }, %..string { ptr @"csbs$byte_world$13b", i64 6 }, %..string { ptr @"csbs$byte_world$13c", i64 6 }, %..string { ptr @"csbs$byte_world$13d", i64 7 }, %..string { ptr @"csbs$byte_world$13e", i64 6 }, %..string { ptr @"csbs$byte_world$13f", i64 6 }, %..string { ptr @"csbs$byte_world$140", i64 5 }, %..string { ptr @"csbs$byte_world$141", i64 5 }, %..string { ptr @"csbs$byte_world$142", i64 6 }, %..string { ptr @"csbs$byte_world$143", i64 6 }, %..string { ptr @"csbs$byte_world$144", i64 7 }, %..string { ptr @"csbs$byte_world$145", i64 7 }, %..string { ptr @"csbs$byte_world$146", i64 11 }, %..string { ptr @"csbs$byte_world$147", i64 6 }, %..string { ptr @"csbs$byte_world$148", i64 6 }, %..string { ptr @"csbs$byte_world$149", i64 7 }, %..string { ptr @"csbs$byte_world$14a", i64 5 }, %..string { ptr @"csbs$byte_world$14b", i64 5 }, %..string { ptr @"csbs$byte_world$14c", i64 6 }, %..string { ptr @"csbs$byte_world$14d", i64 6 }, %..string { ptr @"csbs$byte_world$14e", i64 7 }, %..string { ptr @"csbs$byte_world$14f", i64 7 }, %..string { ptr @"csbs$byte_world$150", i64 4 }, %..string { ptr @"csbs$byte_world$151", i64 6 }, %..string { ptr @"csbs$byte_world$152", i64 5 }, %..string { ptr @"csbs$byte_world$153", i64 6 }, %..string { ptr @"csbs$byte_world$154", i64 9 }, %..string { ptr @"csbs$byte_world$155", i64 7 }, %..string { ptr @"csbs$byte_world$156", i64 7 }, %..string { ptr @"csbs$byte_world$157", i64 9 }, %..string { ptr @"csbs$byte_world$158", i64 8 }, %..string { ptr @"csbs$byte_world$159", i64 6 }, %..string { ptr @"csbs$byte_world$15a", i64 7 }, %..string { ptr @"csbs$byte_world$15b", i64 7 }, %..string { ptr @"csbs$byte_world$15c", i64 7 }, %..string { ptr @"csbs$byte_world$15d", i64 7 }, %..string { ptr @"csbs$byte_world$15e", i64 7 }, %..string { ptr @"csbs$byte_world$15f", i64 8 }, %..string { ptr @"csbs$byte_world$160", i64 6 }, %..string { ptr @"csbs$byte_world$161", i64 8 }, %..string { ptr @"csbs$byte_world$162", i64 8 }, %..string { ptr @"csbs$byte_world$163", i64 6 }, %..string { ptr @"csbs$byte_world$164", i64 8 }, %..string { ptr @"csbs$byte_world$165", i64 12 }, %..string { ptr @"csbs$byte_world$166", i64 8 }, %..string { ptr @"csbs$byte_world$167", i64 10 }, %..string { ptr @"csbs$byte_world$168", i64 11 }, %..string { ptr @"csbs$byte_world$169", i64 15 }, %..string { ptr @"csbs$byte_world$16a", i64 15 }, %..string { ptr @"csbs$byte_world$16b", i64 10 }, %..string { ptr @"csbs$byte_world$16c", i64 12 }, %..string { ptr @"csbs$byte_world$16d", i64 12 }, %..string { ptr @"csbs$byte_world$16e", i64 10 }, %..string { ptr @"csbs$byte_world$16f", i64 13 }, %..string { ptr @"csbs$byte_world$170", i64 8 }, %..string { ptr @"csbs$byte_world$171", i64 11 }, %..string { ptr @"csbs$byte_world$172", i64 9 }, %..string { ptr @"csbs$byte_world$173", i64 12 }, %..string { ptr @"csbs$byte_world$174", i64 10 }, %..string { ptr @"csbs$byte_world$175", i64 7 }, %..string { ptr @"csbs$byte_world$176", i64 7 }, %..string { ptr @"csbs$byte_world$177", i64 8 }, %..string { ptr @"csbs$byte_world$178", i64 9 }, %..string { ptr @"csbs$byte_world$179", i64 12 }, %..string { ptr @"csbs$byte_world$17a", i64 9 }, %..string { ptr @"csbs$byte_world$17b", i64 12 }, %..string { ptr @"csbs$byte_world$17c", i64 9 }, %..string { ptr @"csbs$byte_world$17d", i64 12 }, %..string { ptr @"csbs$byte_world$17e", i64 8 }, %..string { ptr @"csbs$byte_world$17f", i64 11 }, %..string { ptr @"csbs$byte_world$180", i64 6 }, %..string { ptr @"csbs$byte_world$181", i64 7 }, %..string { ptr @"csbs$byte_world$182", i64 7 }, %..string { ptr @"csbs$byte_world$183", i64 7 }, %..string { ptr @"csbs$byte_world$184", i64 6 }, %..string { ptr @"csbs$byte_world$185", i64 9 }, %..string { ptr @"csbs$byte_world$186", i64 6 }, %..string { ptr @"csbs$byte_world$187", i64 9 }, %..string { ptr @"csbs$byte_world$188", i64 11 }, %..string { ptr @"csbs$byte_world$189", i64 9 }, %..string { ptr @"csbs$byte_world$18a", i64 6 }, %..string { ptr @"csbs$byte_world$18b", i64 11 }, %..string { ptr @"csbs$byte_world$18c", i64 11 }, %..string { ptr @"csbs$byte_world$18d", i64 12 }, %..string { ptr @"csbs$byte_world$18e", i64 10 }, %..string { ptr @"csbs$byte_world$18f", i64 15 }, %..string { ptr @"csbs$byte_world$190", i64 7 }, %..string { ptr @"csbs$byte_world$191", i64 9 }, %..string { ptr @"csbs$byte_world$192", i64 11 }, %..string { ptr @"csbs$byte_world$193", i64 9 }], section ".odinti"
@"$enum_values-314" = private constant [136 x i64] [i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8, i64 9, i64 10, i64 11, i64 12, i64 13, i64 14, i64 15, i64 16, i64 17, i64 18, i64 19, i64 20, i64 21, i64 22, i64 23, i64 24, i64 25, i64 26, i64 27, i64 28, i64 29, i64 30, i64 31, i64 32, i64 33, i64 34, i64 35, i64 36, i64 37, i64 38, i64 39, i64 40, i64 41, i64 42, i64 43, i64 44, i64 45, i64 46, i64 47, i64 48, i64 49, i64 50, i64 51, i64 52, i64 53, i64 54, i64 55, i64 56, i64 57, i64 58, i64 59, i64 60, i64 61, i64 62, i64 63, i64 64, i64 65, i64 66, i64 67, i64 68, i64 69, i64 70, i64 71, i64 72, i64 73, i64 74, i64 75, i64 76, i64 77, i64 78, i64 79, i64 80, i64 81, i64 82, i64 83, i64 84, i64 85, i64 86, i64 87, i64 88, i64 89, i64 90, i64 91, i64 92, i64 93, i64 94, i64 95, i64 96, i64 97, i64 98, i64 99, i64 100, i64 101, i64 102, i64 103, i64 104, i64 105, i64 106, i64 107, i64 108, i64 109, i64 110, i64 111, i64 112, i64 113, i64 114, i64 115, i64 116, i64 117, i64 118, i64 119, i64 120, i64 121, i64 122, i64 123, i64 124, i64 125, i64 126, i64 127, i64 128, i64 129, i64 130, i64 131, i64 132, i64 133, i64 11, i64 35], section ".odinti"
@"csbs$byte_world$10c" = private constant [5 x i8] c"NONE\00", align 1
@"csbs$byte_world$10d" = private constant [6 x i8] c"EPERM\00", align 1
@"csbs$byte_world$10e" = private constant [7 x i8] c"ENOENT\00", align 1
@"csbs$byte_world$10f" = private constant [6 x i8] c"ESRCH\00", align 1
@"csbs$byte_world$110" = private constant [6 x i8] c"EINTR\00", align 1
@"csbs$byte_world$111" = private constant [4 x i8] c"EIO\00", align 1
@"csbs$byte_world$112" = private constant [6 x i8] c"ENXIO\00", align 1
@"csbs$byte_world$113" = private constant [6 x i8] c"E2BIG\00", align 1
@"csbs$byte_world$114" = private constant [8 x i8] c"ENOEXEC\00", align 1
@"csbs$byte_world$115" = private constant [6 x i8] c"EBADF\00", align 1
@"csbs$byte_world$116" = private constant [7 x i8] c"ECHILD\00", align 1
@"csbs$byte_world$117" = private constant [7 x i8] c"EAGAIN\00", align 1
@"csbs$byte_world$118" = private constant [7 x i8] c"ENOMEM\00", align 1
@"csbs$byte_world$119" = private constant [7 x i8] c"EACCES\00", align 1
@"csbs$byte_world$11a" = private constant [7 x i8] c"EFAULT\00", align 1
@"csbs$byte_world$11b" = private constant [8 x i8] c"ENOTBLK\00", align 1
@"csbs$byte_world$11c" = private constant [6 x i8] c"EBUSY\00", align 1
@"csbs$byte_world$11d" = private constant [7 x i8] c"EEXIST\00", align 1
@"csbs$byte_world$11e" = private constant [6 x i8] c"EXDEV\00", align 1
@"csbs$byte_world$11f" = private constant [7 x i8] c"ENODEV\00", align 1
@"csbs$byte_world$120" = private constant [8 x i8] c"ENOTDIR\00", align 1
@"csbs$byte_world$121" = private constant [7 x i8] c"EISDIR\00", align 1
@"csbs$byte_world$122" = private constant [7 x i8] c"EINVAL\00", align 1
@"csbs$byte_world$123" = private constant [7 x i8] c"ENFILE\00", align 1
@"csbs$byte_world$124" = private constant [7 x i8] c"EMFILE\00", align 1
@"csbs$byte_world$125" = private constant [7 x i8] c"ENOTTY\00", align 1
@"csbs$byte_world$126" = private constant [8 x i8] c"ETXTBSY\00", align 1
@"csbs$byte_world$127" = private constant [6 x i8] c"EFBIG\00", align 1
@"csbs$byte_world$128" = private constant [7 x i8] c"ENOSPC\00", align 1
@"csbs$byte_world$129" = private constant [7 x i8] c"ESPIPE\00", align 1
@"csbs$byte_world$12a" = private constant [6 x i8] c"EROFS\00", align 1
@"csbs$byte_world$12b" = private constant [7 x i8] c"EMLINK\00", align 1
@"csbs$byte_world$12c" = private constant [6 x i8] c"EPIPE\00", align 1
@"csbs$byte_world$12d" = private constant [5 x i8] c"EDOM\00", align 1
@"csbs$byte_world$12e" = private constant [7 x i8] c"ERANGE\00", align 1
@"csbs$byte_world$12f" = private constant [8 x i8] c"EDEADLK\00", align 1
@"csbs$byte_world$130" = private constant [13 x i8] c"ENAMETOOLONG\00", align 1
@"csbs$byte_world$131" = private constant [7 x i8] c"ENOLCK\00", align 1
@"csbs$byte_world$132" = private constant [7 x i8] c"ENOSYS\00", align 1
@"csbs$byte_world$133" = private constant [10 x i8] c"ENOTEMPTY\00", align 1
@"csbs$byte_world$134" = private constant [6 x i8] c"ELOOP\00", align 1
@"csbs$byte_world$135" = private constant [12 x i8] c"EUNKNOWN_41\00", align 1
@"csbs$byte_world$136" = private constant [7 x i8] c"ENOMSG\00", align 1
@"csbs$byte_world$137" = private constant [6 x i8] c"EIDRM\00", align 1
@"csbs$byte_world$138" = private constant [7 x i8] c"ECHRNG\00", align 1
@"csbs$byte_world$139" = private constant [9 x i8] c"EL2NSYNC\00", align 1
@"csbs$byte_world$13a" = private constant [7 x i8] c"EL3HLT\00", align 1
@"csbs$byte_world$13b" = private constant [7 x i8] c"EL3RST\00", align 1
@"csbs$byte_world$13c" = private constant [7 x i8] c"ELNRNG\00", align 1
@"csbs$byte_world$13d" = private constant [8 x i8] c"EUNATCH\00", align 1
@"csbs$byte_world$13e" = private constant [7 x i8] c"ENOCSI\00", align 1
@"csbs$byte_world$13f" = private constant [7 x i8] c"EL2HLT\00", align 1
@"csbs$byte_world$140" = private constant [6 x i8] c"EBADE\00", align 1
@"csbs$byte_world$141" = private constant [6 x i8] c"EBADR\00", align 1
@"csbs$byte_world$142" = private constant [7 x i8] c"EXFULL\00", align 1
@"csbs$byte_world$143" = private constant [7 x i8] c"ENOANO\00", align 1
@"csbs$byte_world$144" = private constant [8 x i8] c"EBADRQC\00", align 1
@"csbs$byte_world$145" = private constant [8 x i8] c"EBADSLT\00", align 1
@"csbs$byte_world$146" = private constant [12 x i8] c"EUNKNOWN_58\00", align 1
@"csbs$byte_world$147" = private constant [7 x i8] c"EBFONT\00", align 1
@"csbs$byte_world$148" = private constant [7 x i8] c"ENOSTR\00", align 1
@"csbs$byte_world$149" = private constant [8 x i8] c"ENODATA\00", align 1
@"csbs$byte_world$14a" = private constant [6 x i8] c"ETIME\00", align 1
@"csbs$byte_world$14b" = private constant [6 x i8] c"ENOSR\00", align 1
@"csbs$byte_world$14c" = private constant [7 x i8] c"ENONET\00", align 1
@"csbs$byte_world$14d" = private constant [7 x i8] c"ENOPKG\00", align 1
@"csbs$byte_world$14e" = private constant [8 x i8] c"EREMOTE\00", align 1
@"csbs$byte_world$14f" = private constant [8 x i8] c"ENOLINK\00", align 1
@"csbs$byte_world$150" = private constant [5 x i8] c"EADV\00", align 1
@"csbs$byte_world$151" = private constant [7 x i8] c"ESRMNT\00", align 1
@"csbs$byte_world$152" = private constant [6 x i8] c"ECOMM\00", align 1
@"csbs$byte_world$153" = private constant [7 x i8] c"EPROTO\00", align 1
@"csbs$byte_world$154" = private constant [10 x i8] c"EMULTIHOP\00", align 1
@"csbs$byte_world$155" = private constant [8 x i8] c"EDOTDOT\00", align 1
@"csbs$byte_world$156" = private constant [8 x i8] c"EBADMSG\00", align 1
@"csbs$byte_world$157" = private constant [10 x i8] c"EOVERFLOW\00", align 1
@"csbs$byte_world$158" = private constant [9 x i8] c"ENOTUNIQ\00", align 1
@"csbs$byte_world$159" = private constant [7 x i8] c"EBADFD\00", align 1
@"csbs$byte_world$15a" = private constant [8 x i8] c"EREMCHG\00", align 1
@"csbs$byte_world$15b" = private constant [8 x i8] c"ELIBACC\00", align 1
@"csbs$byte_world$15c" = private constant [8 x i8] c"ELIBBAD\00", align 1
@"csbs$byte_world$15d" = private constant [8 x i8] c"ELIBSCN\00", align 1
@"csbs$byte_world$15e" = private constant [8 x i8] c"ELIBMAX\00", align 1
@"csbs$byte_world$15f" = private constant [9 x i8] c"ELIBEXEC\00", align 1
@"csbs$byte_world$160" = private constant [7 x i8] c"EILSEQ\00", align 1
@"csbs$byte_world$161" = private constant [9 x i8] c"ERESTART\00", align 1
@"csbs$byte_world$162" = private constant [9 x i8] c"ESTRPIPE\00", align 1
@"csbs$byte_world$163" = private constant [7 x i8] c"EUSERS\00", align 1
@"csbs$byte_world$164" = private constant [9 x i8] c"ENOTSOCK\00", align 1
@"csbs$byte_world$165" = private constant [13 x i8] c"EDESTADDRREQ\00", align 1
@"csbs$byte_world$166" = private constant [9 x i8] c"EMSGSIZE\00", align 1
@"csbs$byte_world$167" = private constant [11 x i8] c"EPROTOTYPE\00", align 1
@"csbs$byte_world$168" = private constant [12 x i8] c"ENOPROTOOPT\00", align 1
@"csbs$byte_world$169" = private constant [16 x i8] c"EPROTONOSUPPORT\00", align 1
@"csbs$byte_world$16a" = private constant [16 x i8] c"ESOCKTNOSUPPORT\00", align 1
@"csbs$byte_world$16b" = private constant [11 x i8] c"EOPNOTSUPP\00", align 1
@"csbs$byte_world$16c" = private constant [13 x i8] c"EPFNOSUPPORT\00", align 1
@"csbs$byte_world$16d" = private constant [13 x i8] c"EAFNOSUPPORT\00", align 1
@"csbs$byte_world$16e" = private constant [11 x i8] c"EADDRINUSE\00", align 1
@"csbs$byte_world$16f" = private constant [14 x i8] c"EADDRNOTAVAIL\00", align 1
@"csbs$byte_world$170" = private constant [9 x i8] c"ENETDOWN\00", align 1
@"csbs$byte_world$171" = private constant [12 x i8] c"ENETUNREACH\00", align 1
@"csbs$byte_world$172" = private constant [10 x i8] c"ENETRESET\00", align 1
@"csbs$byte_world$173" = private constant [13 x i8] c"ECONNABORTED\00", align 1
@"csbs$byte_world$174" = private constant [11 x i8] c"ECONNRESET\00", align 1
@"csbs$byte_world$175" = private constant [8 x i8] c"ENOBUFS\00", align 1
@"csbs$byte_world$176" = private constant [8 x i8] c"EISCONN\00", align 1
@"csbs$byte_world$177" = private constant [9 x i8] c"ENOTCONN\00", align 1
@"csbs$byte_world$178" = private constant [10 x i8] c"ESHUTDOWN\00", align 1
@"csbs$byte_world$179" = private constant [13 x i8] c"ETOOMANYREFS\00", align 1
@"csbs$byte_world$17a" = private constant [10 x i8] c"ETIMEDOUT\00", align 1
@"csbs$byte_world$17b" = private constant [13 x i8] c"ECONNREFUSED\00", align 1
@"csbs$byte_world$17c" = private constant [10 x i8] c"EHOSTDOWN\00", align 1
@"csbs$byte_world$17d" = private constant [13 x i8] c"EHOSTUNREACH\00", align 1
@"csbs$byte_world$17e" = private constant [9 x i8] c"EALREADY\00", align 1
@"csbs$byte_world$17f" = private constant [12 x i8] c"EINPROGRESS\00", align 1
@"csbs$byte_world$180" = private constant [7 x i8] c"ESTALE\00", align 1
@"csbs$byte_world$181" = private constant [8 x i8] c"EUCLEAN\00", align 1
@"csbs$byte_world$182" = private constant [8 x i8] c"ENOTNAM\00", align 1
@"csbs$byte_world$183" = private constant [8 x i8] c"ENAVAIL\00", align 1
@"csbs$byte_world$184" = private constant [7 x i8] c"EISNAM\00", align 1
@"csbs$byte_world$185" = private constant [10 x i8] c"EREMOTEIO\00", align 1
@"csbs$byte_world$186" = private constant [7 x i8] c"EDQUOT\00", align 1
@"csbs$byte_world$187" = private constant [10 x i8] c"ENOMEDIUM\00", align 1
@"csbs$byte_world$188" = private constant [12 x i8] c"EMEDIUMTYPE\00", align 1
@"csbs$byte_world$189" = private constant [10 x i8] c"ECANCELED\00", align 1
@"csbs$byte_world$18a" = private constant [7 x i8] c"ENOKEY\00", align 1
@"csbs$byte_world$18b" = private constant [12 x i8] c"EKEYEXPIRED\00", align 1
@"csbs$byte_world$18c" = private constant [12 x i8] c"EKEYREVOKED\00", align 1
@"csbs$byte_world$18d" = private constant [13 x i8] c"EKEYREJECTED\00", align 1
@"csbs$byte_world$18e" = private constant [11 x i8] c"EOWNERDEAD\00", align 1
@"csbs$byte_world$18f" = private constant [16 x i8] c"ENOTRECOVERABLE\00", align 1
@"csbs$byte_world$190" = private constant [8 x i8] c"ERFKILL\00", align 1
@"csbs$byte_world$191" = private constant [10 x i8] c"EHWPOISON\00", align 1
@"csbs$byte_world$192" = private constant [12 x i8] c"EWOULDBLOCK\00", align 1
@"csbs$byte_world$193" = private constant [10 x i8] c"EDEADLOCK\00", align 1
@"csbs$byte_world$194" = private constant [7 x i8] c"signed\00", align 1
@"scl$[3213]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 119, i32 1, %..string zeroinitializer }
@"csbs$byte_world$195" = private constant [23 x i8] c"Type_Info_Struct_Flags\00", align 1
@"scl$[3072]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 114, i32 1, %..string zeroinitializer }
@"csbs$byte_world$196" = private constant [21 x i8] c"Type_Info_Parameters\00", align 1
@"csbs$byte_world$197" = private constant [7 x i8] c"params\00", align 1
@"csbs$byte_world$198" = private constant [8 x i8] c"results\00", align 1
@"csbs$byte_world$199" = private constant [9 x i8] c"variadic\00", align 1
@"csbs$byte_world$19a" = private constant [11 x i8] c"convention\00", align 1
@"csbs$byte_world$19b" = private constant [11 x i8] c"underlying\00", align 1
@"csbs$byte_world$19c" = private constant [6 x i8] c"lower\00", align 1
@"csbs$byte_world$19d" = private constant [6 x i8] c"upper\00", align 1
@"csbs$byte_world$19e" = private constant [6 x i8] c"value\00", align 1
@"csbs$byte_world$19f" = private constant [9 x i8] c"map_info\00", align 1
@"csbs$byte_world$1a0" = private constant [9 x i8] c"variants\00", align 1
@"csbs$byte_world$1a1" = private constant [11 x i8] c"tag_offset\00", align 1
@"csbs$byte_world$1a2" = private constant [9 x i8] c"tag_type\00", align 1
@"csbs$byte_world$1a3" = private constant [13 x i8] c"custom_align\00", align 1
@"csbs$byte_world$1a4" = private constant [7 x i8] c"no_nil\00", align 1
@"csbs$byte_world$1a5" = private constant [11 x i8] c"shared_nil\00", align 1
@"csbs$byte_world$1a6" = private constant [5 x i8] c"mode\00", align 1
@"csbs$byte_world$1a7" = private constant [2 x i8] c"p\00", align 1
@"scl$[935]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 27, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1a8" = private constant [19 x i8] c"Calling_Convention\00", align 1
@"scl$[5563]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 209, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1a9" = private constant [10 x i8] c"Type_Info\00", align 1
@"scl$[2327]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 85, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1aa" = private constant [18 x i8] c"Type_Info_Pointer\00", align 1
@"scl$[61].1" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$9d", i64 44 }, i32 6, i32 10, %..string zeroinitializer }
@"csbs$byte_world$1ab" = private constant [18 x i8] c"Maybe($T=Context)\00", align 1
@"csbs$byte_world$1ac" = private constant [6 x i8] c"linux\00", align 1
@"csbs$byte_world$1ad" = private constant [39 x i8] c"/usr/lib/odin/core/sys/linux/bits.odin\00", align 1
@"scl$[143]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1ad", i64 38 }, i32 12, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1ae" = private constant [6 x i8] c"Errno\00", align 1
@"scl$[2065]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 79, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1af" = private constant [18 x i8] c"Type_Info_Complex\00", align 1
@"$enum_names-374" = private constant [8 x %..string] [%..string { ptr @"csbs$byte_world$1b0", i64 5 }, %..string { ptr @"csbs$byte_world$1b1", i64 4 }, %..string { ptr @"csbs$byte_world$1b2", i64 8 }, %..string { ptr @"csbs$byte_world$1b3", i64 6 }, %..string { ptr @"csbs$byte_world$1b4", i64 14 }, %..string { ptr @"csbs$byte_world$ff", i64 10 }, %..string { ptr @"csbs$byte_world$1b5", i64 16 }, %..string { ptr @"csbs$byte_world$1b6", i64 17 }], section ".odinti"
@"$enum_values-374" = private constant [8 x i64] [i64 0, i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7], section ".odinti"
@"csbs$byte_world$1b0" = private constant [6 x i8] c"Alloc\00", align 1
@"csbs$byte_world$1b1" = private constant [5 x i8] c"Free\00", align 1
@"csbs$byte_world$1b2" = private constant [9 x i8] c"Free_All\00", align 1
@"csbs$byte_world$1b3" = private constant [7 x i8] c"Resize\00", align 1
@"csbs$byte_world$1b4" = private constant [15 x i8] c"Query_Features\00", align 1
@"csbs$byte_world$1b5" = private constant [17 x i8] c"Alloc_Non_Zeroed\00", align 1
@"csbs$byte_world$1b6" = private constant [18 x i8] c"Resize_Non_Zeroed\00", align 1
@"scl$[1375]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 53, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1b7" = private constant [11 x i8] c"Equal_Proc\00", align 1
@"scl$[4703]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$91", i64 52 }, i32 97, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1b8" = private constant [14 x i8] c"Map_Cell_Info\00", align 1
@"csbs$byte_world$1b9" = private constant [15 x i8] c"allocator_data\00", align 1
@"csbs$byte_world$1ba" = private constant [10 x i8] c"alignment\00", align 1
@"csbs$byte_world$1bb" = private constant [11 x i8] c"old_memory\00", align 1
@"csbs$byte_world$1bc" = private constant [9 x i8] c"old_size\00", align 1
@"scl$[4614]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 173, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1bd" = private constant [22 x i8] c"Type_Info_Simd_Vector\00", align 1
@"scl$[2724]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 102, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1be" = private constant [27 x i8] c"Type_Info_Enumerated_Array\00", align 1
@"scl$[199]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$d4", i64 33 }, i32 11, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1bf" = private constant [14 x i8] c"General_Error\00", align 1
@"scl$[5433]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 203, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1c0" = private constant [15 x i8] c"Type_Info_Flag\00", align 1
@"$enum_names-407" = private constant [6 x %..string] [%..string { ptr @"csbs$byte_world$1c1", i64 5 }, %..string { ptr @"csbs$byte_world$1c2", i64 8 }, %..string { ptr @"csbs$byte_world$1c3", i64 9 }, %..string { ptr @"csbs$byte_world$1c4", i64 14 }, %..string { ptr @"csbs$byte_world$1c5", i64 14 }, %..string { ptr @"csbs$byte_world$1c6", i64 15 }], section ".odinti"
@"$enum_values-407" = private constant [6 x i64] [i64 0, i64 1, i64 2, i64 3, i64 4, i64 5], section ".odinti"
@"csbs$byte_world$1c1" = private constant [6 x i8] c"POINT\00", align 1
@"csbs$byte_world$1c2" = private constant [9 x i8] c"BILINEAR\00", align 1
@"csbs$byte_world$1c3" = private constant [10 x i8] c"TRILINEAR\00", align 1
@"csbs$byte_world$1c4" = private constant [15 x i8] c"ANISOTROPIC_4X\00", align 1
@"csbs$byte_world$1c5" = private constant [15 x i8] c"ANISOTROPIC_8X\00", align 1
@"csbs$byte_world$1c6" = private constant [16 x i8] c"ANISOTROPIC_16X\00", align 1
@"scl$[4711]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 178, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1c7" = private constant [17 x i8] c"Type_Info_Matrix\00", align 1
@"csbs$byte_world$1c8" = private constant [13 x i8] c"size_of_type\00", align 1
@"csbs$byte_world$1c9" = private constant [14 x i8] c"align_of_type\00", align 1
@"csbs$byte_world$1ca" = private constant [13 x i8] c"size_of_cell\00", align 1
@"csbs$byte_world$1cb" = private constant [18 x i8] c"elements_per_cell\00", align 1
@"scl$[3002]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 112, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1cc" = private constant [16 x i8] c"Type_Info_Slice\00", align 1
@"scl$[3283]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 120, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1cd" = private constant [22 x i8] c"Type_Info_Struct_Flag\00", align 1
@"scl$[67]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$cf", i64 49 }, i32 4, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1ce" = private constant [33 x i8] c"Thread_Local_Cleaner_Contextless\00", align 1
@"$enum_names-421" = private constant [3 x %..string] [%..string { ptr @"csbs$byte_world$1cf", i64 6 }, %..string { ptr @"csbs$byte_world$1d0", i64 9 }, %..string { ptr @"csbs$byte_world$7a", i64 5 }], section ".odinti"
@"$enum_values-421" = private constant [3 x i64] [i64 0, i64 1, i64 3], section ".odinti"
@"csbs$byte_world$1cf" = private constant [7 x i8] c"packed\00", align 1
@"csbs$byte_world$1d0" = private constant [10 x i8] c"raw_union\00", align 1
@"$enum_names-425" = private constant [3 x %..string] [%..string { ptr @"csbs$byte_world$1d1", i64 6 }, %..string { ptr @"csbs$byte_world$1d2", i64 3 }, %..string { ptr @"csbs$byte_world$1d3", i64 4 }], section ".odinti"
@"$enum_values-425" = private constant [3 x i64] [i64 0, i64 1, i64 2], section ".odinti"
@"csbs$byte_world$1d1" = private constant [7 x i8] c"Normal\00", align 1
@"csbs$byte_world$1d2" = private constant [4 x i8] c"Low\00", align 1
@"csbs$byte_world$1d3" = private constant [5 x i8] c"High\00", align 1
@"scl$[2395]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 88, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1d4" = private constant [24 x i8] c"Type_Info_Multi_Pointer\00", align 1
@"scl$[8614]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$45", i64 36 }, i32 354, i32 1, %..string zeroinitializer }
@"csbs$byte_world$1d5" = private constant [12 x i8] c"Logger_Proc\00", align 1
@"csbs$byte_world$1d6" = private constant [19 x i8] c"futex_wait failure\00", align 1
@"csbs$byte_world$1d7" = private constant [41 x i8] c"/usr/lib/odin/core/sync/futex_linux.odin\00", align 1
@"csbs$byte_world$1d8" = private constant [12 x i8] c"_futex_wait\00", align 1
@"scl$[_futex_wait449]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1d7", i64 40 }, i32 18, i32 3, %..string { ptr @"csbs$byte_world$1d8", i64 11 } }
@"csbs$byte_world$1d9" = private constant [11 x i8] c"res == nil\00", align 1
@"csbs$byte_world$1da" = private constant [43 x i8] c"/usr/lib/odin/core/thread/thread_unix.odin\00", align 1
@"csbs$byte_world$1db" = private constant [8 x i8] c"_create\00", align 1
@"scl$[_create3094]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1da", i64 42 }, i32 92, i32 2, %..string { ptr @"csbs$byte_world$1db", i64 7 } }
@"scl$[_create3231]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1da", i64 42 }, i32 95, i32 3, %..string { ptr @"csbs$byte_world$1db", i64 7 } }
@"scl$[_create3265]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1da", i64 42 }, i32 98, i32 12, %..string { ptr @"csbs$byte_world$1db", i64 7 } }
@"scl$[_create3523]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1da", i64 42 }, i32 108, i32 3, %..string { ptr @"csbs$byte_world$1db", i64 7 } }
@"scl$[_create3630]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1da", i64 42 }, i32 112, i32 2, %..string { ptr @"csbs$byte_world$1db", i64 7 } }
@"scl$[_create3930]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1da", i64 42 }, i32 121, i32 2, %..string { ptr @"csbs$byte_world$1db", i64 7 } }
@"scl$[_create4079]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1da", i64 42 }, i32 125, i32 3, %..string { ptr @"csbs$byte_world$1db", i64 7 } }
@"csbs$byte_world$1dc" = private constant [42 x i8] c"is_integer_negative: Unknown integer size\00", align 1
@"csbs$byte_world$1dd" = private constant [41 x i8] c"/usr/lib/odin/core/strconv/integers.odin\00", align 1
@"csbs$byte_world$1de" = private constant [20 x i8] c"is_integer_negative\00", align 1
@"scl$[is_integer_negative1057]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 45, i32 4, %..string { ptr @"csbs$byte_world$1de", i64 19 } }
@"csbs$byte_world$1df" = private constant [44 x i8] c"/usr/lib/odin/core/unicode/utf16/utf16.odin\00", align 1
@"csbs$byte_world$1e0" = private constant [16 x i8] c"block.used == 0\00", align 1
@"csbs$byte_world$1e1" = private constant [61 x i8] c"/usr/lib/odin/base/runtime/default_temp_allocator_arena.odin\00", align 1
@"csbs$byte_world$1e2" = private constant [19 x i8] c"memory_block_alloc\00", align 1
@"scl$[memory_block_alloc1589]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1e1", i64 60 }, i32 50, i32 2, %..string { ptr @"csbs$byte_world$1e2", i64 18 } }
@"csbs$byte_world$1e3" = private constant [18 x i8] c"block.prev == nil\00", align 1
@"scl$[memory_block_alloc1614]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1e1", i64 60 }, i32 51, i32 2, %..string { ptr @"csbs$byte_world$1e2", i64 18 } }
@"csbs$byte_world$1e4" = private constant [37 x i8] c"/usr/lib/odin/core/bufio/writer.odin\00", align 1
@"csbs$byte_world$1e5" = private constant [15 x i8] c"writer_destroy\00", align 1
@"scl$[writer_destroy948]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1e4", i64 36 }, i32 40, i32 2, %..string { ptr @"csbs$byte_world$1e5", i64 14 } }
@"csbs$byte_world$1e6" = private constant [26 x i8] c"strconv: invalid bit_size\00", align 1
@"csbs$byte_world$1e7" = private constant [46 x i8] c"/usr/lib/odin/core/strconv/generic_float.odin\00", align 1
@"csbs$byte_world$1e8" = private constant [13 x i8] c"generic_ftoa\00", align 1
@"scl$[generic_ftoa1322]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1e7", i64 45 }, i32 60, i32 3, %..string { ptr @"csbs$byte_world$1e8", i64 12 } }
@"csbs$byte_world$1e9" = private constant [4 x i8] c"NaN\00", align 1
@"csbs$byte_world$1ea" = private constant [5 x i8] c"-Inf\00", align 1
@"csbs$byte_world$1eb" = private constant [5 x i8] c"+Inf\00", align 1
@"csbs$byte_world$1ec" = private constant [26 x i8] c"futex_wake_single failure\00", align 1
@"csbs$byte_world$1ed" = private constant [14 x i8] c"_futex_signal\00", align 1
@"scl$[_futex_signal1211]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1d7", i64 40 }, i32 47, i32 3, %..string { ptr @"csbs$byte_world$1ed", i64 13 } }
@"runtime::default_random_generator_proc-.global_rand_seed-35405" = thread_local global %"runtime::Default_Random_State" zeroinitializer, align 8
@"csbs$byte_world$1ee" = private constant [24 x i8] c" Invalid slice indices \00", align 1
@"csbs$byte_world$1ef" = private constant [2 x i8] c":\00", align 1
@"csbs$byte_world$1f0" = private constant [22 x i8] c" is out of range 0..<\00", align 1
@"csbs$byte_world$1f1" = private constant [40 x i8] c"/usr/lib/odin/core/strings/strings.odin\00", align 1
@"csbs$byte_world$1f2" = private constant [24 x i8] c"_futex_wake_all failure\00", align 1
@"csbs$byte_world$1f3" = private constant [17 x i8] c"_futex_broadcast\00", align 1
@"scl$[_futex_broadcast1469]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1d7", i64 40 }, i32 57, i32 3, %..string { ptr @"csbs$byte_world$1f3", i64 16 } }
@"csbs$byte_world$1f4" = private constant [60 x i8] c"/usr/lib/odin/base/runtime/default_temporary_allocator.odin\00", align 1
@"csbs$byte_world$1f5" = private constant [31 x i8] c"default_temp_allocator_destroy\00", align 1
@"scl$[default_temp_allocator_destroy1583]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1f4", i64 59 }, i32 39, i32 4, %..string { ptr @"csbs$byte_world$1f5", i64 30 } }
@"csbs$byte_world$1f6" = private constant [43 x i8] c"/usr/lib/odin/base/runtime/entry_unix.odin\00", align 1
@"csbs$byte_world$1f7" = private constant [43 x i8] c"strconv: illegal base passed to write_bits\00", align 1
@"csbs$byte_world$1f8" = private constant [11 x i8] c"write_bits\00", align 1
@"scl$[write_bits1948]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 67, i32 3, %..string { ptr @"csbs$byte_world$1f8", i64 10 } }
@"csbs$byte_world$1f9" = private constant [30 x i8] c"/usr/lib/odin/core/os/os.odin\00", align 1
@"csbs$byte_world$1fa" = private constant [42 x i8] c"/usr/lib/odin/core/unicode/utf8/utf8.odin\00", align 1
@"csbs$byte_world$1fb" = private constant [33 x i8] c"Alignment must be a power of two\00", align 1
@"csbs$byte_world$1fc" = private constant [27 x i8] c"non-power of two alignment\00", align 1
@"csbs$byte_world$1fd" = private constant [24 x i8] c"is_integer_negative_128\00", align 1
@"scl$[is_integer_negative_1283587]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 143, i32 4, %..string { ptr @"csbs$byte_world$1fd", i64 23 } }
@"csbs$byte_world$1fe" = private constant [3 x i8] c"\\a\00", align 1
@"csbs$byte_world$1ff" = private constant [3 x i8] c"\\b\00", align 1
@"csbs$byte_world$200" = private constant [3 x i8] c"\\e\00", align 1
@"csbs$byte_world$201" = private constant [3 x i8] c"\\f\00", align 1
@"csbs$byte_world$202" = private constant [3 x i8] c"\\n\00", align 1
@"csbs$byte_world$203" = private constant [3 x i8] c"\\r\00", align 1
@"csbs$byte_world$204" = private constant [3 x i8] c"\\t\00", align 1
@"csbs$byte_world$205" = private constant [3 x i8] c"\\v\00", align 1
@"csbs$byte_world$206" = private constant [5 x i8] c"\\x00\00", align 1
@"csbs$byte_world$207" = private constant [3 x i8] c"\\x\00", align 1
@"csbs$byte_world$208" = private constant [38 x i8] c"/usr/lib/odin/base/runtime/print.odin\00", align 1
@"csbs$byte_world$209" = private constant [3 x i8] c"00\00", align 1
@"csbs$byte_world$20a" = private constant [48 x i8] c"/usr/lib/odin/core/strconv/decimal/decimal.odin\00", align 1
@"csbs$byte_world$20b" = private constant [36 x i8] c"read_entire_file_from_handle_or_err\00", align 1
@"scl$[read_entire_file_from_handle_or_err3993]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1f9", i64 29 }, i32 156, i32 3, %..string { ptr @"csbs$byte_world$20b", i64 35 } }
@"scl$[read_entire_file_from_handle_or_err3993].2" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1f9", i64 29 }, i32 156, i32 3, %..string { ptr @"csbs$byte_world$20b", i64 35 } }
@"csbs$byte_world$20c" = private constant [57 x i8] c"/home/craft/Projects/Notebook/byte-world/byte_world.odin\00", align 1
@"csbs$byte_world$20d" = private constant [13 x i8] c"free_pattern\00", align 1
@"scl$[free_pattern4044]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 142, i32 2, %..string { ptr @"csbs$byte_world$20d", i64 12 } }
@"scl$[free_pattern4061]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 143, i32 2, %..string { ptr @"csbs$byte_world$20d", i64 12 } }
@"csbs$byte_world$20e" = private constant [15 x i8] c"write_bits_128\00", align 1
@"scl$[write_bits_1284502]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 165, i32 3, %..string { ptr @"csbs$byte_world$20e", i64 14 } }
@"csbs$byte_world$20f" = private constant [32 x i8] c"/usr/lib/odin/core/io/util.odin\00", align 1
@"csbs$byte_world$210" = private constant [22 x i8] c"detect_active_regions\00", align 1
@"scl$[detect_active_regions4975]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 171, i32 13, %..string { ptr @"csbs$byte_world$210", i64 21 } }
@"scl$[detect_active_regions5064]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 175, i32 11, %..string { ptr @"csbs$byte_world$210", i64 21 } }
@"scl$[detect_active_regions5379]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 186, i32 5, %..string { ptr @"csbs$byte_world$210", i64 21 } }
@"scl$[detect_active_regions5563]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 195, i32 18, %..string { ptr @"csbs$byte_world$210", i64 21 } }
@"scl$[detect_active_regions6251]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 220, i32 8, %..string { ptr @"csbs$byte_world$210", i64 21 } }
@"scl$[detect_active_regions6464]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 228, i32 8, %..string { ptr @"csbs$byte_world$210", i64 21 } }
@"scl$[detect_active_regions6665]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 236, i32 8, %..string { ptr @"csbs$byte_world$210", i64 21 } }
@"scl$[detect_active_regions6874]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 244, i32 8, %..string { ptr @"csbs$byte_world$210", i64 21 } }
@"scl$[detect_active_regions7475]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 266, i32 6, %..string { ptr @"csbs$byte_world$210", i64 21 } }
@"scl$[detect_active_regions5099]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 176, i32 8, %..string { ptr @"csbs$byte_world$210", i64 21 } }
@"scl$[detect_active_regions5012]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 172, i32 8, %..string { ptr @"csbs$byte_world$210", i64 21 } }
@"csbs$byte_world$211" = private constant [9 x i8] c"_destroy\00", align 1
@"scl$[_destroy4942]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1da", i64 42 }, i32 170, i32 2, %..string { ptr @"csbs$byte_world$211", i64 8 } }
@"csbs$byte_world$212" = private constant [40 x i8] c"/usr/lib/odin/core/strings/builder.odin\00", align 1
@"csbs$byte_world$213" = private constant [21 x i8] c"_builder_stream_proc\00", align 1
@"scl$[_builder_stream_proc5172]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$212", i64 39 }, i32 171, i32 11, %..string { ptr @"csbs$byte_world$213", i64 20 } }
@"csbs$byte_world$214" = private constant [41 x i8] c"/usr/lib/odin/base/runtime/internal.odin\00", align 1
@"csbs$byte_world$215" = private constant [4 x i8] c"nil\00", align 1
@"csbs$byte_world$216" = private constant [15 x i8] c"len(array) > 0\00", align 1
@"csbs$byte_world$217" = private constant [4 x i8] c"pop\00", align 1
@"scl$[pop6342]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$9d", i64 44 }, i32 174, i32 2, %..string { ptr @"csbs$byte_world$217", i64 3 } }
@"csbs$byte_world$218" = private constant [4 x i8] c"int\00", align 1
@"csbs$byte_world$219" = private constant [5 x i8] c"uint\00", align 1
@"csbs$byte_world$21a" = private constant [8 x i8] c"uintptr\00", align 1
@"csbs$byte_world$21b" = private constant [5 x i8] c"rune\00", align 1
@"csbs$byte_world$21c" = private constant [8 x i8] c"complex\00", align 1
@"csbs$byte_world$21d" = private constant [11 x i8] c"quaternion\00", align 1
@"csbs$byte_world$21e" = private constant [7 x i8] c"string\00", align 1
@"csbs$byte_world$21f" = private constant [3 x i8] c"16\00", align 1
@"csbs$byte_world$220" = private constant [5 x i8] c"bool\00", align 1
@"csbs$byte_world$221" = private constant [4 x i8] c"any\00", align 1
@"csbs$byte_world$222" = private constant [7 x i8] c"typeid\00", align 1
@"csbs$byte_world$223" = private constant [7 x i8] c"rawptr\00", align 1
@"csbs$byte_world$224" = private constant [2 x i8] c"^\00", align 1
@"csbs$byte_world$225" = private constant [4 x i8] c"[^]\00", align 1
@"csbs$byte_world$226" = private constant [7 x i8] c"#soa ^\00", align 1
@"csbs$byte_world$227" = private constant [5 x i8] c"proc\00", align 1
@"csbs$byte_world$228" = private constant [3 x i8] c"()\00", align 1
@"csbs$byte_world$229" = private constant [3 x i8] c", \00", align 1
@"csbs$byte_world$22a" = private constant [2 x i8] c")\00", align 1
@"csbs$byte_world$22b" = private constant [5 x i8] c" -> \00", align 1
@"csbs$byte_world$22c" = private constant [3 x i8] c": \00", align 1
@"csbs$byte_world$22d" = private constant [8 x i8] c"#sparse\00", align 1
@"csbs$byte_world$22e" = private constant [10 x i8] c"[dynamic]\00", align 1
@"csbs$byte_world$22f" = private constant [3 x i8] c"[]\00", align 1
@"csbs$byte_world$230" = private constant [5 x i8] c"map[\00", align 1
@"csbs$byte_world$231" = private constant [6 x i8] c"#soa[\00", align 1
@"csbs$byte_world$232" = private constant [7 x i8] c"#soa[]\00", align 1
@"csbs$byte_world$233" = private constant [14 x i8] c"#soa[dynamic]\00", align 1
@"csbs$byte_world$234" = private constant [8 x i8] c"struct \00", align 1
@"csbs$byte_world$235" = private constant [9 x i8] c"#packed \00", align 1
@"csbs$byte_world$236" = private constant [12 x i8] c"#raw_union \00", align 1
@"csbs$byte_world$237" = private constant [8 x i8] c"#align(\00", align 1
@"csbs$byte_world$238" = private constant [3 x i8] c") \00", align 1
@"csbs$byte_world$239" = private constant [7 x i8] c"union \00", align 1
@"csbs$byte_world$23a" = private constant [9 x i8] c"#no_nil \00", align 1
@"csbs$byte_world$23b" = private constant [2 x i8] c"}\00", align 1
@"csbs$byte_world$23c" = private constant [6 x i8] c"enum \00", align 1
@"csbs$byte_world$23d" = private constant [3 x i8] c" {\00", align 1
@"csbs$byte_world$23e" = private constant [9 x i8] c"bit_set[\00", align 1
@"csbs$byte_world$23f" = private constant [3 x i8] c"..\00", align 1
@"csbs$byte_world$240" = private constant [3 x i8] c"; \00", align 1
@"csbs$byte_world$241" = private constant [11 x i8] c"bit_field \00", align 1
@"csbs$byte_world$242" = private constant [4 x i8] c" | \00", align 1
@"csbs$byte_world$243" = private constant [7 x i8] c"#simd[\00", align 1
@"csbs$byte_world$244" = private constant [8 x i8] c"matrix[\00", align 1
@"csbs$byte_world$245" = private constant [2 x i8] c"]\00", align 1
@"csbs$byte_world$246" = private constant [16 x i8] c"builder_destroy\00", align 1
@"scl$[builder_destroy5982]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$212", i64 39 }, i32 219, i32 2, %..string { ptr @"csbs$byte_world$246", i64 15 } }
@"csbs$byte_world$247" = private constant [32 x i8] c"/usr/lib/odin/core/fmt/fmt.odin\00", align 1
@"csbs$byte_world$248" = private constant [8 x i8] c"tprintf\00", align 1
@"scl$[tprintf6994]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$247", i64 31 }, i32 230, i32 2, %..string { ptr @"csbs$byte_world$248", i64 7 } }
@"csbs$byte_world$249" = private constant [7 x i8] c"k < 61\00", align 1
@"csbs$byte_world$24a" = private constant [11 x i8] c"shift_left\00", align 1
@"scl$[shift_left8268]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20a", i64 47 }, i32 365, i32 2, %..string { ptr @"csbs$byte_world$24a", i64 10 } }
@"csbs$byte_world$24b" = private constant [10 x i8] c"nil arena\00", align 1
@"csbs$byte_world$24c" = private constant [18 x i8] c"temp.block == nil\00", align 1
@"csbs$byte_world$24d" = private constant [15 x i8] c"arena_temp_end\00", align 1
@"scl$[arena_temp_end8497]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1e1", i64 60 }, i32 287, i32 3, %..string { ptr @"csbs$byte_world$24d", i64 14 } }
@"csbs$byte_world$24e" = private constant [15 x i8] c"temp.used == 0\00", align 1
@"scl$[arena_temp_end8525]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1e1", i64 60 }, i32 288, i32 3, %..string { ptr @"csbs$byte_world$24d", i64 14 } }
@"csbs$byte_world$24f" = private constant [57 x i8] c"memory block stored within Arena_Temp not owned by Arena\00", align 1
@"scl$[arena_temp_end8962]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$1e1", i64 60 }, i32 306, i32 4, %..string { ptr @"csbs$byte_world$24d", i64 14 } }
@"csbs$byte_world$250" = private constant [35 x i8] c"out of order use of arena_temp_end\00", align 1
@"csbs$byte_world$251" = private constant [29 x i8] c"double-use of arena_temp_end\00", align 1
@"csbs$byte_world$252" = private constant [6 x i8] c"n > 0\00", align 1
@"csbs$byte_world$253" = private constant [7 x i8] c"wrap_i\00", align 1
@"scl$[wrap_i8657]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 329, i32 2, %..string { ptr @"csbs$byte_world$253", i64 6 } }
@"csbs$byte_world$254" = private constant [9 x i8] c"size > 0\00", align 1
@"csbs$byte_world$255" = private constant [16 x i8] c"byte_world_make\00", align 1
@"scl$[byte_world_make10720]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 421, i32 2, %..string { ptr @"csbs$byte_world$255", i64 15 } }
@"scl$[byte_world_make10831]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 425, i32 10, %..string { ptr @"csbs$byte_world$255", i64 15 } }
@"scl$[byte_world_make10864]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 426, i32 11, %..string { ptr @"csbs$byte_world$255", i64 15 } }
@"scl$[byte_world_make10902]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 427, i32 15, %..string { ptr @"csbs$byte_world$255", i64 15 } }
@"scl$[byte_world_make11028]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 430, i32 34, %..string { ptr @"csbs$byte_world$255", i64 15 } }
@"scl$[byte_world_make11098]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 431, i32 34, %..string { ptr @"csbs$byte_world$255", i64 15 } }
@"ggv$main::byte_world_make$1" = private constant %"main::Byte_World" { i64 0, i64 0, { ptr, i64 } zeroinitializer, { ptr, i64 } zeroinitializer, %"main::Spark_Buffer" zeroinitializer, %"main::Spark_Buffer" zeroinitializer, { ptr, i64 } zeroinitializer, i32 1, i32 0, i8 1, [7 x i8] zeroinitializer, i64 0 }
@"ggv$map_cell_info-13197927915248882629" = private constant %"runtime::Map_Cell_Info" { i64 8, i64 8, i64 64, i64 8 }
@"csbs$byte_world$256" = private constant [23 x i8] c"is_power_of_two(align)\00", align 1
@"csbs$byte_world$257" = private constant [32 x i8] c"/usr/lib/odin/core/mem/mem.odin\00", align 1
@"csbs$byte_world$258" = private constant [22 x i8] c"align_forward_uintptr\00", align 1
@"scl$[align_forward_uintptr14911]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$257", i64 31 }, i32 502, i32 2, %..string { ptr @"csbs$byte_world$258", i64 21 } }
@"csbs$byte_world$259" = private constant [39 x i8] c"allocation not aligned to a cache line\00", align 1
@"csbs$byte_world$25a" = private constant [23 x i8] c"align_backward_uintptr\00", align 1
@"scl$[align_backward_uintptr16529]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$257", i64 31 }, i32 559, i32 2, %..string { ptr @"csbs$byte_world$25a", i64 22 } }
@"csbs$byte_world$25b" = private constant [28 x i8] c"unable to insert into a map\00", align 1
@"csbs$byte_world$25c" = private constant [33 x i8] c"map_insert_hash_dynamic_with_key\00", align 1
@"scl$[map_insert_hash_dynamic_with_key17600]" = private constant %"runtime::Source_Code_Location" { %..string { ptr @"csbs$byte_world$91", i64 52 }, i32 425, i32 4, %..string { ptr @"csbs$byte_world$25c", i64 32 } }

; Function Attrs: noinline optnone
define weak hidden void @"__$startup_runtime"(ptr noalias nonnull "captures"="none" %__.context_ptr) #0 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  call void @"__$startup$os::args"(ptr %__.context_ptr)
  ret void
}

; Function Attrs: nounwind
define internal i8 @"__$equal-16425491715425561513"(ptr nonnull %0, ptr nonnull %1) #1 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %2 = icmp eq ptr %0, %1
  br i1 %2, label %same_ptr, label %diff_ptr

same_ptr:                                         ; preds = %entry
  ret i8 1

diff_ptr:                                         ; preds = %entry
  %3 = getelementptr inbounds nuw { %..string, i32, i32, %..string }, ptr %0, i32 0, i32 0
  %4 = getelementptr inbounds nuw { %..string, i32, i32, %..string }, ptr %1, i32 0, i32 0
  %5 = load %..string, ptr %3, align 8
  %6 = load %..string, ptr %4, align 8
  %7 = call i8 @"runtime::string_eq"(%..string %5, %..string %6)
  %8 = trunc i8 %7 to i1
  br i1 %8, label %btrue, label %bfalse

btrue:                                            ; preds = %diff_ptr
  %9 = getelementptr inbounds nuw { %..string, i32, i32, %..string }, ptr %0, i32 0, i32 1
  %10 = getelementptr inbounds nuw { %..string, i32, i32, %..string }, ptr %1, i32 0, i32 1
  %11 = load i32, ptr %9, align 4
  %12 = load i32, ptr %10, align 4
  %13 = icmp eq i32 %11, %12
  br i1 %13, label %btrue1, label %bfalse

btrue1:                                           ; preds = %btrue
  %14 = getelementptr inbounds nuw { %..string, i32, i32, %..string }, ptr %0, i32 0, i32 2
  %15 = getelementptr inbounds nuw { %..string, i32, i32, %..string }, ptr %1, i32 0, i32 2
  %16 = load i32, ptr %14, align 4
  %17 = load i32, ptr %15, align 4
  %18 = icmp eq i32 %16, %17
  br i1 %18, label %btrue2, label %bfalse

btrue2:                                           ; preds = %btrue1
  %19 = getelementptr inbounds nuw { %..string, i32, i32, %..string }, ptr %0, i32 0, i32 3
  %20 = getelementptr inbounds nuw { %..string, i32, i32, %..string }, ptr %1, i32 0, i32 3
  %21 = load %..string, ptr %19, align 8
  %22 = load %..string, ptr %20, align 8
  %23 = call i8 @"runtime::string_eq"(%..string %21, %..string %22)
  %24 = trunc i8 %23 to i1
  br i1 %24, label %btrue3, label %bfalse

btrue3:                                           ; preds = %btrue2
  ret i8 1

bfalse:                                           ; preds = %btrue2, %btrue1, %btrue, %diff_ptr
  ret i8 0
}

; Function Attrs: nounwind
define internal i8 @"__$equal-1905637414496559711"(ptr nonnull %0, ptr nonnull %1) #1 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %2 = icmp eq ptr %0, %1
  br i1 %2, label %same_ptr, label %diff_ptr

same_ptr:                                         ; preds = %entry
  ret i8 1

diff_ptr:                                         ; preds = %entry
  %3 = getelementptr inbounds nuw { i32, i32 }, ptr %0, i32 0, i32 1
  %4 = load i32, ptr %3, align 4
  %5 = getelementptr inbounds nuw { i32, i32 }, ptr %1, i32 0, i32 1
  %6 = load i32, ptr %5, align 4
  %7 = icmp eq i32 %4, %6
  br i1 %7, label %bswitch, label %bfalse

bswitch:                                          ; preds = %diff_ptr
  switch i32 %4, label %bfalse [
    i32 0, label %bcase
    i32 1, label %bcase1
    i32 2, label %bcase2
    i32 3, label %bcase3
    i32 4, label %bcase4
  ]

bcase:                                            ; preds = %bswitch
  ret i8 1

bcase1:                                           ; preds = %bswitch
  %8 = load i32, ptr %0, align 4
  %9 = load i32, ptr %1, align 4
  %10 = icmp eq i32 %8, %9
  %11 = zext i1 %10 to i8
  ret i8 %11

bcase2:                                           ; preds = %bswitch
  %12 = load i32, ptr %0, align 4
  %13 = load i32, ptr %1, align 4
  %14 = icmp eq i32 %12, %13
  %15 = zext i1 %14 to i8
  ret i8 %15

bcase3:                                           ; preds = %bswitch
  %16 = load i8, ptr %0, align 1
  %17 = load i8, ptr %1, align 1
  %18 = icmp eq i8 %16, %17
  %19 = zext i1 %18 to i8
  ret i8 %19

bcase4:                                           ; preds = %bswitch
  %20 = load i32, ptr %0, align 4
  %21 = load i32, ptr %1, align 4
  %22 = icmp eq i32 %20, %21
  %23 = zext i1 %22 to i8
  ret i8 %23

bfalse:                                           ; preds = %bswitch, %diff_ptr
  ret i8 0
}

; Function Attrs: nounwind
define internal i8 @"__$equal-7674627286601529764"(ptr nonnull %0, ptr nonnull %1) #1 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %2 = icmp eq ptr %0, %1
  br i1 %2, label %same_ptr, label %diff_ptr

same_ptr:                                         ; preds = %entry
  ret i8 1

diff_ptr:                                         ; preds = %entry
  %3 = getelementptr inbounds nuw { %..string, ptr, %..string, ptr }, ptr %0, i32 0, i32 0
  %4 = getelementptr inbounds nuw { %..string, ptr, %..string, ptr }, ptr %1, i32 0, i32 0
  %5 = load %..string, ptr %3, align 8
  %6 = load %..string, ptr %4, align 8
  %7 = call i8 @"runtime::string_eq"(%..string %5, %..string %6)
  %8 = trunc i8 %7 to i1
  br i1 %8, label %btrue, label %bfalse

btrue:                                            ; preds = %diff_ptr
  %9 = getelementptr inbounds nuw { %..string, ptr, %..string, ptr }, ptr %0, i32 0, i32 1
  %10 = getelementptr inbounds nuw { %..string, ptr, %..string, ptr }, ptr %1, i32 0, i32 1
  %11 = load ptr, ptr %9, align 8
  %12 = load ptr, ptr %10, align 8
  %13 = icmp eq ptr %11, %12
  br i1 %13, label %btrue1, label %bfalse

btrue1:                                           ; preds = %btrue
  %14 = getelementptr inbounds nuw { %..string, ptr, %..string, ptr }, ptr %0, i32 0, i32 2
  %15 = getelementptr inbounds nuw { %..string, ptr, %..string, ptr }, ptr %1, i32 0, i32 2
  %16 = load %..string, ptr %14, align 8
  %17 = load %..string, ptr %15, align 8
  %18 = call i8 @"runtime::string_eq"(%..string %16, %..string %17)
  %19 = trunc i8 %18 to i1
  br i1 %19, label %btrue2, label %bfalse

btrue2:                                           ; preds = %btrue1
  %20 = getelementptr inbounds nuw { %..string, ptr, %..string, ptr }, ptr %0, i32 0, i32 3
  %21 = getelementptr inbounds nuw { %..string, ptr, %..string, ptr }, ptr %1, i32 0, i32 3
  %22 = load ptr, ptr %20, align 8
  %23 = load ptr, ptr %21, align 8
  %24 = icmp eq ptr %22, %23
  br i1 %24, label %btrue3, label %bfalse

btrue3:                                           ; preds = %btrue2
  ret i8 1

bfalse:                                           ; preds = %btrue2, %btrue1, %btrue, %diff_ptr
  ret i8 0
}

; Function Attrs: nounwind
define internal i8 @"__$equal-12420968667424683282"(ptr nonnull %0, ptr nonnull %1) #1 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %2 = icmp eq ptr %0, %1
  br i1 %2, label %same_ptr, label %diff_ptr

same_ptr:                                         ; preds = %entry
  ret i8 1

diff_ptr:                                         ; preds = %entry
  %3 = getelementptr inbounds nuw { ptr, i64 }, ptr %0, i32 0, i32 1
  %4 = load i64, ptr %3, align 8
  %5 = getelementptr inbounds nuw { ptr, i64 }, ptr %1, i32 0, i32 1
  %6 = load i64, ptr %5, align 8
  %7 = icmp eq i64 %4, %6
  br i1 %7, label %bswitch, label %bfalse

bswitch:                                          ; preds = %diff_ptr
  switch i64 %4, label %bfalse [
    i64 0, label %bcase
    i64 1, label %bcase1
    i64 2, label %bcase2
  ]

bcase:                                            ; preds = %bswitch
  ret i8 1

bcase1:                                           ; preds = %bswitch
  %8 = load ptr, ptr %0, align 8
  %9 = load ptr, ptr %1, align 8
  %10 = icmp eq ptr %8, %9
  %11 = zext i1 %10 to i8
  ret i8 %11

bcase2:                                           ; preds = %bswitch
  %12 = load ptr, ptr %0, align 8
  %13 = load ptr, ptr %1, align 8
  %14 = icmp eq ptr %12, %13
  %15 = zext i1 %14 to i8
  ret i8 %15

bfalse:                                           ; preds = %bswitch, %diff_ptr
  ret i8 0
}

define weak hidden void @"__$startup$os::args"(ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %0 = call { ptr, i64 } @"os::[os_linux.odin]::_alloc_command_line_arguments"()
  store { ptr, i64 } %0, ptr @"os::args", align 8
  ret void
}

declare internal { ptr, i64 } @"os::[os_linux.odin]::_alloc_command_line_arguments"()

; Function Attrs: noinline optnone
define weak hidden void @"__$cleanup_runtime"(ptr noalias nonnull "captures"="none" %__.context_ptr) #0 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  call void @"os::[os_linux.odin]::_delete_command_line_arguments"()
  call void @"runtime::[default_temporary_allocator.odin]::_destroy_temp_allocator_fini"()
  ret void
}

declare internal void @"os::[os_linux.odin]::_delete_command_line_arguments"()

define internal void @"runtime::[default_temporary_allocator.odin]::_destroy_temp_allocator_fini"() {
decls:
  br label %entry

entry:                                            ; preds = %decls
  call void @"runtime::default_temp_allocator_destroy"(ptr @"runtime::global_default_temp_allocator_data")
  ret void
}

define internal { i64, i64 } @"os::stream_from_handle"(i32 %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca i32, align 4
  %s = alloca %"io::Stream", align 8
  %2 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %1, align 4
  call void @llvm.memset.inline.p0.i64(ptr %s, i8 0, i64 16, i1 false)
  %3 = getelementptr inbounds nuw %"io::Stream", ptr %s, i32 0, i32 1
  %4 = sext i32 %0 to i64
  %5 = inttoptr i64 %4 to ptr
  store ptr %5, ptr %3, align 8
  %6 = getelementptr inbounds nuw %"io::Stream", ptr %s, i32 0, i32 0
  store ptr @"os::[stream.odin]::_file_stream_proc", ptr %6, align 8
  %7 = load %"io::Stream", ptr %s, align 8
  store %"io::Stream" %7, ptr %2, align 8
  %8 = load { i64, i64 }, ptr %2, align 8
  ret { i64, i64 } %8
}

; Function Attrs: noreturn
define internal void @"runtime::bounds_trap"() #2 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.trap()
  unreachable
}

define internal i128 @"runtime::udivmod128"(i128 %0, i128 %1, ptr %2) {
decls:
  %3 = alloca i128, align 16
  %4 = alloca i128, align 16
  %5 = alloca ptr, align 8
  %6 = alloca i128, align 16
  %n = alloca [2 x i64], align 8
  %7 = alloca i128, align 16
  %d = alloca [2 x i64], align 8
  %q = alloca [2 x i64], align 16
  %r = alloca [2 x i64], align 16
  %sr = alloca i32, align 4
  %res = alloca i64, align 8
  %carry = alloca i32, align 4
  %r_all = alloca i128, align 16
  %s = alloca i128, align 16
  %q_all = alloca i128, align 16
  br label %entry

entry:                                            ; preds = %decls
  store i128 %0, ptr %3, align 16
  store i128 %1, ptr %4, align 16
  store ptr %2, ptr %5, align 8
  store i128 %0, ptr %6, align 16
  %8 = load [2 x i64], ptr %6, align 8
  store [2 x i64] %8, ptr %n, align 8
  store i128 %1, ptr %7, align 16
  %9 = load [2 x i64], ptr %7, align 8
  store [2 x i64] %9, ptr %d, align 8
  call void @llvm.memset.inline.p0.i64(ptr %q, i8 0, i64 16, i1 false)
  call void @llvm.memset.inline.p0.i64(ptr %r, i8 0, i64 16, i1 false)
  store i32 0, ptr %sr, align 4
  %10 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %11 = load i64, ptr %10, align 8
  %12 = icmp eq i64 %11, 0
  %13 = zext i1 %12 to i8
  %14 = icmp ne i8 %13, 0
  br i1 %14, label %if.then, label %if.done6

if.then:                                          ; preds = %entry
  %15 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %16 = load i64, ptr %15, align 8
  %17 = icmp eq i64 %16, 0
  %18 = zext i1 %17 to i8
  %19 = icmp ne i8 %18, 0
  br i1 %19, label %if.then1, label %if.done3

if.then1:                                         ; preds = %if.then
  %20 = icmp ne ptr %2, null
  %21 = zext i1 %20 to i8
  %22 = icmp ne i8 %21, 0
  br i1 %22, label %if.then2, label %if.done

if.then2:                                         ; preds = %if.then1
  %23 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %24 = load i64, ptr %23, align 8
  %25 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %26 = load i64, ptr %25, align 8
  %27 = icmp ne i64 %26, 0
  br i1 %27, label %mod.safe, label %mod.edge

mod.safe:                                         ; preds = %if.then2
  %28 = urem i64 %24, %26
  br label %mod.done

mod.edge:                                         ; preds = %if.then2
  call void @llvm.trap()
  unreachable

mod.done:                                         ; preds = %mod.safe
  store i64 %28, ptr %res, align 8
  %29 = load i64, ptr %res, align 8
  %30 = zext i64 %29 to i128
  store i128 %30, ptr %2, align 16
  br label %if.done

if.done:                                          ; preds = %mod.done, %if.then1
  %31 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %32 = load i64, ptr %31, align 8
  %33 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %34 = load i64, ptr %33, align 8
  %35 = icmp ne i64 %34, 0
  br i1 %35, label %div.safe, label %div.edge

div.safe:                                         ; preds = %if.done
  %36 = udiv i64 %32, %34
  br label %div.done

div.edge:                                         ; preds = %if.done
  call void @llvm.trap()
  unreachable

div.done:                                         ; preds = %div.safe
  %37 = zext i64 %36 to i128
  ret i128 %37

if.done3:                                         ; preds = %if.then
  %38 = icmp ne ptr %2, null
  %39 = zext i1 %38 to i8
  %40 = icmp ne i8 %39, 0
  br i1 %40, label %if.then4, label %if.done5

if.then4:                                         ; preds = %if.done3
  %41 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %42 = load i64, ptr %41, align 8
  %43 = zext i64 %42 to i128
  store i128 %43, ptr %2, align 16
  br label %if.done5

if.done5:                                         ; preds = %if.then4, %if.done3
  ret i128 0

if.done6:                                         ; preds = %entry
  %44 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %45 = load i64, ptr %44, align 8
  %46 = icmp eq i64 %45, 0
  %47 = zext i1 %46 to i8
  %48 = icmp ne i8 %47, 0
  br i1 %48, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.done6
  %49 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %50 = load i64, ptr %49, align 8
  %51 = icmp eq i64 %50, 0
  %52 = zext i1 %51 to i8
  %53 = icmp ne i8 %52, 0
  br i1 %53, label %if.then8, label %if.done17

if.then8:                                         ; preds = %if.then7
  %54 = icmp ne ptr %2, null
  %55 = zext i1 %54 to i8
  %56 = icmp ne i8 %55, 0
  br i1 %56, label %if.then9, label %if.done13

if.then9:                                         ; preds = %if.then8
  %57 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %58 = load i64, ptr %57, align 8
  %59 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %60 = load i64, ptr %59, align 8
  %61 = icmp ne i64 %60, 0
  br i1 %61, label %mod.safe10, label %mod.edge11

mod.safe10:                                       ; preds = %if.then9
  %62 = urem i64 %58, %60
  br label %mod.done12

mod.edge11:                                       ; preds = %if.then9
  call void @llvm.trap()
  unreachable

mod.done12:                                       ; preds = %mod.safe10
  %63 = zext i64 %62 to i128
  store i128 %63, ptr %2, align 16
  br label %if.done13

if.done13:                                        ; preds = %mod.done12, %if.then8
  %64 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %65 = load i64, ptr %64, align 8
  %66 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %67 = load i64, ptr %66, align 8
  %68 = icmp ne i64 %67, 0
  br i1 %68, label %div.safe14, label %div.edge15

div.safe14:                                       ; preds = %if.done13
  %69 = udiv i64 %65, %67
  br label %div.done16

div.edge15:                                       ; preds = %if.done13
  call void @llvm.trap()
  unreachable

div.done16:                                       ; preds = %div.safe14
  %70 = zext i64 %69 to i128
  ret i128 %70

if.done17:                                        ; preds = %if.then7
  %71 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %72 = load i64, ptr %71, align 8
  %73 = icmp eq i64 %72, 0
  %74 = zext i1 %73 to i8
  %75 = icmp ne i8 %74, 0
  br i1 %75, label %if.then18, label %if.done27

if.then18:                                        ; preds = %if.done17
  %76 = icmp ne ptr %2, null
  %77 = zext i1 %76 to i8
  %78 = icmp ne i8 %77, 0
  br i1 %78, label %if.then19, label %if.done23

if.then19:                                        ; preds = %if.then18
  %79 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  %80 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %81 = load i64, ptr %80, align 8
  %82 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %83 = load i64, ptr %82, align 8
  %84 = icmp ne i64 %83, 0
  br i1 %84, label %mod.safe20, label %mod.edge21

mod.safe20:                                       ; preds = %if.then19
  %85 = urem i64 %81, %83
  br label %mod.done22

mod.edge21:                                       ; preds = %if.then19
  call void @llvm.trap()
  unreachable

mod.done22:                                       ; preds = %mod.safe20
  store i64 %85, ptr %79, align 8
  %86 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  store i64 0, ptr %86, align 8
  %87 = load [2 x i64], ptr %r, align 8
  %88 = load i128, ptr %r, align 16
  store i128 %88, ptr %2, align 16
  br label %if.done23

if.done23:                                        ; preds = %mod.done22, %if.then18
  %89 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %90 = load i64, ptr %89, align 8
  %91 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %92 = load i64, ptr %91, align 8
  %93 = icmp ne i64 %92, 0
  br i1 %93, label %div.safe24, label %div.edge25

div.safe24:                                       ; preds = %if.done23
  %94 = udiv i64 %90, %92
  br label %div.done26

div.edge25:                                       ; preds = %if.done23
  call void @llvm.trap()
  unreachable

div.done26:                                       ; preds = %div.safe24
  %95 = zext i64 %94 to i128
  ret i128 %95

if.done27:                                        ; preds = %if.done17
  %96 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %97 = load i64, ptr %96, align 8
  %98 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %99 = load i64, ptr %98, align 8
  %100 = sub i64 %99, 1
  %101 = and i64 %97, %100
  %102 = icmp eq i64 %101, 0
  %103 = zext i1 %102 to i8
  %104 = icmp ne i8 %103, 0
  br i1 %104, label %if.then28, label %if.done31

if.then28:                                        ; preds = %if.done27
  %105 = icmp ne ptr %2, null
  %106 = zext i1 %105 to i8
  %107 = icmp ne i8 %106, 0
  br i1 %107, label %if.then29, label %if.done30

if.then29:                                        ; preds = %if.then28
  %108 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %109 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %110 = load i64, ptr %109, align 8
  store i64 %110, ptr %108, align 8
  %111 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  %112 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %113 = load i64, ptr %112, align 8
  %114 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %115 = load i64, ptr %114, align 8
  %116 = sub i64 %115, 1
  %117 = and i64 %113, %116
  store i64 %117, ptr %111, align 8
  %118 = load [2 x i64], ptr %r, align 8
  %119 = load i128, ptr %r, align 16
  store i128 %119, ptr %2, align 16
  br label %if.done30

if.done30:                                        ; preds = %if.then29, %if.then28
  %120 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %121 = load i64, ptr %120, align 8
  %122 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %123 = load i64, ptr %122, align 8
  %124 = call i64 @llvm.cttz.i64(i64 %123, i1 false)
  %125 = icmp ult i64 %124, 64
  %126 = lshr i64 %121, %124
  %127 = select i1 %125, i64 %126, i64 0
  %128 = zext i64 %127 to i128
  ret i128 %128

if.done31:                                        ; preds = %if.done27
  %129 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %130 = load i64, ptr %129, align 8
  %131 = call i64 @llvm.ctlz.i64(i64 %130, i1 false)
  %132 = trunc i64 %131 to i32
  %133 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %134 = load i64, ptr %133, align 8
  %135 = call i64 @llvm.ctlz.i64(i64 %134, i1 false)
  %136 = trunc i64 %135 to i32
  %137 = sub i32 %132, %136
  store i32 %137, ptr %sr, align 4
  %138 = load i32, ptr %sr, align 4
  %139 = icmp ugt i32 %138, 62
  %140 = zext i1 %139 to i8
  %141 = icmp ne i8 %140, 0
  br i1 %141, label %if.then32, label %if.done35

if.then32:                                        ; preds = %if.done31
  %142 = icmp ne ptr %2, null
  %143 = zext i1 %142 to i8
  %144 = icmp ne i8 %143, 0
  br i1 %144, label %if.then33, label %if.done34

if.then33:                                        ; preds = %if.then32
  store i128 %0, ptr %2, align 16
  br label %if.done34

if.done34:                                        ; preds = %if.then33, %if.then32
  ret i128 0

if.done35:                                        ; preds = %if.done31
  %145 = load i32, ptr %sr, align 4
  %146 = add i32 %145, 1
  store i32 %146, ptr %sr, align 4
  %147 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  store i64 0, ptr %147, align 8
  %148 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %149 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %150 = load i64, ptr %149, align 8
  %151 = load i32, ptr %sr, align 4
  %152 = sub i32 64, %151
  %153 = zext i32 %152 to i64
  %154 = icmp ult i64 %153, 64
  %155 = shl i64 %150, %153
  %156 = select i1 %154, i64 %155, i64 0
  store i64 %156, ptr %148, align 8
  %157 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  %158 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %159 = load i64, ptr %158, align 8
  %160 = load i32, ptr %sr, align 4
  %161 = zext i32 %160 to i64
  %162 = icmp ult i64 %161, 64
  %163 = lshr i64 %159, %161
  %164 = select i1 %162, i64 %163, i64 0
  store i64 %164, ptr %157, align 8
  %165 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %166 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %167 = load i64, ptr %166, align 8
  %168 = load i32, ptr %sr, align 4
  %169 = sub i32 64, %168
  %170 = zext i32 %169 to i64
  %171 = icmp ult i64 %170, 64
  %172 = shl i64 %167, %170
  %173 = select i1 %171, i64 %172, i64 0
  %174 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %175 = load i64, ptr %174, align 8
  %176 = load i32, ptr %sr, align 4
  %177 = zext i32 %176 to i64
  %178 = icmp ult i64 %177, 64
  %179 = lshr i64 %175, %177
  %180 = select i1 %178, i64 %179, i64 0
  %181 = or i64 %173, %180
  store i64 %181, ptr %165, align 8
  br label %if.done54

if.else:                                          ; preds = %if.done6
  %182 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %183 = load i64, ptr %182, align 8
  %184 = icmp eq i64 %183, 0
  %185 = zext i1 %184 to i8
  %186 = icmp ne i8 %185, 0
  br i1 %186, label %if.then36, label %if.else45

if.then36:                                        ; preds = %if.else
  %187 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %188 = load i64, ptr %187, align 8
  %189 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %190 = load i64, ptr %189, align 8
  %191 = sub i64 %190, 1
  %192 = and i64 %188, %191
  %193 = icmp eq i64 %192, 0
  %194 = zext i1 %193 to i8
  %195 = icmp ne i8 %194, 0
  br i1 %195, label %if.then37, label %if.done42

if.then37:                                        ; preds = %if.then36
  %196 = icmp ne ptr %2, null
  %197 = zext i1 %196 to i8
  %198 = icmp ne i8 %197, 0
  br i1 %198, label %if.then38, label %if.done39

if.then38:                                        ; preds = %if.then37
  %199 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %200 = load i64, ptr %199, align 8
  %201 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %202 = load i64, ptr %201, align 8
  %203 = sub i64 %202, 1
  %204 = and i64 %200, %203
  %205 = zext i64 %204 to i128
  store i128 %205, ptr %2, align 16
  br label %if.done39

if.done39:                                        ; preds = %if.then38, %if.then37
  %206 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %207 = load i64, ptr %206, align 8
  %208 = icmp eq i64 %207, 1
  %209 = zext i1 %208 to i8
  %210 = icmp ne i8 %209, 0
  br i1 %210, label %if.then40, label %if.done41

if.then40:                                        ; preds = %if.done39
  ret i128 %0

if.done41:                                        ; preds = %if.done39
  %211 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %212 = load i64, ptr %211, align 8
  %213 = call i64 @llvm.cttz.i64(i64 %212, i1 false)
  %214 = trunc i64 %213 to i32
  store i32 %214, ptr %sr, align 4
  %215 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %216 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %217 = load i64, ptr %216, align 8
  %218 = load i32, ptr %sr, align 4
  %219 = zext i32 %218 to i64
  %220 = icmp ult i64 %219, 64
  %221 = lshr i64 %217, %219
  %222 = select i1 %220, i64 %221, i64 0
  store i64 %222, ptr %215, align 8
  %223 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  %224 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %225 = load i64, ptr %224, align 8
  %226 = load i32, ptr %sr, align 4
  %227 = sub i32 64, %226
  %228 = zext i32 %227 to i64
  %229 = icmp ult i64 %228, 64
  %230 = shl i64 %225, %228
  %231 = select i1 %229, i64 %230, i64 0
  %232 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %233 = load i64, ptr %232, align 8
  %234 = load i32, ptr %sr, align 4
  %235 = zext i32 %234 to i64
  %236 = icmp ult i64 %235, 64
  %237 = lshr i64 %233, %235
  %238 = select i1 %236, i64 %237, i64 0
  %239 = or i64 %231, %238
  store i64 %239, ptr %223, align 8
  %240 = load [2 x i64], ptr %q, align 8
  %241 = load i128, ptr %q, align 16
  ret i128 %241

if.done42:                                        ; preds = %if.then36
  %242 = getelementptr [2 x i64], ptr %d, i64 0, i64 0
  %243 = load i64, ptr %242, align 8
  %244 = call i64 @llvm.ctlz.i64(i64 %243, i1 false)
  %245 = trunc i64 %244 to i32
  %246 = add i32 65, %245
  %247 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %248 = load i64, ptr %247, align 8
  %249 = call i64 @llvm.ctlz.i64(i64 %248, i1 false)
  %250 = trunc i64 %249 to i32
  %251 = sub i32 %246, %250
  store i32 %251, ptr %sr, align 4
  %252 = load i32, ptr %sr, align 4
  %253 = icmp eq i32 %252, 64
  %254 = zext i1 %253 to i8
  %255 = icmp eq i8 1, %254
  br i1 %255, label %switch.case.body, label %switch.case.next

switch.case.next:                                 ; preds = %if.done42
  %256 = load i32, ptr %sr, align 4
  %257 = icmp ult i32 %256, 64
  %258 = zext i1 %257 to i8
  %259 = icmp eq i8 1, %258
  br i1 %259, label %switch.case.body44, label %switch.case.next43

switch.case.body:                                 ; preds = %if.done42
  %260 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  store i64 0, ptr %260, align 8
  %261 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %262 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %263 = load i64, ptr %262, align 8
  store i64 %263, ptr %261, align 8
  %264 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  store i64 0, ptr %264, align 8
  %265 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %266 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %267 = load i64, ptr %266, align 8
  store i64 %267, ptr %265, align 8
  br label %switch.done

switch.case.next43:                               ; preds = %switch.case.next
  br label %switch.default.body

switch.case.body44:                               ; preds = %switch.case.next
  %268 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  store i64 0, ptr %268, align 8
  %269 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %270 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %271 = load i64, ptr %270, align 8
  %272 = load i32, ptr %sr, align 4
  %273 = sub i32 64, %272
  %274 = zext i32 %273 to i64
  %275 = icmp ult i64 %274, 64
  %276 = shl i64 %271, %274
  %277 = select i1 %275, i64 %276, i64 0
  store i64 %277, ptr %269, align 8
  %278 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  %279 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %280 = load i64, ptr %279, align 8
  %281 = load i32, ptr %sr, align 4
  %282 = zext i32 %281 to i64
  %283 = icmp ult i64 %282, 64
  %284 = lshr i64 %280, %282
  %285 = select i1 %283, i64 %284, i64 0
  store i64 %285, ptr %278, align 8
  %286 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %287 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %288 = load i64, ptr %287, align 8
  %289 = load i32, ptr %sr, align 4
  %290 = sub i32 64, %289
  %291 = zext i32 %290 to i64
  %292 = icmp ult i64 %291, 64
  %293 = shl i64 %288, %291
  %294 = select i1 %292, i64 %293, i64 0
  %295 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %296 = load i64, ptr %295, align 8
  %297 = load i32, ptr %sr, align 4
  %298 = zext i32 %297 to i64
  %299 = icmp ult i64 %298, 64
  %300 = lshr i64 %296, %298
  %301 = select i1 %299, i64 %300, i64 0
  %302 = or i64 %294, %301
  store i64 %302, ptr %286, align 8
  br label %switch.done

switch.default.body:                              ; preds = %switch.case.next43
  %303 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  %304 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %305 = load i64, ptr %304, align 8
  %306 = load i32, ptr %sr, align 4
  %307 = sub i32 128, %306
  %308 = zext i32 %307 to i64
  %309 = icmp ult i64 %308, 64
  %310 = shl i64 %305, %308
  %311 = select i1 %309, i64 %310, i64 0
  store i64 %311, ptr %303, align 8
  %312 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %313 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %314 = load i64, ptr %313, align 8
  %315 = load i32, ptr %sr, align 4
  %316 = sub i32 128, %315
  %317 = zext i32 %316 to i64
  %318 = icmp ult i64 %317, 64
  %319 = shl i64 %314, %317
  %320 = select i1 %318, i64 %319, i64 0
  %321 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %322 = load i64, ptr %321, align 8
  %323 = load i32, ptr %sr, align 4
  %324 = sub i32 %323, 64
  %325 = zext i32 %324 to i64
  %326 = icmp ult i64 %325, 64
  %327 = lshr i64 %322, %325
  %328 = select i1 %326, i64 %327, i64 0
  %329 = or i64 %320, %328
  store i64 %329, ptr %312, align 8
  %330 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  store i64 0, ptr %330, align 8
  %331 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %332 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %333 = load i64, ptr %332, align 8
  %334 = load i32, ptr %sr, align 4
  %335 = sub i32 %334, 64
  %336 = zext i32 %335 to i64
  %337 = icmp ult i64 %336, 64
  %338 = lshr i64 %333, %336
  %339 = select i1 %337, i64 %338, i64 0
  store i64 %339, ptr %331, align 8
  br label %switch.done

switch.done:                                      ; preds = %switch.default.body, %switch.case.body44, %switch.case.body
  br label %if.done53

if.else45:                                        ; preds = %if.else
  %340 = getelementptr [2 x i64], ptr %d, i64 0, i64 1
  %341 = load i64, ptr %340, align 8
  %342 = call i64 @llvm.ctlz.i64(i64 %341, i1 false)
  %343 = trunc i64 %342 to i32
  %344 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %345 = load i64, ptr %344, align 8
  %346 = call i64 @llvm.ctlz.i64(i64 %345, i1 false)
  %347 = trunc i64 %346 to i32
  %348 = sub i32 %343, %347
  store i32 %348, ptr %sr, align 4
  %349 = load i32, ptr %sr, align 4
  %350 = icmp ugt i32 %349, 63
  %351 = zext i1 %350 to i8
  %352 = icmp ne i8 %351, 0
  br i1 %352, label %if.then46, label %if.done49

if.then46:                                        ; preds = %if.else45
  %353 = icmp ne ptr %2, null
  %354 = zext i1 %353 to i8
  %355 = icmp ne i8 %354, 0
  br i1 %355, label %if.then47, label %if.done48

if.then47:                                        ; preds = %if.then46
  store i128 %0, ptr %2, align 16
  br label %if.done48

if.done48:                                        ; preds = %if.then47, %if.then46
  ret i128 0

if.done49:                                        ; preds = %if.else45
  %356 = load i32, ptr %sr, align 4
  %357 = add i32 %356, 1
  store i32 %357, ptr %sr, align 4
  %358 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  store i64 0, ptr %358, align 8
  %359 = load i32, ptr %sr, align 4
  %360 = icmp eq i32 %359, 64
  %361 = zext i1 %360 to i8
  %362 = icmp ne i8 %361, 0
  br i1 %362, label %if.then50, label %if.else51

if.then50:                                        ; preds = %if.done49
  %363 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %364 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %365 = load i64, ptr %364, align 8
  store i64 %365, ptr %363, align 8
  %366 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  store i64 0, ptr %366, align 8
  %367 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %368 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %369 = load i64, ptr %368, align 8
  store i64 %369, ptr %367, align 8
  br label %if.done52

if.else51:                                        ; preds = %if.done49
  %370 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  %371 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %372 = load i64, ptr %371, align 8
  %373 = load i32, ptr %sr, align 4
  %374 = zext i32 %373 to i64
  %375 = icmp ult i64 %374, 64
  %376 = lshr i64 %372, %374
  %377 = select i1 %375, i64 %376, i64 0
  store i64 %377, ptr %370, align 8
  %378 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %379 = getelementptr [2 x i64], ptr %n, i64 0, i64 1
  %380 = load i64, ptr %379, align 8
  %381 = load i32, ptr %sr, align 4
  %382 = sub i32 64, %381
  %383 = zext i32 %382 to i64
  %384 = icmp ult i64 %383, 64
  %385 = shl i64 %380, %383
  %386 = select i1 %384, i64 %385, i64 0
  %387 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %388 = load i64, ptr %387, align 8
  %389 = load i32, ptr %sr, align 4
  %390 = zext i32 %389 to i64
  %391 = icmp ult i64 %390, 64
  %392 = lshr i64 %388, %390
  %393 = select i1 %391, i64 %392, i64 0
  %394 = or i64 %386, %393
  store i64 %394, ptr %378, align 8
  %395 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %396 = getelementptr [2 x i64], ptr %n, i64 0, i64 0
  %397 = load i64, ptr %396, align 8
  %398 = load i32, ptr %sr, align 4
  %399 = sub i32 64, %398
  %400 = zext i32 %399 to i64
  %401 = icmp ult i64 %400, 64
  %402 = shl i64 %397, %400
  %403 = select i1 %401, i64 %402, i64 0
  store i64 %403, ptr %395, align 8
  br label %if.done52

if.done52:                                        ; preds = %if.else51, %if.then50
  br label %if.done53

if.done53:                                        ; preds = %if.done52, %switch.done
  br label %if.done54

if.done54:                                        ; preds = %if.done53, %if.done35
  store i32 0, ptr %carry, align 4
  store i128 0, ptr %r_all, align 16
  br label %for.loop

for.loop:                                         ; preds = %for.post, %if.done54
  %404 = load i32, ptr %sr, align 4
  %405 = icmp ugt i32 %404, 0
  %406 = zext i1 %405 to i8
  %407 = icmp ne i8 %406, 0
  br i1 %407, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %408 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  %409 = getelementptr [2 x i64], ptr %r, i64 0, i64 1
  %410 = load i64, ptr %409, align 8
  %411 = shl i64 %410, 1
  %412 = select i1 true, i64 %411, i64 0
  %413 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %414 = load i64, ptr %413, align 8
  %415 = lshr i64 %414, 63
  %416 = select i1 true, i64 %415, i64 0
  %417 = or i64 %412, %416
  store i64 %417, ptr %408, align 8
  %418 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %419 = getelementptr [2 x i64], ptr %r, i64 0, i64 0
  %420 = load i64, ptr %419, align 8
  %421 = shl i64 %420, 1
  %422 = select i1 true, i64 %421, i64 0
  %423 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %424 = load i64, ptr %423, align 8
  %425 = lshr i64 %424, 63
  %426 = select i1 true, i64 %425, i64 0
  %427 = or i64 %422, %426
  store i64 %427, ptr %418, align 8
  %428 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %429 = getelementptr [2 x i64], ptr %q, i64 0, i64 1
  %430 = load i64, ptr %429, align 8
  %431 = shl i64 %430, 1
  %432 = select i1 true, i64 %431, i64 0
  %433 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  %434 = load i64, ptr %433, align 8
  %435 = lshr i64 %434, 63
  %436 = select i1 true, i64 %435, i64 0
  %437 = or i64 %432, %436
  store i64 %437, ptr %428, align 8
  %438 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  %439 = getelementptr [2 x i64], ptr %q, i64 0, i64 0
  %440 = load i64, ptr %439, align 8
  %441 = shl i64 %440, 1
  %442 = select i1 true, i64 %441, i64 0
  %443 = load i32, ptr %carry, align 4
  %444 = zext i32 %443 to i64
  %445 = or i64 %442, %444
  store i64 %445, ptr %438, align 8
  %446 = load [2 x i64], ptr %r, align 8
  %447 = load i128, ptr %r, align 16
  store i128 %447, ptr %r_all, align 16
  %448 = load i128, ptr %r_all, align 16
  %449 = sub i128 %1, %448
  %450 = sub i128 %449, 1
  %451 = ashr i128 %450, 127
  %452 = select i1 true, i128 %451, i128 0
  store i128 %452, ptr %s, align 16
  %453 = load i128, ptr %s, align 16
  %454 = and i128 %453, 1
  %455 = trunc i128 %454 to i32
  store i32 %455, ptr %carry, align 4
  %456 = load i128, ptr %s, align 16
  %457 = and i128 %1, %456
  %458 = load i128, ptr %r_all, align 16
  %459 = sub i128 %458, %457
  store i128 %459, ptr %r_all, align 16
  %460 = load i128, ptr %r_all, align 16
  %461 = load [2 x i64], ptr %r_all, align 8
  store [2 x i64] %461, ptr %r, align 8
  br label %for.post

for.post:                                         ; preds = %for.body
  %462 = load i32, ptr %sr, align 4
  %463 = sub i32 %462, 1
  store i32 %463, ptr %sr, align 4
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %464 = load [2 x i64], ptr %q, align 8
  %465 = load i128, ptr %q, align 16
  %466 = shl i128 %465, 1
  %467 = select i1 true, i128 %466, i128 0
  %468 = load i32, ptr %carry, align 4
  %469 = zext i32 %468 to i128
  %470 = or i128 %467, %469
  store i128 %470, ptr %q_all, align 16
  %471 = icmp ne ptr %2, null
  %472 = zext i1 %471 to i8
  %473 = icmp ne i8 %472, 0
  br i1 %473, label %if.then55, label %if.done56

if.then55:                                        ; preds = %for.done
  %474 = load i128, ptr %r_all, align 16
  store i128 %474, ptr %2, align 16
  br label %if.done56

if.done56:                                        ; preds = %if.then55, %for.done
  %475 = load i128, ptr %q_all, align 16
  ret i128 %475
}

define internal i64 @"runtime::stderr_write"({ ptr, i64 } %0, ptr noalias nonnull %1) {
decls:
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca i64, align 8
  %4 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %2, align 8
  store i64 0, ptr %3, align 8
  %5 = call i64 @"runtime::[os_specific_linux.odin]::_stderr_write"({ ptr, i64 } %0, ptr %3)
  %6 = load i64, ptr %3, align 8
  %7 = load { i64, i64 }, ptr %4, align 8
  store i64 %6, ptr %1, align 8
  ret i64 %5
}

define internal i64 @"runtime::[os_specific_linux.odin]::_stderr_write"({ ptr, i64 } %0, ptr noalias nonnull %1) {
decls:
  %2 = alloca { ptr, i64 }, align 8
  %ret = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %2, align 8
  %3 = extractvalue { ptr, i64 } %0, 0
  %4 = ptrtoint ptr %3 to i64
  %5 = extractvalue { ptr, i64 } %0, 1
  %6 = call i64 asm sideeffect "syscall", "={rax},{rax},{rdi},{rsi},{rdx},~{rcx},~{r11},~{memory}"(i64 1, i64 2, i64 %4, i64 %5)
  store i64 %6, ptr %ret, align 8
  %7 = load i64, ptr %ret, align 8
  %8 = icmp slt i64 %7, 0
  %9 = zext i1 %8 to i8
  %10 = icmp ne i8 %9, 0
  br i1 %10, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %entry
  %11 = load i64, ptr %ret, align 8
  %12 = icmp sgt i64 %11, -4096
  %13 = zext i1 %12 to i8
  %14 = icmp ne i8 %13, 0
  br i1 %14, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and
  %15 = load i64, ptr %ret, align 8
  %16 = sub i64 0, %15
  store i64 0, ptr %1, align 8
  ret i64 %16

if.done:                                          ; preds = %cmp.and, %entry
  %17 = load i64, ptr %ret, align 8
  store i64 %17, ptr %1, align 8
  ret i64 0
}

define internal { i64, i64 } @"runtime::heap_allocator"(ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %0 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store %"runtime::Allocator" { ptr @"runtime::heap_allocator_proc", ptr null }, ptr %0, align 8
  %1 = load { i64, i64 }, ptr %0, align 8
  ret { i64, i64 } %1
}

define internal i64 @"time::_now"() {
decls:
  %0 = alloca %"linux::Time_Spec", align 8
  %1 = alloca { %"linux::Time_Spec", i32 }, align 8
  %time_spec_now = alloca %"linux::Time_Spec", align 8
  %ns = alloca i64, align 8
  %2 = alloca %"time::Time", align 8
  %3 = alloca i64, align 16
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memset.inline.p0.i64(ptr %0, i8 0, i64 16, i1 false)
  %4 = call i32 @"linux::clock_gettime"(i64 0, ptr %0)
  %5 = load %"linux::Time_Spec", ptr %0, align 8
  %6 = load { %"linux::Time_Spec", i32 }, ptr %1, align 8
  store %"linux::Time_Spec" %5, ptr %time_spec_now, align 8
  %7 = getelementptr inbounds nuw %"linux::Time_Spec", ptr %time_spec_now, i32 0, i32 0
  %8 = load i64, ptr %7, align 8
  %9 = mul i64 %8, 1000000000
  %10 = getelementptr inbounds nuw %"linux::Time_Spec", ptr %time_spec_now, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %12 = add i64 %9, %11
  store i64 %12, ptr %ns, align 8
  call void @llvm.memset.inline.p0.i64(ptr %2, i8 0, i64 8, i1 false)
  store %"time::Time" zeroinitializer, ptr %2, align 8
  %13 = load i64, ptr %ns, align 8
  %14 = getelementptr inbounds nuw %"time::Time", ptr %2, i32 0, i32 0
  store i64 %13, ptr %14, align 8
  %15 = load %"time::Time", ptr %2, align 8
  store %"time::Time" %15, ptr %3, align 8
  %16 = load i64, ptr %3, align 8
  ret i64 %16
}

define internal i64 @"sync::[primitives_linux.odin]::_current_thread_id"() {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %0 = call i32 @"linux::gettid"()
  %1 = sext i32 %0 to i64
  ret i64 %1
}

define internal i64 @"sync::current_thread_id"() {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %0 = call i64 @"sync::[primitives_linux.odin]::_current_thread_id"()
  ret i64 %0
}

define internal i8 @"sync::[futex_linux.odin]::_futex_wait"(ptr %0, i32 %1) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i32, align 4
  %errno = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i32 %1, ptr %3, align 4
  %4 = call i32 @"linux::futex_wait"(ptr %0, i32 0, i32 128, i32 %1, ptr null)
  store i32 %4, ptr %errno, align 4
  %5 = load i32, ptr %errno, align 4
  %6 = icmp eq i32 %5, 110
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  %9 = load i32, ptr %errno, align 4
  switch i32 %9, label %switch.default.body [
    i32 0, label %switch.case.body
    i32 4, label %switch.case.body
    i32 11, label %switch.case.body
  ]

switch.case.body:                                 ; preds = %if.done, %if.done, %if.done
  ret i8 1

switch.default.body:                              ; preds = %if.done
  %10 = load %"runtime::Source_Code_Location", ptr @"scl$[_futex_wait449]", align 8
  call void @"runtime::panic_contextless"(%..string { ptr @"csbs$byte_world$1d6", i64 18 }, ptr @"scl$[_futex_wait449]")
  unreachable

switch.done:                                      ; No predecessors!
  unreachable
}

define internal void @"sync::[primitives_internal.odin]::_sema_post"(ptr %0, i64 %1) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  call void @"sys_valgrind::helgrind_sem_post_pre"(ptr %0)
  %4 = load ptr, ptr %2, align 8
  %5 = getelementptr inbounds nuw %"sync::Sema", ptr %4, i32 0, i32 0
  %6 = getelementptr inbounds nuw %"sync::[primitives_internal.odin]::_Sema", ptr %5, i32 0, i32 0
  call void @"sync::atomic_sema_post"(ptr %6, i64 %1)
  ret void
}

define internal i8 @"io::to_writer"({ i64, i64 } %0, ptr noalias nonnull %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca %"io::Stream", align 16
  %w = alloca %"io::Stream", align 8
  %ok = alloca i8, align 1
  %3 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %2, align 8
  %4 = load %"io::Stream", ptr %2, align 8
  call void @llvm.memset.inline.p0.i64(ptr %w, i8 0, i64 16, i1 false)
  store i8 0, ptr %ok, align 1
  store i8 1, ptr %ok, align 1
  store %"io::Stream" %4, ptr %w, align 8
  store %"io::Stream" %4, ptr %3, align 8
  %5 = load { i64, i64 }, ptr %3, align 8
  %6 = call i64 @"io::query"({ i64, i64 } %5, ptr %__.context_ptr)
  %7 = and i64 %6, 16
  %8 = icmp ne i64 %7, 0
  %9 = zext i1 %8 to i8
  store i8 %9, ptr %ok, align 1
  %10 = load %"io::Stream", ptr %w, align 8
  %11 = load i8, ptr %ok, align 1
  store %"io::Stream" %10, ptr %w, align 8
  store i8 %11, ptr %ok, align 1
  store %"io::Stream" %10, ptr %1, align 8
  ret i8 %11
}

define internal i8 @"runtime::heap_allocator_proc"(ptr %0, i8 %1, i64 %2, i64 %3, ptr %4, i64 %5, ptr %6, ptr noalias nonnull %7, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %8 = alloca ptr, align 8
  %9 = alloca i8, align 1
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca ptr, align 8
  %13 = alloca i64, align 8
  %14 = alloca { ptr, i64 }, align 8
  %15 = alloca { { ptr, i64 }, i8 }, align 8
  %16 = alloca { ptr, i64 }, align 8
  %17 = alloca { { ptr, i64 }, i8 }, align 8
  %set = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %8, align 8
  store i8 %1, ptr %9, align 1
  store i64 %2, ptr %10, align 8
  store i64 %3, ptr %11, align 8
  store ptr %4, ptr %12, align 8
  store i64 %5, ptr %13, align 8
  switch i8 %1, label %switch.done [
    i8 0, label %switch.case.body
    i8 6, label %switch.case.body
    i8 1, label %switch.case.body1
    i8 2, label %switch.case.body2
    i8 3, label %switch.case.body3
    i8 7, label %switch.case.body3
    i8 4, label %switch.case.body4
    i8 5, label %switch.case.body5
  ]

switch.case.body:                                 ; preds = %entry, %entry
  %18 = icmp eq i8 %1, 0
  %19 = zext i1 %18 to i8
  call void @llvm.memset.inline.p0.i64(ptr %14, i8 0, i64 16, i1 false)
  %20 = call i8 @"runtime::heap_allocator_proc.aligned_alloc-0"(i64 %2, i64 %3, ptr null, i64 0, i8 %19, ptr %14, ptr %__.context_ptr)
  %21 = load { ptr, i64 }, ptr %14, align 8
  %22 = load { { ptr, i64 }, i8 }, ptr %15, align 8
  store { ptr, i64 } %21, ptr %7, align 8
  ret i8 %20

switch.case.body1:                                ; preds = %entry
  call void @"runtime::heap_allocator_proc.aligned_free-1"(ptr %4, ptr %__.context_ptr)
  br label %switch.done

switch.case.body2:                                ; preds = %entry
  store { ptr, i64 } zeroinitializer, ptr %7, align 8
  ret i8 4

switch.case.body3:                                ; preds = %entry, %entry
  %23 = icmp eq i8 %1, 3
  %24 = zext i1 %23 to i8
  call void @llvm.memset.inline.p0.i64(ptr %16, i8 0, i64 16, i1 false)
  %25 = call i8 @"runtime::heap_allocator_proc.aligned_resize-2"(ptr %4, i64 %5, i64 %2, i64 %3, i8 %24, ptr %16, ptr %__.context_ptr)
  %26 = load { ptr, i64 }, ptr %16, align 8
  %27 = load { { ptr, i64 }, i8 }, ptr %17, align 8
  store { ptr, i64 } %26, ptr %7, align 8
  ret i8 %25

switch.case.body4:                                ; preds = %entry
  store ptr %4, ptr %set, align 8
  %28 = load ptr, ptr %set, align 8
  %29 = icmp ne ptr %28, null
  %30 = zext i1 %29 to i8
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %if.then, label %if.done

if.then:                                          ; preds = %switch.case.body4
  %32 = load ptr, ptr %set, align 8
  store i8 -37, ptr %32, align 1
  br label %if.done

if.done:                                          ; preds = %if.then, %switch.case.body4
  store { ptr, i64 } zeroinitializer, ptr %7, align 8
  ret i8 0

switch.case.body5:                                ; preds = %entry
  store { ptr, i64 } zeroinitializer, ptr %7, align 8
  ret i8 4

switch.done:                                      ; preds = %switch.case.body1, %entry
  store { ptr, i64 } zeroinitializer, ptr %7, align 8
  ret i8 0
}

define internal i32 @"os::[stream.odin]::_file_stream_proc"(ptr %0, i64 %1, { ptr, i64 } %2, i64 %3, i64 %4, ptr noalias nonnull %5, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %6 = alloca ptr, align 8
  %7 = alloca i64, align 8
  %8 = alloca { ptr, i64 }, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  %fd = alloca i32, align 4
  %n_int = alloca i64, align 8
  %os_err = alloca %"os::Error", align 8
  %11 = alloca %"os::Error", align 16
  %12 = alloca %"os::Error", align 16
  %13 = alloca i64, align 8
  %14 = alloca %"os::Error", align 16
  %15 = alloca { i64, %"os::Error" }, align 8
  %16 = alloca i64, align 8
  %17 = alloca %"os::Error", align 16
  %18 = alloca { i64, %"os::Error" }, align 8
  %19 = alloca i64, align 8
  %20 = alloca %"os::Error", align 16
  %21 = alloca { i64, %"os::Error" }, align 8
  %22 = alloca i64, align 8
  %23 = alloca %"os::Error", align 16
  %24 = alloca { i64, %"os::Error" }, align 8
  %25 = alloca i64, align 8
  %26 = alloca %"os::Error", align 16
  %27 = alloca { i64, %"os::Error" }, align 8
  %28 = alloca i64, align 8
  %29 = alloca %"os::Error", align 16
  %30 = alloca { i64, %"os::Error" }, align 8
  %31 = alloca i64, align 8
  %32 = alloca { i64, i32 }, align 8
  %33 = alloca i64, align 16
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %6, align 8
  store i64 %1, ptr %7, align 8
  store { ptr, i64 } %2, ptr %8, align 8
  store i64 %3, ptr %9, align 8
  store i64 %4, ptr %10, align 8
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  %34 = ptrtoint ptr %0 to i64
  %35 = trunc i64 %34 to i32
  store i32 %35, ptr %fd, align 4
  store i64 0, ptr %n_int, align 8
  call void @llvm.memset.inline.p0.i64(ptr %os_err, i8 0, i64 8, i1 false)
  switch i64 %1, label %switch.done [
    i64 0, label %switch.case.body
    i64 1, label %switch.case.body1
    i64 2, label %switch.case.body2
    i64 3, label %switch.case.body5
    i64 4, label %switch.case.body11
    i64 5, label %switch.case.body17
    i64 6, label %switch.case.body23
    i64 7, label %switch.case.body24
    i64 8, label %switch.case.body25
    i64 9, label %switch.case.body26
  ]

switch.case.body:                                 ; preds = %entry
  %36 = load i32, ptr %fd, align 4
  %37 = call i64 @"os::close"(i32 %36, ptr %__.context_ptr)
  store i64 %37, ptr %11, align 8
  %38 = load %"os::Error", ptr %11, align 4
  store %"os::Error" %38, ptr %os_err, align 4
  br label %switch.done

switch.case.body1:                                ; preds = %entry
  %39 = load i32, ptr %fd, align 4
  %40 = call i64 @"os::flush"(i32 %39, ptr %__.context_ptr)
  store i64 %40, ptr %12, align 8
  %41 = load %"os::Error", ptr %12, align 4
  store %"os::Error" %41, ptr %os_err, align 4
  br label %switch.done

switch.case.body2:                                ; preds = %entry
  %42 = extractvalue { ptr, i64 } %2, 1
  %43 = icmp eq i64 %42, 0
  %44 = zext i1 %43 to i8
  %45 = icmp ne i8 %44, 0
  br i1 %45, label %if.then, label %if.done

if.then:                                          ; preds = %switch.case.body2
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  store i64 0, ptr %5, align 8
  ret i32 0

if.done:                                          ; preds = %switch.case.body2
  %46 = load i32, ptr %fd, align 4
  store i64 0, ptr %13, align 8
  %47 = call i64 @"os::read"(i32 %46, { ptr, i64 } %2, ptr %13, ptr %__.context_ptr)
  store i64 %47, ptr %14, align 8
  %48 = load %"os::Error", ptr %14, align 4
  %49 = load i64, ptr %13, align 8
  %50 = load { i64, %"os::Error" }, ptr %15, align 8
  store i64 %49, ptr %n_int, align 8
  store %"os::Error" %48, ptr %os_err, align 4
  %51 = load i64, ptr %n_int, align 8
  store i64 %51, ptr %n, align 8
  %52 = load i64, ptr %n, align 8
  %53 = icmp eq i64 %52, 0
  %54 = zext i1 %53 to i8
  %55 = icmp ne i8 %54, 0
  br i1 %55, label %cmp.and, label %if.done4

cmp.and:                                          ; preds = %if.done
  %56 = load %"os::Error", ptr %os_err, align 4
  %57 = getelementptr inbounds nuw %"os::Error", ptr %os_err, i32 0, i32 1
  %58 = load i32, ptr %57, align 4
  %59 = icmp eq i32 %58, 0
  %60 = zext i1 %59 to i8
  %61 = icmp ne i8 %60, 0
  br i1 %61, label %if.then3, label %if.done4

if.then3:                                         ; preds = %cmp.and
  store i32 1, ptr %err, align 4
  br label %if.done4

if.done4:                                         ; preds = %if.then3, %cmp.and, %if.done
  br label %switch.done

switch.case.body5:                                ; preds = %entry
  %62 = extractvalue { ptr, i64 } %2, 1
  %63 = icmp eq i64 %62, 0
  %64 = zext i1 %63 to i8
  %65 = icmp ne i8 %64, 0
  br i1 %65, label %if.then6, label %if.done7

if.then6:                                         ; preds = %switch.case.body5
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  store i64 0, ptr %5, align 8
  ret i32 0

if.done7:                                         ; preds = %switch.case.body5
  %66 = load i32, ptr %fd, align 4
  store i64 0, ptr %16, align 8
  %67 = call i64 @"os::read_at"(i32 %66, { ptr, i64 } %2, i64 %3, ptr %16, ptr %__.context_ptr)
  store i64 %67, ptr %17, align 8
  %68 = load %"os::Error", ptr %17, align 4
  %69 = load i64, ptr %16, align 8
  %70 = load { i64, %"os::Error" }, ptr %18, align 8
  store i64 %69, ptr %n_int, align 8
  store %"os::Error" %68, ptr %os_err, align 4
  %71 = load i64, ptr %n_int, align 8
  store i64 %71, ptr %n, align 8
  %72 = load i64, ptr %n, align 8
  %73 = icmp eq i64 %72, 0
  %74 = zext i1 %73 to i8
  %75 = icmp ne i8 %74, 0
  br i1 %75, label %cmp.and8, label %if.done10

cmp.and8:                                         ; preds = %if.done7
  %76 = load %"os::Error", ptr %os_err, align 4
  %77 = getelementptr inbounds nuw %"os::Error", ptr %os_err, i32 0, i32 1
  %78 = load i32, ptr %77, align 4
  %79 = icmp eq i32 %78, 0
  %80 = zext i1 %79 to i8
  %81 = icmp ne i8 %80, 0
  br i1 %81, label %if.then9, label %if.done10

if.then9:                                         ; preds = %cmp.and8
  store i32 1, ptr %err, align 4
  br label %if.done10

if.done10:                                        ; preds = %if.then9, %cmp.and8, %if.done7
  br label %switch.done

switch.case.body11:                               ; preds = %entry
  %82 = extractvalue { ptr, i64 } %2, 1
  %83 = icmp eq i64 %82, 0
  %84 = zext i1 %83 to i8
  %85 = icmp ne i8 %84, 0
  br i1 %85, label %if.then12, label %if.done13

if.then12:                                        ; preds = %switch.case.body11
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  store i64 0, ptr %5, align 8
  ret i32 0

if.done13:                                        ; preds = %switch.case.body11
  %86 = load i32, ptr %fd, align 4
  store i64 0, ptr %19, align 8
  %87 = call i64 @"os::write"(i32 %86, { ptr, i64 } %2, ptr %19, ptr %__.context_ptr)
  store i64 %87, ptr %20, align 8
  %88 = load %"os::Error", ptr %20, align 4
  %89 = load i64, ptr %19, align 8
  %90 = load { i64, %"os::Error" }, ptr %21, align 8
  store i64 %89, ptr %n_int, align 8
  store %"os::Error" %88, ptr %os_err, align 4
  %91 = load i64, ptr %n_int, align 8
  store i64 %91, ptr %n, align 8
  %92 = load i64, ptr %n, align 8
  %93 = icmp eq i64 %92, 0
  %94 = zext i1 %93 to i8
  %95 = icmp ne i8 %94, 0
  br i1 %95, label %cmp.and14, label %if.done16

cmp.and14:                                        ; preds = %if.done13
  %96 = load %"os::Error", ptr %os_err, align 4
  %97 = getelementptr inbounds nuw %"os::Error", ptr %os_err, i32 0, i32 1
  %98 = load i32, ptr %97, align 4
  %99 = icmp eq i32 %98, 0
  %100 = zext i1 %99 to i8
  %101 = icmp ne i8 %100, 0
  br i1 %101, label %if.then15, label %if.done16

if.then15:                                        ; preds = %cmp.and14
  store i32 1, ptr %err, align 4
  br label %if.done16

if.done16:                                        ; preds = %if.then15, %cmp.and14, %if.done13
  br label %switch.done

switch.case.body17:                               ; preds = %entry
  %102 = extractvalue { ptr, i64 } %2, 1
  %103 = icmp eq i64 %102, 0
  %104 = zext i1 %103 to i8
  %105 = icmp ne i8 %104, 0
  br i1 %105, label %if.then18, label %if.done19

if.then18:                                        ; preds = %switch.case.body17
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  store i64 0, ptr %5, align 8
  ret i32 0

if.done19:                                        ; preds = %switch.case.body17
  %106 = load i32, ptr %fd, align 4
  store i64 0, ptr %22, align 8
  %107 = call i64 @"os::write_at"(i32 %106, { ptr, i64 } %2, i64 %3, ptr %22, ptr %__.context_ptr)
  store i64 %107, ptr %23, align 8
  %108 = load %"os::Error", ptr %23, align 4
  %109 = load i64, ptr %22, align 8
  %110 = load { i64, %"os::Error" }, ptr %24, align 8
  store i64 %109, ptr %n_int, align 8
  store %"os::Error" %108, ptr %os_err, align 4
  %111 = load i64, ptr %n_int, align 8
  store i64 %111, ptr %n, align 8
  %112 = load i64, ptr %n, align 8
  %113 = icmp eq i64 %112, 0
  %114 = zext i1 %113 to i8
  %115 = icmp ne i8 %114, 0
  br i1 %115, label %cmp.and20, label %if.done22

cmp.and20:                                        ; preds = %if.done19
  %116 = load %"os::Error", ptr %os_err, align 4
  %117 = getelementptr inbounds nuw %"os::Error", ptr %os_err, i32 0, i32 1
  %118 = load i32, ptr %117, align 4
  %119 = icmp eq i32 %118, 0
  %120 = zext i1 %119 to i8
  %121 = icmp ne i8 %120, 0
  br i1 %121, label %if.then21, label %if.done22

if.then21:                                        ; preds = %cmp.and20
  store i32 1, ptr %err, align 4
  br label %if.done22

if.done22:                                        ; preds = %if.then21, %cmp.and20, %if.done19
  br label %switch.done

switch.case.body23:                               ; preds = %entry
  %122 = load i32, ptr %fd, align 4
  store i64 0, ptr %25, align 8
  %123 = call i64 @"os::seek"(i32 %122, i64 %3, i64 %4, ptr %25, ptr %__.context_ptr)
  store i64 %123, ptr %26, align 8
  %124 = load %"os::Error", ptr %26, align 4
  %125 = load i64, ptr %25, align 8
  %126 = load { i64, %"os::Error" }, ptr %27, align 8
  store i64 %125, ptr %n, align 8
  store %"os::Error" %124, ptr %os_err, align 4
  br label %switch.done

switch.case.body24:                               ; preds = %entry
  %127 = load i32, ptr %fd, align 4
  store i64 0, ptr %28, align 8
  %128 = call i64 @"os::file_size"(i32 %127, ptr %28, ptr %__.context_ptr)
  store i64 %128, ptr %29, align 8
  %129 = load %"os::Error", ptr %29, align 4
  %130 = load i64, ptr %28, align 8
  %131 = load { i64, %"os::Error" }, ptr %30, align 8
  store i64 %130, ptr %n, align 8
  store %"os::Error" %129, ptr %os_err, align 4
  br label %switch.done

switch.case.body25:                               ; preds = %entry
  store i32 -1, ptr %err, align 4
  br label %switch.done

switch.case.body26:                               ; preds = %entry
  store i64 0, ptr %31, align 8
  %132 = call i32 @"io::query_utility"(i64 767, ptr %31)
  %133 = load i64, ptr %31, align 8
  %134 = load { i64, i32 }, ptr %32, align 8
  store i64 %133, ptr %n, align 8
  store i32 %132, ptr %err, align 4
  store i64 %133, ptr %5, align 8
  ret i32 %132

switch.done:                                      ; preds = %switch.case.body25, %switch.case.body24, %switch.case.body23, %if.done22, %if.done16, %if.done10, %if.done4, %switch.case.body1, %switch.case.body, %entry
  %135 = load i32, ptr %err, align 4
  %136 = icmp eq i32 %135, 0
  %137 = zext i1 %136 to i8
  %138 = icmp ne i8 %137, 0
  br i1 %138, label %cmp.and27, label %if.done29

cmp.and27:                                        ; preds = %switch.done
  %139 = load %"os::Error", ptr %os_err, align 4
  %140 = getelementptr inbounds nuw %"os::Error", ptr %os_err, i32 0, i32 1
  %141 = load i32, ptr %140, align 4
  %142 = icmp ne i32 %141, 0
  %143 = zext i1 %142 to i8
  %144 = icmp ne i8 %143, 0
  br i1 %144, label %if.then28, label %if.done29

if.then28:                                        ; preds = %cmp.and27
  %145 = load %"os::Error", ptr %os_err, align 4
  store %"os::Error" %145, ptr %33, align 4
  %146 = load i64, ptr %33, align 8
  %147 = call i32 @"os::[errors.odin]::error_to_io_error"(i64 %146, ptr %__.context_ptr)
  store i32 %147, ptr %err, align 4
  br label %if.done29

if.done29:                                        ; preds = %if.then28, %cmp.and27, %switch.done
  %148 = load i32, ptr %err, align 4
  %149 = icmp ne i32 %148, 0
  %150 = zext i1 %149 to i8
  %151 = icmp ne i8 %150, 0
  br i1 %151, label %if.then30, label %if.done31

if.then30:                                        ; preds = %if.done29
  store i64 0, ptr %n, align 8
  br label %if.done31

if.done31:                                        ; preds = %if.then30, %if.done29
  %152 = load i64, ptr %n, align 8
  %153 = load i32, ptr %err, align 4
  store i64 %152, ptr %n, align 8
  store i32 %153, ptr %err, align 4
  store i64 %152, ptr %5, align 8
  ret i32 %153
}

; Function Attrs: noreturn
define internal void @"runtime::type_assertion_trap"() #2 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.trap()
  unreachable
}

declare ptr @malloc(i64)

define internal void @"sync::[primitives_internal.odin]::_sema_wait"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = load ptr, ptr %1, align 8
  %3 = getelementptr inbounds nuw %"sync::Sema", ptr %2, i32 0, i32 0
  %4 = getelementptr inbounds nuw %"sync::[primitives_internal.odin]::_Sema", ptr %3, i32 0, i32 0
  call void @"sync::atomic_sema_wait"(ptr %4)
  call void @"sys_valgrind::helgrind_sem_wait_post"(ptr %0)
  ret void
}

declare ptr @calloc(i64, i64)

; Function Attrs: alwaysinline
define internal i64 @"linux::[helpers.odin]::syscall0"(i64 %0) #3 {
decls:
  %1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = call i64 asm sideeffect "syscall", "={rax},{rax},~{rcx},~{r11},~{memory}"(i64 %0)
  ret i64 %2
}

define internal i32 @"utf16::decode_surrogate_pair"(i32 %0, i32 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %2, align 4
  store i32 %1, ptr %3, align 4
  %4 = icmp sle i32 55296, %0
  %5 = zext i1 %4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %entry
  %7 = icmp slt i32 %0, 56320
  %8 = zext i1 %7 to i8
  %9 = icmp ne i8 %8, 0
  br i1 %9, label %cmp.and1, label %if.done

cmp.and1:                                         ; preds = %cmp.and
  %10 = icmp sle i32 56320, %1
  %11 = zext i1 %10 to i8
  %12 = icmp ne i8 %11, 0
  br i1 %12, label %cmp.and2, label %if.done

cmp.and2:                                         ; preds = %cmp.and1
  %13 = icmp slt i32 %1, 57344
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and2
  %16 = sub i32 %0, 55296
  %17 = shl i32 %16, 10
  %18 = select i1 true, i32 %17, i32 0
  %19 = sub i32 %1, 56320
  %20 = or i32 %18, %19
  %21 = add i32 %20, 65536
  ret i32 %21

if.done:                                          ; preds = %cmp.and2, %cmp.and1, %cmp.and, %entry
  ret i32 65533
}

declare i32 @sched_get_priority_max(i32)

declare void @free(ptr)

declare ptr @realloc(ptr, i64)

define internal void @"runtime::bounds_check_error"(%..string %0, i32 %1, i32 %2, i64 %3, i64 %4) {
decls:
  %5 = alloca %..string, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %5, align 8
  store i32 %1, ptr %6, align 4
  store i32 %2, ptr %7, align 4
  store i64 %3, ptr %8, align 8
  store i64 %4, ptr %9, align 8
  %10 = icmp ult i64 %3, %4
  %11 = zext i1 %10 to i8
  %12 = icmp ne i8 %11, 0
  br i1 %12, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  call void @"runtime::bounds_check_error.handle_error-0"(%..string %0, i32 %1, i32 %2, i64 %3, i64 %4)
  unreachable
}

define internal ptr @"runtime::[heap_allocator_unix.odin]::_heap_alloc"(i64 %0, i8 %1) {
decls:
  %2 = alloca i64, align 8
  %3 = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %2, align 8
  store i8 %1, ptr %3, align 1
  %4 = icmp sle i64 %0, 0
  %5 = zext i1 %4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret ptr null

if.done:                                          ; preds = %entry
  %7 = icmp ne i8 %1, 0
  br i1 %7, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.done
  %8 = call ptr @calloc(i64 1, i64 %0)
  ret ptr %8

if.else:                                          ; preds = %if.done
  %9 = call ptr @malloc(i64 %0)
  ret ptr %9

if.done2:                                         ; No predecessors!
  unreachable
}

define internal ptr @"thread::[thread_unix.odin]::_create"(ptr %0, i64 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %attrs = alloca %"posix::pthread_attr_t", align 8
  %stacksize = alloca %"posix::rlimit", align 8
  %res = alloca i32, align 4
  %res3 = alloca i32, align 4
  %4 = alloca { i64, i64 }, align 16
  %5 = alloca ptr, align 8
  %6 = alloca { ptr, i8 }, align 8
  %thread = alloca ptr, align 8
  %policy = alloca i32, align 4
  %params = alloca %"posix::sched_param", align 8
  %low = alloca i32, align 4
  %high = alloca i32, align 4
  %7 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  call void @llvm.memset.p0.i64(ptr %attrs, i8 0, i64 56, i1 false)
  %8 = call i32 @pthread_attr_init(ptr %attrs)
  %9 = icmp ne i32 %8, 0
  %10 = zext i1 %9 to i8
  %11 = icmp ne i8 %10, 0
  br i1 %11, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret ptr null

if.done:                                          ; preds = %entry
  call void @llvm.memset.inline.p0.i64(ptr %stacksize, i8 0, i64 16, i1 false)
  br label %if.init

if.init:                                          ; preds = %if.done
  %12 = call i32 @getrlimit(i32 3, ptr %stacksize)
  store i32 %12, ptr %res, align 4
  %13 = load i32, ptr %res, align 4
  %14 = icmp eq i32 %13, 0
  %15 = zext i1 %14 to i8
  %16 = icmp ne i8 %15, 0
  br i1 %16, label %cmp.and, label %if.done2

cmp.and:                                          ; preds = %if.init
  %17 = getelementptr inbounds nuw %"posix::rlimit", ptr %stacksize, i32 0, i32 0
  %18 = load i64, ptr %17, align 8
  %19 = icmp ugt i64 %18, 0
  %20 = zext i1 %19 to i8
  %21 = icmp ne i8 %20, 0
  br i1 %21, label %if.then1, label %if.done2

if.then1:                                         ; preds = %cmp.and
  %22 = getelementptr inbounds nuw %"posix::rlimit", ptr %stacksize, i32 0, i32 0
  %23 = load i64, ptr %22, align 8
  %24 = call i32 @pthread_attr_setstacksize(ptr %attrs, i64 %23)
  br label %if.done2

if.done2:                                         ; preds = %if.then1, %cmp.and, %if.init
  store i32 0, ptr %res3, align 4
  %25 = call i32 @pthread_attr_setdetachstate(ptr %attrs, i32 0)
  store i32 %25, ptr %res3, align 4
  %26 = load i32, ptr %res3, align 4
  %27 = icmp eq i32 %26, 0
  %28 = zext i1 %27 to i8
  %29 = load %"runtime::Source_Code_Location", ptr @"scl$[_create3094]", align 8
  call void @"runtime::assert"(i8 %28, %..string { ptr @"csbs$byte_world$1d9", i64 10 }, ptr @"scl$[_create3094]", ptr %__.context_ptr)
  %30 = call i32 @pthread_attr_setinheritsched(ptr %attrs, i32 1)
  store i32 %30, ptr %res3, align 4
  %31 = load i32, ptr %res3, align 4
  %32 = icmp eq i32 %31, 0
  %33 = zext i1 %32 to i8
  %34 = load %"runtime::Source_Code_Location", ptr @"scl$[_create3231]", align 8
  call void @"runtime::assert"(i8 %33, %..string { ptr @"csbs$byte_world$1d9", i64 10 }, ptr @"scl$[_create3231]", ptr %__.context_ptr)
  %35 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 0
  %36 = load %"runtime::Allocator", ptr %35, align 8
  %37 = load %"runtime::Source_Code_Location", ptr @"scl$[_create3265]", align 8
  store %"runtime::Allocator" %36, ptr %4, align 8
  %38 = load { i64, i64 }, ptr %4, align 8
  store ptr null, ptr %5, align 8
  %39 = call i8 @"runtime::new:proc(T:$thread::Thread,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(t:^thread::Thread,err:runtime::Allocator_Error)"({ i64, i64 } %38, ptr @"scl$[_create3265]", ptr %5, ptr %__.context_ptr)
  %40 = load ptr, ptr %5, align 8
  %41 = load { ptr, i8 }, ptr %6, align 8
  store ptr %40, ptr %thread, align 8
  %42 = load ptr, ptr %thread, align 8
  %43 = icmp eq ptr %42, null
  %44 = zext i1 %43 to i8
  %45 = icmp ne i8 %44, 0
  br i1 %45, label %if.then4, label %if.done5

if.then4:                                         ; preds = %if.done2
  br label %defer

defer:                                            ; preds = %if.then4
  %46 = call i32 @pthread_attr_destroy(ptr %attrs)
  ret ptr null

if.done5:                                         ; preds = %if.done2
  %47 = load ptr, ptr %thread, align 8
  %48 = getelementptr inbounds nuw %"thread::Thread", ptr %47, i32 0, i32 9
  %49 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 0
  %50 = load %"runtime::Allocator", ptr %49, align 8
  store %"runtime::Allocator" %50, ptr %48, align 8
  store i32 0, ptr %policy, align 4
  %51 = call i32 @pthread_attr_getschedpolicy(ptr %attrs, ptr %policy)
  store i32 %51, ptr %res3, align 4
  %52 = load i32, ptr %res3, align 4
  %53 = icmp eq i32 %52, 0
  %54 = zext i1 %53 to i8
  %55 = load %"runtime::Source_Code_Location", ptr @"scl$[_create3523]", align 8
  call void @"runtime::assert"(i8 %54, %..string { ptr @"csbs$byte_world$1d9", i64 10 }, ptr @"scl$[_create3523]", ptr %__.context_ptr)
  call void @llvm.memset.p0.i64(ptr %params, i8 0, i64 48, i1 false)
  %56 = call i32 @pthread_attr_getschedparam(ptr %attrs, ptr %params)
  store i32 %56, ptr %res3, align 4
  %57 = load i32, ptr %res3, align 4
  %58 = icmp eq i32 %57, 0
  %59 = zext i1 %58 to i8
  %60 = load %"runtime::Source_Code_Location", ptr @"scl$[_create3630]", align 8
  call void @"runtime::assert"(i8 %59, %..string { ptr @"csbs$byte_world$1d9", i64 10 }, ptr @"scl$[_create3630]", ptr %__.context_ptr)
  %61 = load i32, ptr %policy, align 4
  %62 = call i32 @sched_get_priority_min(i32 %61)
  store i32 %62, ptr %low, align 4
  %63 = load i32, ptr %policy, align 4
  %64 = call i32 @sched_get_priority_max(i32 %63)
  store i32 %64, ptr %high, align 4
  switch i64 %1, label %switch.done [
    i64 0, label %switch.case.body
    i64 1, label %switch.case.body6
    i64 2, label %switch.case.body7
  ]

switch.case.body:                                 ; preds = %if.done5
  br label %switch.done

switch.case.body6:                                ; preds = %if.done5
  %65 = getelementptr inbounds nuw %"posix::sched_param", ptr %params, i32 0, i32 0
  %66 = load i32, ptr %low, align 4
  %67 = add i32 %66, 1
  store i32 %67, ptr %65, align 4
  br label %switch.done

switch.case.body7:                                ; preds = %if.done5
  %68 = getelementptr inbounds nuw %"posix::sched_param", ptr %params, i32 0, i32 0
  %69 = load i32, ptr %high, align 4
  store i32 %69, ptr %68, align 4
  br label %switch.done

switch.done:                                      ; preds = %switch.case.body7, %switch.case.body6, %switch.case.body, %if.done5
  %70 = call i32 @pthread_attr_setschedparam(ptr %attrs, ptr %params)
  store i32 %70, ptr %res3, align 4
  %71 = load i32, ptr %res3, align 4
  %72 = icmp eq i32 %71, 0
  %73 = zext i1 %72 to i8
  %74 = load %"runtime::Source_Code_Location", ptr @"scl$[_create3930]", align 8
  call void @"runtime::assert"(i8 %73, %..string { ptr @"csbs$byte_world$1d9", i64 10 }, ptr @"scl$[_create3930]", ptr %__.context_ptr)
  %75 = load ptr, ptr %thread, align 8
  %76 = getelementptr inbounds nuw %"thread::Thread", ptr %75, i32 0, i32 4
  store ptr %0, ptr %76, align 8
  %77 = load ptr, ptr %thread, align 8
  %78 = getelementptr inbounds nuw %"thread::Thread", ptr %77, i32 0, i32 0
  %79 = getelementptr inbounds nuw %"thread::[thread_unix.odin]::Thread_Os_Specific", ptr %78, i32 0, i32 0
  %80 = load ptr, ptr %thread, align 8
  %81 = call i32 @pthread_create(ptr %79, ptr %attrs, ptr @"thread::[thread_unix.odin]::_create.__unix_thread_entry_proc-0", ptr %80)
  %82 = icmp ne i32 %81, 0
  %83 = zext i1 %82 to i8
  %84 = icmp ne i8 %83, 0
  br i1 %84, label %if.then8, label %if.done10

if.then8:                                         ; preds = %switch.done
  %85 = load ptr, ptr %thread, align 8
  %86 = load ptr, ptr %thread, align 8
  %87 = getelementptr inbounds nuw %"thread::Thread", ptr %86, i32 0, i32 9
  %88 = load %"runtime::Allocator", ptr %87, align 8
  %89 = load %"runtime::Source_Code_Location", ptr @"scl$[_create4079]", align 8
  store %"runtime::Allocator" %88, ptr %7, align 8
  %90 = load { i64, i64 }, ptr %7, align 8
  %91 = call i8 @"runtime::mem_free"(ptr %85, { i64, i64 } %90, ptr @"scl$[_create4079]", ptr %__.context_ptr)
  br label %defer9

defer9:                                           ; preds = %if.then8
  %92 = call i32 @pthread_attr_destroy(ptr %attrs)
  ret ptr null

if.done10:                                        ; preds = %switch.done
  %93 = load ptr, ptr %thread, align 8
  br label %defer11

defer11:                                          ; preds = %if.done10
  %94 = call i32 @pthread_attr_destroy(ptr %attrs)
  ret ptr %93
}

define internal i64 @"fmt::fprintln"(i32 %0, { ptr, i64 } %1, %..string %2, i8 %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca i32, align 4
  %5 = alloca { ptr, i64 }, align 8
  %6 = alloca %..string, align 8
  %7 = alloca i8, align 1
  %buf = alloca [1024 x i8], align 1
  %b = alloca %"bufio::Writer", align 8
  %8 = alloca %"io::Stream", align 16
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca { i64, i64 }, align 16
  %11 = alloca %"io::Stream", align 16
  %w = alloca %"io::Stream", align 8
  %12 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %4, align 4
  store { ptr, i64 } %1, ptr %5, align 8
  store %..string %2, ptr %6, align 8
  store i8 %3, ptr %7, align 1
  call void @llvm.memset.p0.i64(ptr %buf, i8 0, i64 1024, i1 false)
  call void @llvm.memset.p0.i64(ptr %b, i8 0, i64 72, i1 false)
  %13 = call { i64, i64 } @"os::stream_from_handle"(i32 %0, ptr %__.context_ptr)
  store { i64, i64 } %13, ptr %8, align 8
  %14 = load %"io::Stream", ptr %8, align 8
  %15 = load [1024 x i8], ptr %buf, align 1
  %16 = getelementptr [1024 x i8], ptr %buf, i64 0, i64 0
  %17 = getelementptr i8, ptr %16, i64 0
  %18 = getelementptr inbounds nuw { ptr, i64 }, ptr %9, i32 0, i32 0
  store ptr %17, ptr %18, align 8
  %19 = getelementptr inbounds nuw { ptr, i64 }, ptr %9, i32 0, i32 1
  store i64 1024, ptr %19, align 8
  %20 = load { ptr, i64 }, ptr %9, align 8
  store %"io::Stream" %14, ptr %10, align 8
  %21 = load { i64, i64 }, ptr %10, align 8
  call void @"bufio::writer_init_with_buf"(ptr %b, { i64, i64 } %21, { ptr, i64 } %20, ptr %__.context_ptr)
  %22 = call { i64, i64 } @"bufio::writer_to_writer"(ptr %b, ptr %__.context_ptr)
  store { i64, i64 } %22, ptr %11, align 8
  %23 = load %"io::Stream", ptr %11, align 8
  store %"io::Stream" %23, ptr %w, align 8
  %24 = load %"io::Stream", ptr %w, align 8
  store %"io::Stream" %24, ptr %12, align 8
  %25 = load { i64, i64 }, ptr %12, align 8
  %26 = call i64 @"fmt::wprintln"({ i64, i64 } %25, { ptr, i64 } %1, %..string %2, i8 %3, ptr %__.context_ptr)
  br label %defer

defer:                                            ; preds = %entry
  %27 = call i32 @"bufio::writer_flush"(ptr %b, ptr %__.context_ptr)
  ret i64 %26
}

define internal i32 @"utf16::encode_surrogate_pair"(i32 %0, ptr noalias nonnull %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca i32, align 4
  %r1 = alloca i32, align 4
  %r2 = alloca i32, align 4
  %r = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %2, align 4
  store i32 0, ptr %r1, align 4
  store i32 0, ptr %r2, align 4
  store i32 %0, ptr %r, align 4
  %3 = load i32, ptr %r, align 4
  %4 = icmp slt i32 %3, 65536
  %5 = zext i1 %4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %entry
  %7 = load i32, ptr %r, align 4
  %8 = icmp sgt i32 %7, 1114111
  %9 = zext i1 %8 to i8
  %10 = icmp ne i8 %9, 0
  br i1 %10, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %entry
  store i32 65533, ptr %r1, align 4
  store i32 65533, ptr %r2, align 4
  store i32 65533, ptr %1, align 4
  ret i32 65533

if.done:                                          ; preds = %cmp.or
  %11 = load i32, ptr %r, align 4
  %12 = sub i32 %11, 65536
  store i32 %12, ptr %r, align 4
  %13 = load i32, ptr %r, align 4
  %14 = ashr i32 %13, 10
  %15 = select i1 true, i32 %14, i32 0
  %16 = and i32 %15, 1023
  %17 = add i32 55296, %16
  %18 = load i32, ptr %r, align 4
  %19 = and i32 %18, 1023
  %20 = add i32 56320, %19
  store i32 %17, ptr %r1, align 4
  store i32 %20, ptr %r2, align 4
  store i32 %17, ptr %1, align 4
  ret i32 %20
}

declare i32 @pthread_attr_init(ptr)

define internal i8 @"strconv::is_integer_negative"(i64 %0, i8 %1, i64 %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca i64, align 8
  %5 = alloca i8, align 1
  %6 = alloca i64, align 8
  %u = alloca i64, align 8
  %neg = alloca i8, align 1
  %i = alloca i8, align 1
  %i2 = alloca i16, align 2
  %i4 = alloca i32, align 4
  %i6 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %4, align 8
  store i8 %1, ptr %5, align 1
  store i64 %2, ptr %6, align 8
  store i64 0, ptr %u, align 8
  store i8 0, ptr %neg, align 1
  store i64 %0, ptr %u, align 8
  %7 = icmp ne i8 %1, 0
  br i1 %7, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  switch i64 %2, label %switch.default.body [
    i64 8, label %switch.case.body
    i64 16, label %switch.case.body1
    i64 32, label %switch.case.body3
    i64 64, label %switch.case.body5
  ]

switch.case.body:                                 ; preds = %if.then
  %8 = load i64, ptr %u, align 8
  %9 = trunc i64 %8 to i8
  store i8 %9, ptr %i, align 1
  %10 = load i8, ptr %i, align 1
  %11 = icmp slt i8 %10, 0
  %12 = zext i1 %11 to i8
  store i8 %12, ptr %neg, align 1
  %13 = load i8, ptr %i, align 1
  %14 = sext i8 %13 to i64
  %15 = icmp slt i64 %14, 0
  %16 = sub i64 0, %14
  %17 = select i1 %15, i64 %16, i64 %14
  store i64 %17, ptr %u, align 8
  br label %switch.done

switch.case.body1:                                ; preds = %if.then
  %18 = load i64, ptr %u, align 8
  %19 = trunc i64 %18 to i16
  store i16 %19, ptr %i2, align 2
  %20 = load i16, ptr %i2, align 2
  %21 = icmp slt i16 %20, 0
  %22 = zext i1 %21 to i8
  store i8 %22, ptr %neg, align 1
  %23 = load i16, ptr %i2, align 2
  %24 = sext i16 %23 to i64
  %25 = icmp slt i64 %24, 0
  %26 = sub i64 0, %24
  %27 = select i1 %25, i64 %26, i64 %24
  store i64 %27, ptr %u, align 8
  br label %switch.done

switch.case.body3:                                ; preds = %if.then
  %28 = load i64, ptr %u, align 8
  %29 = trunc i64 %28 to i32
  store i32 %29, ptr %i4, align 4
  %30 = load i32, ptr %i4, align 4
  %31 = icmp slt i32 %30, 0
  %32 = zext i1 %31 to i8
  store i8 %32, ptr %neg, align 1
  %33 = load i32, ptr %i4, align 4
  %34 = sext i32 %33 to i64
  %35 = icmp slt i64 %34, 0
  %36 = sub i64 0, %34
  %37 = select i1 %35, i64 %36, i64 %34
  store i64 %37, ptr %u, align 8
  br label %switch.done

switch.case.body5:                                ; preds = %if.then
  %38 = load i64, ptr %u, align 8
  store i64 %38, ptr %i6, align 8
  %39 = load i64, ptr %i6, align 8
  %40 = icmp slt i64 %39, 0
  %41 = zext i1 %40 to i8
  store i8 %41, ptr %neg, align 1
  %42 = load i64, ptr %i6, align 8
  %43 = icmp slt i64 %42, 0
  %44 = sub i64 0, %42
  %45 = select i1 %43, i64 %44, i64 %42
  store i64 %45, ptr %u, align 8
  br label %switch.done

switch.default.body:                              ; preds = %if.then
  %46 = load %"runtime::Source_Code_Location", ptr @"scl$[is_integer_negative1057]", align 8
  call void @"runtime::panic"(%..string { ptr @"csbs$byte_world$1dc", i64 41 }, ptr @"scl$[is_integer_negative1057]", ptr %__.context_ptr)
  unreachable

switch.done:                                      ; preds = %switch.case.body5, %switch.case.body3, %switch.case.body1, %switch.case.body
  br label %if.done

if.done:                                          ; preds = %switch.done, %entry
  %47 = load i64, ptr %u, align 8
  %48 = load i8, ptr %neg, align 1
  store i64 %47, ptr %u, align 8
  store i8 %48, ptr %neg, align 1
  store i64 %47, ptr %3, align 8
  ret i8 %48
}

define internal void @"bufio::writer_init_with_buf"(ptr %0, { i64, i64 } %1, { ptr, i64 } %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca %"io::Stream", align 16
  %5 = alloca { ptr, i64 }, align 8
  %6 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store { i64, i64 } %1, ptr %4, align 8
  %7 = load %"io::Stream", ptr %4, align 8
  store { ptr, i64 } %2, ptr %5, align 8
  store %"io::Stream" %7, ptr %6, align 8
  %8 = load { i64, i64 }, ptr %6, align 8
  call void @"bufio::writer_reset"(ptr %0, { i64, i64 } %8, ptr %__.context_ptr)
  %9 = load ptr, ptr %3, align 8
  %10 = getelementptr inbounds nuw %"bufio::Writer", ptr %9, i32 0, i32 1
  store %"runtime::Allocator" zeroinitializer, ptr %10, align 8
  %11 = load ptr, ptr %3, align 8
  %12 = getelementptr inbounds nuw %"bufio::Writer", ptr %11, i32 0, i32 0
  store { ptr, i64 } %2, ptr %12, align 8
  ret void
}

; Function Attrs: alwaysinline
define internal i8 @"runtime::[default_temp_allocator_arena.odin]::safe_add"(i64 %0, i64 %1, ptr noalias nonnull %2) #3 {
decls:
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %z = alloca i64, align 8
  %did_overflow = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %3, align 8
  store i64 %1, ptr %4, align 8
  %5 = call { i64, i1 } @llvm.uadd.with.overflow.i64(i64 %0, i64 %1)
  %6 = extractvalue { i64, i1 } %5, 0
  %7 = extractvalue { i64, i1 } %5, 1
  store i64 %6, ptr %z, align 8
  %8 = zext i1 %7 to i8
  store i8 %8, ptr %did_overflow, align 1
  %9 = load i64, ptr %z, align 8
  %10 = load i8, ptr %did_overflow, align 1
  %11 = icmp eq i8 %10, 0
  %12 = zext i1 %11 to i8
  store i64 %9, ptr %2, align 8
  ret i8 %12
}

declare i32 @sched_get_priority_min(i32)

define internal ptr @"runtime::[heap_allocator_unix.odin]::_heap_resize"(ptr %0, i64 %1) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %4 = call ptr @realloc(ptr %0, i64 %1)
  ret ptr %4
}

define internal i32 @"io::write_u64"({ i64, i64 } %0, i64 %1, i64 %2, ptr %3, ptr noalias nonnull %4, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %5 = alloca %"io::Stream", align 16
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca ptr, align 8
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  %buf = alloca [32 x i8], align 1
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca %..string, align 8
  %s = alloca %..string, align 8
  %11 = alloca { i64, i64 }, align 16
  %12 = alloca i64, align 8
  %13 = alloca { i64, i32 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %5, align 8
  %14 = load %"io::Stream", ptr %5, align 8
  store i64 %1, ptr %6, align 8
  store i64 %2, ptr %7, align 8
  store ptr %3, ptr %8, align 8
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  call void @llvm.memset.inline.p0.i64(ptr %buf, i8 0, i64 32, i1 false)
  %15 = load [32 x i8], ptr %buf, align 1
  %16 = getelementptr [32 x i8], ptr %buf, i64 0, i64 0
  %17 = getelementptr i8, ptr %16, i64 0
  %18 = getelementptr inbounds nuw { ptr, i64 }, ptr %9, i32 0, i32 0
  store ptr %17, ptr %18, align 8
  %19 = getelementptr inbounds nuw { ptr, i64 }, ptr %9, i32 0, i32 1
  store i64 32, ptr %19, align 8
  %20 = load { ptr, i64 }, ptr %9, align 8
  %21 = load %..string, ptr @"strconv::digits", align 8
  store %..string %21, ptr %10, align 8
  %22 = call %..string @"strconv::write_bits"({ ptr, i64 } %20, i64 %1, i64 %2, i8 0, i64 64, ptr byval(%..string) %10, i8 0, ptr %__.context_ptr)
  store %..string %22, ptr %s, align 8
  %23 = load %..string, ptr %s, align 8
  store %"io::Stream" %14, ptr %11, align 8
  %24 = load { i64, i64 }, ptr %11, align 8
  store i64 0, ptr %12, align 8
  %25 = call i32 @"io::write_string"({ i64, i64 } %24, %..string %23, ptr %3, ptr %12, ptr %__.context_ptr)
  %26 = load i64, ptr %12, align 8
  %27 = load { i64, i32 }, ptr %13, align 8
  store i64 %26, ptr %n, align 8
  store i32 %25, ptr %err, align 4
  store i64 %26, ptr %4, align 8
  ret i32 %25
}

declare i32 @pthread_attr_destroy(ptr)

define internal i64 @"utf16::encode"({ ptr, i64 } %0, { ptr, i64 } %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca { ptr, i64 }, align 8
  %n = alloca i64, align 8
  %m = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %r = alloca i32, align 4
  %6 = alloca i32, align 4
  %7 = alloca { i32, i32 }, align 4
  %r1 = alloca i32, align 4
  %r2 = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %2, align 8
  store { ptr, i64 } %1, ptr %3, align 8
  %8 = extractvalue { ptr, i64 } %0, 1
  store i64 0, ptr %n, align 8
  store i64 %8, ptr %m, align 8
  %9 = extractvalue { ptr, i64 } %1, 1
  store i64 %9, ptr %4, align 8
  store i64 -1, ptr %5, align 8
  br label %for.index.loop

for.index.loop:                                   ; preds = %switch.done, %entry
  %10 = load i64, ptr %5, align 8
  %11 = add i64 %10, 1
  store i64 %11, ptr %5, align 8
  %12 = load i64, ptr %4, align 8
  %13 = icmp slt i64 %11, %12
  br i1 %13, label %for.index.body, label %for.index.done

for.index.body:                                   ; preds = %for.index.loop
  %14 = load i64, ptr %5, align 8
  %15 = extractvalue { ptr, i64 } %1, 0
  %16 = getelementptr i32, ptr %15, i64 %14
  %17 = load i32, ptr %16, align 4
  store i32 %17, ptr %r, align 4
  %18 = load i32, ptr %r, align 4
  %19 = icmp sle i32 0, %18
  %20 = icmp slt i32 %18, 55296
  %21 = zext i1 %19 to i8
  %22 = zext i1 %20 to i8
  %23 = and i8 %21, %22
  %24 = trunc i8 %23 to i1
  br i1 %24, label %switch.case.body, label %switch.case.next

switch.case.next:                                 ; preds = %for.index.body
  %25 = icmp sle i32 57344, %18
  %26 = icmp slt i32 %18, 65536
  %27 = zext i1 %25 to i8
  %28 = zext i1 %26 to i8
  %29 = and i8 %27, %28
  %30 = trunc i8 %29 to i1
  br i1 %30, label %switch.case.body, label %switch.case.next1

switch.case.next1:                                ; preds = %switch.case.next
  %31 = icmp sle i32 65536, %18
  %32 = icmp sle i32 %18, 1114111
  %33 = zext i1 %31 to i8
  %34 = zext i1 %32 to i8
  %35 = and i8 %33, %34
  %36 = trunc i8 %35 to i1
  br i1 %36, label %switch.case.body3, label %switch.case.next2

switch.case.body:                                 ; preds = %switch.case.next, %for.index.body
  %37 = load i64, ptr %m, align 8
  %38 = add i64 %37, 1
  %39 = load i64, ptr %n, align 8
  %40 = icmp slt i64 %38, %39
  %41 = zext i1 %40 to i8
  %42 = icmp ne i8 %41, 0
  br i1 %42, label %if.then, label %if.done

if.then:                                          ; preds = %switch.case.body
  br label %for.index.done

unreachable:                                      ; No predecessors!
  br label %if.done

if.done:                                          ; preds = %unreachable, %switch.case.body
  %43 = extractvalue { ptr, i64 } %0, 0
  %44 = load i64, ptr %n, align 8
  %45 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1df", i64 43 }, i32 42, i32 6, i64 %44, i64 %45)
  %46 = getelementptr i16, ptr %43, i64 %44
  %47 = load i32, ptr %r, align 4
  %48 = trunc i32 %47 to i16
  store i16 %48, ptr %46, align 2
  %49 = load i64, ptr %n, align 8
  %50 = add i64 %49, 1
  store i64 %50, ptr %n, align 8
  br label %switch.done

switch.case.next2:                                ; preds = %switch.case.next1
  br label %switch.default.body

switch.case.body3:                                ; preds = %switch.case.next1
  %51 = load i64, ptr %m, align 8
  %52 = add i64 %51, 2
  %53 = load i64, ptr %n, align 8
  %54 = icmp slt i64 %52, %53
  %55 = zext i1 %54 to i8
  %56 = icmp ne i8 %55, 0
  br i1 %56, label %if.then4, label %if.done6

if.then4:                                         ; preds = %switch.case.body3
  br label %for.index.done

unreachable5:                                     ; No predecessors!
  br label %if.done6

if.done6:                                         ; preds = %unreachable5, %switch.case.body3
  %57 = load i32, ptr %r, align 4
  store i32 0, ptr %6, align 4
  %58 = call i32 @"utf16::encode_surrogate_pair"(i32 %57, ptr %6, ptr %__.context_ptr)
  %59 = load i32, ptr %6, align 4
  %60 = load { i32, i32 }, ptr %7, align 4
  store i32 %59, ptr %r1, align 4
  store i32 %58, ptr %r2, align 4
  %61 = extractvalue { ptr, i64 } %0, 0
  %62 = load i64, ptr %n, align 8
  %63 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1df", i64 43 }, i32 48, i32 6, i64 %62, i64 %63)
  %64 = getelementptr i16, ptr %61, i64 %62
  %65 = load i32, ptr %r1, align 4
  %66 = trunc i32 %65 to i16
  store i16 %66, ptr %64, align 2
  %67 = extractvalue { ptr, i64 } %0, 0
  %68 = load i64, ptr %n, align 8
  %69 = add i64 %68, 1
  %70 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1df", i64 43 }, i32 49, i32 6, i64 %69, i64 %70)
  %71 = getelementptr i16, ptr %67, i64 %69
  %72 = load i32, ptr %r2, align 4
  %73 = trunc i32 %72 to i16
  store i16 %73, ptr %71, align 2
  %74 = load i64, ptr %n, align 8
  %75 = add i64 %74, 2
  store i64 %75, ptr %n, align 8
  br label %switch.done

switch.default.body:                              ; preds = %switch.case.next2
  %76 = load i64, ptr %m, align 8
  %77 = add i64 %76, 1
  %78 = load i64, ptr %n, align 8
  %79 = icmp slt i64 %77, %78
  %80 = zext i1 %79 to i8
  %81 = icmp ne i8 %80, 0
  br i1 %81, label %if.then7, label %if.done9

if.then7:                                         ; preds = %switch.default.body
  br label %for.index.done

unreachable8:                                     ; No predecessors!
  br label %if.done9

if.done9:                                         ; preds = %unreachable8, %switch.default.body
  %82 = extractvalue { ptr, i64 } %0, 0
  %83 = load i64, ptr %n, align 8
  %84 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1df", i64 43 }, i32 54, i32 6, i64 %83, i64 %84)
  %85 = getelementptr i16, ptr %82, i64 %83
  store i16 -3, ptr %85, align 2
  %86 = load i64, ptr %n, align 8
  %87 = add i64 %86, 1
  store i64 %87, ptr %n, align 8
  br label %switch.done

switch.done:                                      ; preds = %if.done9, %if.done6, %if.done
  br label %for.index.loop

for.index.done:                                   ; preds = %if.then7, %if.then4, %if.then, %for.index.loop
  %88 = load i64, ptr %n, align 8
  ret i64 %88
}

; Function Attrs: alwaysinline
define internal { ptr, i64 } @"runtime::[internal.odin]::byte_slice"(ptr %0, i64 %1) #3 {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %4 = alloca ptr, align 8
  %5 = alloca { ptr, i64 }, align 8
  %6 = alloca { ptr, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  store ptr %0, ptr %4, align 8
  %7 = load ptr, ptr %4, align 8
  %8 = icmp sgt i64 %1, 0
  %9 = select i1 %8, i64 %1, i64 0
  %10 = getelementptr i8, ptr %7, i64 0
  %11 = sub i64 %9, 0
  %12 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 0
  %13 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 1
  store ptr %10, ptr %12, align 8
  store i64 %11, ptr %13, align 8
  %14 = load { ptr, i64 }, ptr %5, align 8
  store { ptr, i64 } %14, ptr %6, align 8
  %15 = load { ptr, i64 }, ptr %6, align 8
  ret { ptr, i64 } %15
}

define internal i8 @"runtime::memory_block_alloc"({ i64, i64 } %0, i64 %1, i64 %2, ptr %3, ptr noalias nonnull %4, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %5 = alloca %"runtime::Allocator", align 16
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %block = alloca ptr, align 8
  %err = alloca i8, align 1
  %total_size = alloca i64, align 8
  %base_offset = alloca i64, align 8
  %min_alignment = alloca i64, align 8
  %8 = alloca { i64, i64 }, align 16
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca { { ptr, i64 }, i8 }, align 8
  %data = alloca { ptr, i64 }, align 8
  %11 = alloca ptr, align 8
  %end = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %5, align 8
  %12 = load %"runtime::Allocator", ptr %5, align 8
  store i64 %1, ptr %6, align 8
  store i64 %2, ptr %7, align 8
  store ptr null, ptr %block, align 8
  store i8 0, ptr %err, align 1
  %13 = icmp ugt i64 %2, 48
  %14 = select i1 %13, i64 %2, i64 48
  %15 = add i64 %1, %14
  store i64 %15, ptr %total_size, align 8
  %16 = icmp ugt i64 %2, 48
  %17 = select i1 %16, i64 %2, i64 48
  store i64 %17, ptr %base_offset, align 8
  %18 = icmp sgt i64 16, %2
  %19 = select i1 %18, i64 16, i64 %2
  store i64 %19, ptr %min_alignment, align 8
  %20 = load i64, ptr %total_size, align 8
  %21 = load i64, ptr %min_alignment, align 8
  %22 = load %"runtime::Source_Code_Location", ptr %3, align 8
  store %"runtime::Allocator" %12, ptr %8, align 8
  %23 = load { i64, i64 }, ptr %8, align 8
  call void @llvm.memset.inline.p0.i64(ptr %9, i8 0, i64 16, i1 false)
  %24 = call i8 @"runtime::mem_alloc"(i64 %20, i64 %21, { i64, i64 } %23, ptr %3, ptr %9, ptr %__.context_ptr)
  %25 = load { ptr, i64 }, ptr %9, align 8
  %26 = load { { ptr, i64 }, i8 }, ptr %10, align 8
  %27 = icmp eq i8 %24, 0
  br i1 %27, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %entry
  store i8 %24, ptr %err, align 1
  %28 = load ptr, ptr %block, align 8
  %29 = load i8, ptr %err, align 1
  store ptr %28, ptr %block, align 8
  store i8 %29, ptr %err, align 1
  store ptr %28, ptr %4, align 8
  ret i8 %29

or_return.continue:                               ; preds = %entry
  store { ptr, i64 } %25, ptr %data, align 8
  %30 = load { ptr, i64 }, ptr %data, align 8
  %31 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %32 = load ptr, ptr %31, align 8
  store ptr %32, ptr %block, align 8
  %33 = load { ptr, i64 }, ptr %data, align 8
  %34 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %35 = load ptr, ptr %34, align 8
  %36 = load ptr, ptr %34, align 8
  %37 = load { ptr, i64 }, ptr %data, align 8
  %38 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 1
  %39 = load i64, ptr %38, align 8
  %40 = getelementptr i8, ptr %36, i64 %39
  store ptr %40, ptr %11, align 8
  %41 = load ptr, ptr %11, align 8
  %42 = ptrtoint ptr %41 to i64
  store i64 %42, ptr %end, align 8
  %43 = load ptr, ptr %block, align 8
  %44 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %43, i32 0, i32 1
  store %"runtime::Allocator" %12, ptr %44, align 8
  %45 = load ptr, ptr %block, align 8
  %46 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %45, i32 0, i32 2
  %47 = load ptr, ptr %block, align 8
  %48 = ptrtoint ptr %47 to i64
  %49 = load i64, ptr %base_offset, align 8
  %50 = add i64 %48, %49
  %51 = inttoptr i64 %50 to ptr
  store ptr %51, ptr %46, align 8
  %52 = load ptr, ptr %block, align 8
  %53 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %52, i32 0, i32 4
  %54 = load i64, ptr %end, align 8
  %55 = load ptr, ptr %block, align 8
  %56 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %55, i32 0, i32 2
  %57 = load ptr, ptr %56, align 8
  %58 = ptrtoint ptr %57 to i64
  %59 = sub i64 %54, %58
  store i64 %59, ptr %53, align 8
  %60 = load ptr, ptr %block, align 8
  %61 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %60, i32 0, i32 3
  %62 = load i64, ptr %61, align 8
  %63 = icmp eq i64 %62, 0
  %64 = zext i1 %63 to i8
  %65 = load %"runtime::Source_Code_Location", ptr @"scl$[memory_block_alloc1589]", align 8
  call void @"runtime::assert"(i8 %64, %..string { ptr @"csbs$byte_world$1e0", i64 15 }, ptr @"scl$[memory_block_alloc1589]", ptr %__.context_ptr)
  %66 = load ptr, ptr %block, align 8
  %67 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %66, i32 0, i32 0
  %68 = load ptr, ptr %67, align 8
  %69 = icmp eq ptr %68, null
  %70 = zext i1 %69 to i8
  %71 = load %"runtime::Source_Code_Location", ptr @"scl$[memory_block_alloc1614]", align 8
  call void @"runtime::assert"(i8 %70, %..string { ptr @"csbs$byte_world$1e3", i64 17 }, ptr @"scl$[memory_block_alloc1614]", ptr %__.context_ptr)
  %72 = load ptr, ptr %block, align 8
  %73 = load i8, ptr %err, align 1
  store ptr %72, ptr %block, align 8
  store i8 %73, ptr %err, align 1
  store ptr %72, ptr %4, align 8
  ret i8 %73
}

define internal void @"bufio::writer_destroy"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr inbounds nuw %"bufio::Writer", ptr %3, i32 0, i32 0
  %5 = load { ptr, i64 }, ptr %4, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr inbounds nuw %"bufio::Writer", ptr %6, i32 0, i32 1
  %8 = load %"runtime::Allocator", ptr %7, align 8
  %9 = load %"runtime::Source_Code_Location", ptr @"scl$[writer_destroy948]", align 8
  store %"runtime::Allocator" %8, ptr %2, align 8
  %10 = load { i64, i64 }, ptr %2, align 8
  %11 = call i8 @"runtime::delete_slice:proc(array:[]u8,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"({ ptr, i64 } %5, { i64, i64 } %10, ptr @"scl$[writer_destroy948]", ptr %__.context_ptr)
  call void @llvm.memset.p0.i64(ptr %0, i8 0, i64 72, i1 false)
  ret void
}

define internal void @"runtime::run_thread_local_cleaners"(ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %0 = alloca i64, align 8
  %1 = alloca i64, align 8
  %p = alloca %"runtime::Thread_Local_Cleaner", align 8
  %2 = alloca [8 x i8], align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 8, ptr %0, align 8
  store i64 -1, ptr %1, align 8
  br label %for.index.loop

for.index.loop:                                   ; preds = %typeswitch.done, %entry
  %3 = load i64, ptr %1, align 8
  %4 = add i64 %3, 1
  store i64 %4, ptr %1, align 8
  %5 = icmp slt i64 %4, 8
  br i1 %5, label %for.index.body, label %for.index.done

for.index.body:                                   ; preds = %for.index.loop
  %6 = load i64, ptr %1, align 8
  %7 = getelementptr [8 x %"runtime::Thread_Local_Cleaner"], ptr @"runtime::[thread_management.odin]::thread_local_cleaners", i64 0, i64 %6
  %8 = load %"runtime::Thread_Local_Cleaner", ptr %7, align 8
  store %"runtime::Thread_Local_Cleaner" %8, ptr %p, align 8
  %9 = load %"runtime::Thread_Local_Cleaner", ptr %p, align 8
  %10 = getelementptr inbounds nuw %"runtime::Thread_Local_Cleaner", ptr %p, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %12 = icmp eq i64 %11, 0
  %13 = zext i1 %12 to i8
  %14 = icmp ne i8 %13, 0
  br i1 %14, label %if.then, label %if.done

if.then:                                          ; preds = %for.index.body
  br label %for.index.done

unreachable:                                      ; No predecessors!
  br label %if.done

if.done:                                          ; preds = %unreachable, %for.index.body
  %15 = load %"runtime::Thread_Local_Cleaner", ptr %p, align 8
  %16 = getelementptr inbounds nuw %"runtime::Thread_Local_Cleaner", ptr %p, i32 0, i32 1
  %17 = load i64, ptr %16, align 8
  switch i64 %17, label %typeswitch.done [
    i64 1, label %typeswitch.body
    i64 2, label %typeswitch.body1
  ]

typeswitch.body:                                  ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %p, i64 8, i1 false)
  %18 = load ptr, ptr %2, align 8
  call void %18(ptr %__.context_ptr)
  br label %typeswitch.done

typeswitch.body1:                                 ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %p, i64 8, i1 false)
  %19 = load ptr, ptr %2, align 8
  call void %19()
  br label %typeswitch.done

typeswitch.done:                                  ; preds = %typeswitch.body1, %typeswitch.body, %if.done
  br label %for.index.loop

for.index.done:                                   ; preds = %if.then, %for.index.loop
  ret void
}

; Function Attrs: alwaysinline
define internal i8 @"runtime::is_power_of_two_int"(i64 %0) #3 {
decls:
  %1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = icmp sle i64 %0, 0
  %3 = zext i1 %2 to i8
  %4 = icmp ne i8 %3, 0
  br i1 %4, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  %5 = sub i64 %0, 1
  %6 = and i64 %0, %5
  %7 = icmp eq i64 %6, 0
  %8 = zext i1 %7 to i8
  ret i8 %8
}

define internal { ptr, i64 } @"strconv::generic_ftoa"({ ptr, i64 } %0, double %1, i8 %2, i64 %3, i64 %4, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %5 = alloca { ptr, i64 }, align 8
  %6 = alloca double, align 8
  %7 = alloca i8, align 1
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %bits = alloca i64, align 8
  %flt = alloca ptr, align 8
  %10 = alloca i16, align 16
  %11 = alloca i32, align 16
  %12 = alloca i64, align 16
  %neg = alloca i8, align 1
  %exp = alloca i64, align 8
  %mant = alloca i64, align 8
  %s = alloca %..string, align 8
  %n = alloca i64, align 8
  %13 = alloca { ptr, i64 }, align 8
  %14 = alloca { ptr, i64 }, align 8
  %d_ = alloca %"strconv_decimal::Decimal", align 8
  %d = alloca ptr, align 8
  %digs = alloca %"strconv::Decimal_Slice", align 8
  %prec = alloca i64, align 8
  %shortest = alloca i8, align 1
  %15 = alloca %"strconv::Decimal_Slice", align 8
  %16 = alloca { ptr, i64 }, align 8
  %17 = alloca %"strconv::Decimal_Slice", align 8
  %18 = alloca { ptr, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %5, align 8
  store double %1, ptr %6, align 8
  store i8 %2, ptr %7, align 1
  store i64 %3, ptr %8, align 8
  store i64 %4, ptr %9, align 8
  store i64 0, ptr %bits, align 8
  store ptr null, ptr %flt, align 8
  switch i64 %4, label %switch.default.body [
    i64 16, label %switch.case.body
    i64 32, label %switch.case.body1
    i64 64, label %switch.case.body2
  ]

switch.case.body:                                 ; preds = %entry
  %19 = fptrunc double %1 to half
  store half %19, ptr %10, align 2
  %20 = load i16, ptr %10, align 2
  %21 = zext i16 %20 to i64
  store i64 %21, ptr %bits, align 8
  store ptr @"strconv::_f16_info", ptr %flt, align 8
  br label %switch.done

switch.case.body1:                                ; preds = %entry
  %22 = fptrunc double %1 to float
  store float %22, ptr %11, align 4
  %23 = load i32, ptr %11, align 4
  %24 = zext i32 %23 to i64
  store i64 %24, ptr %bits, align 8
  store ptr @"strconv::_f32_info", ptr %flt, align 8
  br label %switch.done

switch.case.body2:                                ; preds = %entry
  store double %1, ptr %12, align 8
  %25 = load i64, ptr %12, align 8
  store i64 %25, ptr %bits, align 8
  store ptr @"strconv::_f64_info", ptr %flt, align 8
  br label %switch.done

switch.default.body:                              ; preds = %entry
  %26 = load %"runtime::Source_Code_Location", ptr @"scl$[generic_ftoa1322]", align 8
  call void @"runtime::panic"(%..string { ptr @"csbs$byte_world$1e6", i64 25 }, ptr @"scl$[generic_ftoa1322]", ptr %__.context_ptr)
  unreachable

switch.done:                                      ; preds = %switch.case.body2, %switch.case.body1, %switch.case.body
  %27 = load i64, ptr %bits, align 8
  %28 = load ptr, ptr %flt, align 8
  %29 = getelementptr inbounds nuw %"strconv::Float_Info", ptr %28, i32 0, i32 1
  %30 = load i64, ptr %29, align 8
  %31 = load ptr, ptr %flt, align 8
  %32 = getelementptr inbounds nuw %"strconv::Float_Info", ptr %31, i32 0, i32 0
  %33 = load i64, ptr %32, align 8
  %34 = add i64 %30, %33
  %35 = icmp ult i64 %34, 64
  %36 = lshr i64 %27, %34
  %37 = select i1 %35, i64 %36, i64 0
  %38 = icmp ne i64 %37, 0
  %39 = zext i1 %38 to i8
  store i8 %39, ptr %neg, align 1
  %40 = load i64, ptr %bits, align 8
  %41 = load ptr, ptr %flt, align 8
  %42 = getelementptr inbounds nuw %"strconv::Float_Info", ptr %41, i32 0, i32 0
  %43 = load i64, ptr %42, align 8
  %44 = icmp ult i64 %43, 64
  %45 = lshr i64 %40, %43
  %46 = select i1 %44, i64 %45, i64 0
  %47 = load ptr, ptr %flt, align 8
  %48 = getelementptr inbounds nuw %"strconv::Float_Info", ptr %47, i32 0, i32 1
  %49 = load i64, ptr %48, align 8
  %50 = icmp ult i64 %49, 64
  %51 = shl i64 1, %49
  %52 = select i1 %50, i64 %51, i64 0
  %53 = sub i64 %52, 1
  %54 = and i64 %46, %53
  store i64 %54, ptr %exp, align 8
  %55 = load i64, ptr %bits, align 8
  %56 = load ptr, ptr %flt, align 8
  %57 = getelementptr inbounds nuw %"strconv::Float_Info", ptr %56, i32 0, i32 0
  %58 = load i64, ptr %57, align 8
  %59 = icmp ult i64 %58, 64
  %60 = shl i64 1, %58
  %61 = select i1 %59, i64 %60, i64 0
  %62 = sub i64 %61, 1
  %63 = and i64 %55, %62
  store i64 %63, ptr %mant, align 8
  %64 = load i64, ptr %exp, align 8
  %65 = load ptr, ptr %flt, align 8
  %66 = getelementptr inbounds nuw %"strconv::Float_Info", ptr %65, i32 0, i32 1
  %67 = load i64, ptr %66, align 8
  %68 = icmp ult i64 %67, 64
  %69 = shl i64 1, %67
  %70 = select i1 %68, i64 %69, i64 0
  %71 = sub i64 %70, 1
  %72 = icmp eq i64 %64, %71
  br i1 %72, label %switch.case.body3, label %switch.case.next

switch.case.next:                                 ; preds = %switch.done
  %73 = icmp eq i64 %64, 0
  br i1 %73, label %switch.case.body8, label %switch.case.next7

switch.case.body3:                                ; preds = %switch.done
  call void @llvm.memset.inline.p0.i64(ptr %s, i8 0, i64 16, i1 false)
  %74 = load i64, ptr %mant, align 8
  %75 = icmp ne i64 %74, 0
  %76 = zext i1 %75 to i8
  %77 = icmp ne i8 %76, 0
  br i1 %77, label %if.then, label %if.else

if.then:                                          ; preds = %switch.case.body3
  store %..string { ptr @"csbs$byte_world$1e9", i64 3 }, ptr %s, align 8
  br label %if.done6

if.else:                                          ; preds = %switch.case.body3
  %78 = load i8, ptr %neg, align 1
  %79 = icmp ne i8 %78, 0
  br i1 %79, label %if.then4, label %if.else5

if.then4:                                         ; preds = %if.else
  store %..string { ptr @"csbs$byte_world$1ea", i64 4 }, ptr %s, align 8
  br label %if.done

if.else5:                                         ; preds = %if.else
  store %..string { ptr @"csbs$byte_world$1eb", i64 4 }, ptr %s, align 8
  br label %if.done

if.done:                                          ; preds = %if.else5, %if.then4
  br label %if.done6

if.done6:                                         ; preds = %if.done, %if.then
  %80 = load %..string, ptr %s, align 8
  %81 = call i64 @"runtime::copy_from_string:proc\22contextless\22(dst:[]u8,src:string)->(:int)"({ ptr, i64 } %0, %..string %80)
  store i64 %81, ptr %n, align 8
  %82 = load { ptr, i64 }, ptr %5, align 8
  %83 = load i64, ptr %n, align 8
  %84 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 1
  %85 = load i64, ptr %84, align 8
  call void @"runtime::slice_expr_error_hi"(%..string { ptr @"csbs$byte_world$1e7", i64 45 }, i32 78, i32 13, i64 %83, i64 %85)
  %86 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 0
  %87 = load ptr, ptr %86, align 8
  %88 = getelementptr i8, ptr %87, i64 0
  %89 = sub i64 %83, 0
  %90 = getelementptr inbounds nuw { ptr, i64 }, ptr %13, i32 0, i32 0
  store ptr %88, ptr %90, align 8
  %91 = getelementptr inbounds nuw { ptr, i64 }, ptr %13, i32 0, i32 1
  store i64 %89, ptr %91, align 8
  %92 = load { ptr, i64 }, ptr %13, align 8
  store { ptr, i64 } %92, ptr %14, align 8
  %93 = load { ptr, i64 }, ptr %14, align 8
  ret { ptr, i64 } %93

switch.case.next7:                                ; preds = %switch.case.next
  br label %switch.default.body9

switch.case.body8:                                ; preds = %switch.case.next
  %94 = load i64, ptr %exp, align 8
  %95 = add i64 %94, 1
  store i64 %95, ptr %exp, align 8
  br label %switch.done10

switch.default.body9:                             ; preds = %switch.case.next7
  %96 = load ptr, ptr %flt, align 8
  %97 = getelementptr inbounds nuw %"strconv::Float_Info", ptr %96, i32 0, i32 0
  %98 = load i64, ptr %97, align 8
  %99 = icmp ult i64 %98, 64
  %100 = shl i64 1, %98
  %101 = select i1 %99, i64 %100, i64 0
  %102 = load i64, ptr %mant, align 8
  %103 = or i64 %102, %101
  store i64 %103, ptr %mant, align 8
  br label %switch.done10

switch.done10:                                    ; preds = %switch.default.body9, %switch.case.body8
  %104 = load ptr, ptr %flt, align 8
  %105 = getelementptr inbounds nuw %"strconv::Float_Info", ptr %104, i32 0, i32 2
  %106 = load i64, ptr %105, align 8
  %107 = load i64, ptr %exp, align 8
  %108 = add i64 %107, %106
  store i64 %108, ptr %exp, align 8
  call void @llvm.memset.p0.i64(ptr %d_, i8 0, i64 408, i1 false)
  store ptr %d_, ptr %d, align 8
  %109 = load ptr, ptr %d, align 8
  %110 = load i64, ptr %mant, align 8
  call void @"strconv_decimal::assign"(ptr %109, i64 %110, ptr %__.context_ptr)
  %111 = load ptr, ptr %d, align 8
  %112 = load i64, ptr %exp, align 8
  %113 = load ptr, ptr %flt, align 8
  %114 = getelementptr inbounds nuw %"strconv::Float_Info", ptr %113, i32 0, i32 0
  %115 = load i64, ptr %114, align 8
  %116 = sub i64 %112, %115
  call void @"strconv_decimal::shift"(ptr %111, i64 %116, ptr %__.context_ptr)
  call void @llvm.memset.p0.i64(ptr %digs, i8 0, i64 40, i1 false)
  store i64 %3, ptr %prec, align 8
  %117 = load i64, ptr %prec, align 8
  %118 = icmp slt i64 %117, 0
  %119 = zext i1 %118 to i8
  store i8 %119, ptr %shortest, align 1
  %120 = load i8, ptr %shortest, align 1
  %121 = icmp ne i8 %120, 0
  br i1 %121, label %if.then11, label %if.else16

if.then11:                                        ; preds = %switch.done10
  %122 = load ptr, ptr %d, align 8
  %123 = load i64, ptr %mant, align 8
  %124 = load i64, ptr %exp, align 8
  %125 = load ptr, ptr %flt, align 8
  call void @"strconv::round_shortest"(ptr %122, i64 %123, i64 %124, ptr %125, ptr %__.context_ptr)
  call void @llvm.memset.p0.i64(ptr %15, i8 0, i64 40, i1 false)
  call void @llvm.memset.p0.i64(ptr %15, i8 0, i64 40, i1 false)
  %126 = load ptr, ptr %d, align 8
  %127 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %126, i32 0, i32 0
  %128 = load [384 x i8], ptr %127, align 1
  %129 = getelementptr [384 x i8], ptr %127, i64 0, i64 0
  %130 = getelementptr i8, ptr %129, i64 0
  %131 = getelementptr inbounds nuw { ptr, i64 }, ptr %16, i32 0, i32 0
  store ptr %130, ptr %131, align 8
  %132 = getelementptr inbounds nuw { ptr, i64 }, ptr %16, i32 0, i32 1
  store i64 384, ptr %132, align 8
  %133 = load { ptr, i64 }, ptr %16, align 8
  %134 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %15, i32 0, i32 0
  store { ptr, i64 } %133, ptr %134, align 8
  %135 = load ptr, ptr %d, align 8
  %136 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %135, i32 0, i32 1
  %137 = load i64, ptr %136, align 8
  %138 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %15, i32 0, i32 1
  store i64 %137, ptr %138, align 8
  %139 = load ptr, ptr %d, align 8
  %140 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %139, i32 0, i32 2
  %141 = load i64, ptr %140, align 8
  %142 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %15, i32 0, i32 2
  store i64 %141, ptr %142, align 8
  %143 = load %"strconv::Decimal_Slice", ptr %15, align 8
  store %"strconv::Decimal_Slice" %143, ptr %digs, align 8
  switch i8 %2, label %switch.done15 [
    i8 101, label %switch.case.body12
    i8 69, label %switch.case.body12
    i8 102, label %switch.case.body13
    i8 70, label %switch.case.body13
    i8 103, label %switch.case.body14
    i8 71, label %switch.case.body14
  ]

switch.case.body12:                               ; preds = %if.then11, %if.then11
  %144 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %digs, i32 0, i32 1
  %145 = load i64, ptr %144, align 8
  %146 = sub i64 %145, 1
  store i64 %146, ptr %prec, align 8
  br label %switch.done15

switch.case.body13:                               ; preds = %if.then11, %if.then11
  %147 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %digs, i32 0, i32 1
  %148 = load i64, ptr %147, align 8
  %149 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %digs, i32 0, i32 2
  %150 = load i64, ptr %149, align 8
  %151 = sub i64 %148, %150
  %152 = icmp sgt i64 %151, 0
  %153 = select i1 %152, i64 %151, i64 0
  store i64 %153, ptr %prec, align 8
  br label %switch.done15

switch.case.body14:                               ; preds = %if.then11, %if.then11
  %154 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %digs, i32 0, i32 1
  %155 = load i64, ptr %154, align 8
  store i64 %155, ptr %prec, align 8
  br label %switch.done15

switch.done15:                                    ; preds = %switch.case.body14, %switch.case.body13, %switch.case.body12, %if.then11
  br label %if.done23

if.else16:                                        ; preds = %switch.done10
  switch i8 %2, label %switch.done22 [
    i8 101, label %switch.case.body17
    i8 69, label %switch.case.body17
    i8 102, label %switch.case.body18
    i8 70, label %switch.case.body18
    i8 103, label %switch.case.body19
    i8 71, label %switch.case.body19
  ]

switch.case.body17:                               ; preds = %if.else16, %if.else16
  %156 = load ptr, ptr %d, align 8
  %157 = load i64, ptr %prec, align 8
  %158 = add i64 %157, 1
  call void @"strconv_decimal::round"(ptr %156, i64 %158, ptr %__.context_ptr)
  br label %switch.done22

switch.case.body18:                               ; preds = %if.else16, %if.else16
  %159 = load ptr, ptr %d, align 8
  %160 = load ptr, ptr %d, align 8
  %161 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %160, i32 0, i32 2
  %162 = load i64, ptr %161, align 8
  %163 = load i64, ptr %prec, align 8
  %164 = add i64 %162, %163
  call void @"strconv_decimal::round"(ptr %159, i64 %164, ptr %__.context_ptr)
  br label %switch.done22

switch.case.body19:                               ; preds = %if.else16, %if.else16
  %165 = load i64, ptr %prec, align 8
  %166 = icmp eq i64 %165, 0
  %167 = zext i1 %166 to i8
  %168 = icmp ne i8 %167, 0
  br i1 %168, label %if.then20, label %if.done21

if.then20:                                        ; preds = %switch.case.body19
  store i64 1, ptr %prec, align 8
  br label %if.done21

if.done21:                                        ; preds = %if.then20, %switch.case.body19
  %169 = load ptr, ptr %d, align 8
  %170 = load i64, ptr %prec, align 8
  call void @"strconv_decimal::round"(ptr %169, i64 %170, ptr %__.context_ptr)
  br label %switch.done22

switch.done22:                                    ; preds = %if.done21, %switch.case.body18, %switch.case.body17, %if.else16
  call void @llvm.memset.p0.i64(ptr %17, i8 0, i64 40, i1 false)
  call void @llvm.memset.p0.i64(ptr %17, i8 0, i64 40, i1 false)
  %171 = load ptr, ptr %d, align 8
  %172 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %171, i32 0, i32 0
  %173 = load [384 x i8], ptr %172, align 1
  %174 = getelementptr [384 x i8], ptr %172, i64 0, i64 0
  %175 = getelementptr i8, ptr %174, i64 0
  %176 = getelementptr inbounds nuw { ptr, i64 }, ptr %18, i32 0, i32 0
  store ptr %175, ptr %176, align 8
  %177 = getelementptr inbounds nuw { ptr, i64 }, ptr %18, i32 0, i32 1
  store i64 384, ptr %177, align 8
  %178 = load { ptr, i64 }, ptr %18, align 8
  %179 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %17, i32 0, i32 0
  store { ptr, i64 } %178, ptr %179, align 8
  %180 = load ptr, ptr %d, align 8
  %181 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %180, i32 0, i32 1
  %182 = load i64, ptr %181, align 8
  %183 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %17, i32 0, i32 1
  store i64 %182, ptr %183, align 8
  %184 = load ptr, ptr %d, align 8
  %185 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %184, i32 0, i32 2
  %186 = load i64, ptr %185, align 8
  %187 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %17, i32 0, i32 2
  store i64 %186, ptr %187, align 8
  %188 = load %"strconv::Decimal_Slice", ptr %17, align 8
  store %"strconv::Decimal_Slice" %188, ptr %digs, align 8
  br label %if.done23

if.done23:                                        ; preds = %switch.done22, %switch.done15
  %189 = load i8, ptr %shortest, align 1
  %190 = load i8, ptr %neg, align 1
  %191 = load %"strconv::Decimal_Slice", ptr %digs, align 8
  %192 = load i64, ptr %prec, align 8
  %193 = call { ptr, i64 } @"strconv::format_digits"({ ptr, i64 } %0, i8 %189, i8 %190, ptr %digs, i64 %192, i8 %2, ptr %__.context_ptr)
  store { ptr, i64 } %193, ptr %14, align 8
  %194 = load { ptr, i64 }, ptr %14, align 8
  ret { ptr, i64 } %194
}

define internal void @"runtime::[heap_allocator_unix.odin]::_heap_free"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  call void @free(ptr %0)
  ret void
}

define internal i32 @"io::write_i64"({ i64, i64 } %0, i64 %1, i64 %2, ptr %3, ptr noalias nonnull %4, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %5 = alloca %"io::Stream", align 16
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca ptr, align 8
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  %buf = alloca [32 x i8], align 1
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca %..string, align 8
  %s = alloca %..string, align 8
  %11 = alloca { i64, i64 }, align 16
  %12 = alloca i64, align 8
  %13 = alloca { i64, i32 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %5, align 8
  %14 = load %"io::Stream", ptr %5, align 8
  store i64 %1, ptr %6, align 8
  store i64 %2, ptr %7, align 8
  store ptr %3, ptr %8, align 8
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  call void @llvm.memset.inline.p0.i64(ptr %buf, i8 0, i64 32, i1 false)
  %15 = load [32 x i8], ptr %buf, align 1
  %16 = getelementptr [32 x i8], ptr %buf, i64 0, i64 0
  %17 = getelementptr i8, ptr %16, i64 0
  %18 = getelementptr inbounds nuw { ptr, i64 }, ptr %9, i32 0, i32 0
  store ptr %17, ptr %18, align 8
  %19 = getelementptr inbounds nuw { ptr, i64 }, ptr %9, i32 0, i32 1
  store i64 32, ptr %19, align 8
  %20 = load { ptr, i64 }, ptr %9, align 8
  %21 = load %..string, ptr @"strconv::digits", align 8
  store %..string %21, ptr %10, align 8
  %22 = call %..string @"strconv::write_bits"({ ptr, i64 } %20, i64 %1, i64 %2, i8 1, i64 64, ptr byval(%..string) %10, i8 0, ptr %__.context_ptr)
  store %..string %22, ptr %s, align 8
  %23 = load %..string, ptr %s, align 8
  store %"io::Stream" %14, ptr %11, align 8
  %24 = load { i64, i64 }, ptr %11, align 8
  store i64 0, ptr %12, align 8
  %25 = call i32 @"io::write_string"({ i64, i64 } %24, %..string %23, ptr %3, ptr %12, ptr %__.context_ptr)
  %26 = load i64, ptr %12, align 8
  %27 = load { i64, i32 }, ptr %13, align 8
  store i64 %26, ptr %n, align 8
  store i32 %25, ptr %err, align 4
  store i64 %26, ptr %4, align 8
  ret i32 %25
}

define internal void @"sync::[futex_linux.odin]::_futex_signal"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca i64, align 8
  %3 = alloca { i64, i32 }, align 8
  %errno = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  store i64 0, ptr %2, align 8
  %4 = call i32 @"linux::futex_wake"(ptr %0, i32 1, i32 128, i32 1, ptr %2)
  %5 = load i64, ptr %2, align 8
  %6 = load { i64, i32 }, ptr %3, align 8
  store i32 %4, ptr %errno, align 4
  %7 = load i32, ptr %errno, align 4
  switch i32 %7, label %switch.default.body [
    i32 0, label %switch.case.body
  ]

switch.case.body:                                 ; preds = %entry
  ret void

switch.default.body:                              ; preds = %entry
  %8 = load %"runtime::Source_Code_Location", ptr @"scl$[_futex_signal1211]", align 8
  call void @"runtime::panic_contextless"(%..string { ptr @"csbs$byte_world$1ec", i64 25 }, ptr @"scl$[_futex_signal1211]")
  unreachable

switch.done:                                      ; No predecessors!
  ret void
}

define internal void @"runtime::default_random_generator_proc"(ptr %0, i64 %1, { ptr, i64 } %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca i64, align 8
  %5 = alloca { ptr, i64 }, align 8
  %r = alloca ptr, align 8
  %6 = alloca i64, align 8
  %pos = alloca i8, align 1
  %val = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %seed = alloca i64, align 8
  %info = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store i64 %1, ptr %4, align 8
  store { ptr, i64 } %2, ptr %5, align 8
  %9 = icmp eq ptr %0, null
  %10 = zext i1 %9 to i8
  %11 = icmp ne i8 %10, 0
  br i1 %11, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store ptr @"runtime::default_random_generator_proc-.global_rand_seed-35405", ptr %r, align 8
  br label %if.done

if.else:                                          ; preds = %entry
  store ptr %0, ptr %r, align 8
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then
  switch i64 %1, label %switch.done10 [
    i64 0, label %switch.case.body
    i64 1, label %switch.case.body6
    i64 2, label %switch.case.body7
  ]

switch.case.body:                                 ; preds = %if.done
  %12 = load ptr, ptr %r, align 8
  %13 = getelementptr inbounds nuw %"runtime::Default_Random_State", ptr %12, i32 0, i32 0
  %14 = load i64, ptr %13, align 8
  %15 = icmp eq i64 %14, 0
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %cmp.and, label %if.done2

cmp.and:                                          ; preds = %switch.case.body
  %18 = load ptr, ptr %r, align 8
  %19 = getelementptr inbounds nuw %"runtime::Default_Random_State", ptr %18, i32 0, i32 1
  %20 = load i64, ptr %19, align 8
  %21 = icmp eq i64 %20, 0
  %22 = zext i1 %21 to i8
  %23 = icmp ne i8 %22, 0
  br i1 %23, label %if.then1, label %if.done2

if.then1:                                         ; preds = %cmp.and
  %24 = load ptr, ptr %r, align 8
  call void @"runtime::default_random_generator_proc.init-1"(ptr %24, i64 0)
  br label %if.done2

if.done2:                                         ; preds = %if.then1, %cmp.and, %switch.case.body
  %25 = extractvalue { ptr, i64 } %2, 1
  switch i64 %25, label %switch.default.body [
    i64 8, label %switch.case.body3
  ]

switch.case.body3:                                ; preds = %if.done2
  %26 = extractvalue { ptr, i64 } %2, 0
  %27 = load ptr, ptr %r, align 8
  %28 = call i64 @"runtime::default_random_generator_proc.read_u64-0"(ptr %27)
  store i64 %28, ptr %6, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %26, ptr %6, i64 8, i1 false)
  br label %switch.done

switch.default.body:                              ; preds = %if.done2
  store i8 0, ptr %pos, align 1
  store i64 0, ptr %val, align 8
  %29 = extractvalue { ptr, i64 } %2, 1
  store i64 %29, ptr %7, align 8
  store i64 -1, ptr %8, align 8
  br label %for.index.loop

for.index.loop:                                   ; preds = %if.done5, %switch.default.body
  %30 = load i64, ptr %8, align 8
  %31 = add i64 %30, 1
  store i64 %31, ptr %8, align 8
  %32 = load i64, ptr %7, align 8
  %33 = icmp slt i64 %31, %32
  br i1 %33, label %for.index.body, label %for.index.done

for.index.body:                                   ; preds = %for.index.loop
  %34 = load i64, ptr %8, align 8
  %35 = extractvalue { ptr, i64 } %2, 0
  %36 = getelementptr i8, ptr %35, i64 %34
  %37 = load i8, ptr %36, align 1
  %38 = load i8, ptr %pos, align 1
  %39 = icmp eq i8 %38, 0
  %40 = zext i1 %39 to i8
  %41 = icmp ne i8 %40, 0
  br i1 %41, label %if.then4, label %if.done5

if.then4:                                         ; preds = %for.index.body
  %42 = load ptr, ptr %r, align 8
  %43 = call i64 @"runtime::default_random_generator_proc.read_u64-0"(ptr %42)
  store i64 %43, ptr %val, align 8
  store i8 8, ptr %pos, align 1
  br label %if.done5

if.done5:                                         ; preds = %if.then4, %for.index.body
  %44 = load i64, ptr %val, align 8
  %45 = trunc i64 %44 to i8
  store i8 %45, ptr %36, align 1
  %46 = load i64, ptr %val, align 8
  %47 = lshr i64 %46, 8
  %48 = select i1 true, i64 %47, i64 0
  store i64 %48, ptr %val, align 8
  %49 = load i8, ptr %pos, align 1
  %50 = sub i8 %49, 1
  store i8 %50, ptr %pos, align 1
  br label %for.index.loop

for.index.done:                                   ; preds = %for.index.loop
  br label %switch.done

switch.done:                                      ; preds = %for.index.done, %switch.case.body3
  br label %switch.done10

switch.case.body6:                                ; preds = %if.done
  store i64 0, ptr %seed, align 8
  %51 = extractvalue { ptr, i64 } %2, 0
  %52 = extractvalue { ptr, i64 } %2, 1
  %53 = icmp slt i64 8, %52
  %54 = select i1 %53, i64 8, i64 %52
  %55 = call ptr @"runtime::mem_copy_non_overlapping"(ptr %seed, ptr %51, i64 %54)
  %56 = load ptr, ptr %r, align 8
  %57 = load i64, ptr %seed, align 8
  call void @"runtime::default_random_generator_proc.init-1"(ptr %56, i64 %57)
  br label %switch.done10

switch.case.body7:                                ; preds = %if.done
  %58 = extractvalue { ptr, i64 } %2, 1
  %59 = icmp ne i64 %58, 4
  %60 = zext i1 %59 to i8
  %61 = icmp ne i8 %60, 0
  br i1 %61, label %if.then8, label %if.done9

if.then8:                                         ; preds = %switch.case.body7
  ret void

if.done9:                                         ; preds = %switch.case.body7
  %62 = extractvalue { ptr, i64 } %2, 0
  store ptr %62, ptr %info, align 8
  %63 = load ptr, ptr %info, align 8
  %64 = load i32, ptr %63, align 4
  %65 = or i32 %64, 10
  store i32 %65, ptr %63, align 4
  br label %switch.done10

switch.done10:                                    ; preds = %if.done9, %switch.case.body6, %switch.done, %if.done
  ret void
}

; Function Attrs: noreturn
define internal void @"runtime::slice_handle_error"(%..string %0, i32 %1, i32 %2, i64 %3, i64 %4, i64 %5) #2 {
decls:
  %6 = alloca %..string, align 8
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca %"runtime::Source_Code_Location", align 8
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %6, align 8
  store i32 %1, ptr %7, align 4
  store i32 %2, ptr %8, align 4
  store i64 %3, ptr %9, align 8
  store i64 %4, ptr %10, align 8
  store i64 %5, ptr %11, align 8
  call void @llvm.memset.p0.i64(ptr %12, i8 0, i64 40, i1 false)
  call void @llvm.memset.p0.i64(ptr %12, i8 0, i64 40, i1 false)
  %13 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %12, i32 0, i32 0
  store %..string %0, ptr %13, align 8
  %14 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %12, i32 0, i32 1
  store i32 %1, ptr %14, align 4
  %15 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %12, i32 0, i32 2
  store i32 %2, ptr %15, align 4
  %16 = load %"runtime::Source_Code_Location", ptr %12, align 8
  call void @"runtime::print_caller_location"(ptr %12)
  %17 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$1ee", i64 23 })
  call void @"runtime::print_i64"(i64 %3)
  %18 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$1ef", i64 1 })
  call void @"runtime::print_i64"(i64 %4)
  %19 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$1f0", i64 21 })
  call void @"runtime::print_i64"(i64 %5)
  %20 = call i64 @"runtime::print_byte"(i8 10)
  call void @"runtime::bounds_trap"()
  unreachable
}

define internal void @"bufio::writer_reset"(ptr %0, { i64, i64 } %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca %"io::Stream", align 16
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store { i64, i64 } %1, ptr %3, align 8
  %4 = load %"io::Stream", ptr %3, align 8
  %5 = load ptr, ptr %2, align 8
  %6 = getelementptr inbounds nuw %"bufio::Writer", ptr %5, i32 0, i32 2
  store %"io::Stream" %4, ptr %6, align 8
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds nuw %"bufio::Writer", ptr %7, i32 0, i32 3
  store i64 0, ptr %8, align 8
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr inbounds nuw %"bufio::Writer", ptr %9, i32 0, i32 4
  store i32 0, ptr %10, align 4
  ret void
}

define internal i8 @"strings::clone_to_cstring"(%..string %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca %..string, align 8
  %5 = alloca %"runtime::Allocator", align 16
  %res = alloca ptr, align 8
  %err = alloca i8, align 1
  %6 = alloca { i64, i64 }, align 16
  %7 = alloca { ptr, i64 }, align 8
  %8 = alloca { { ptr, i64 }, i8 }, align 8
  %c = alloca { ptr, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %4, align 8
  store { i64, i64 } %1, ptr %5, align 8
  %9 = load %"runtime::Allocator", ptr %5, align 8
  store ptr null, ptr %res, align 8
  store i8 0, ptr %err, align 1
  %10 = extractvalue %..string %0, 1
  %11 = add i64 %10, 1
  %12 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %9, ptr %6, align 8
  %13 = load { i64, i64 }, ptr %6, align 8
  call void @llvm.memset.inline.p0.i64(ptr %7, i8 0, i64 16, i1 false)
  %14 = call i8 @"runtime::make_slice:proc(T:$[]u8,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]u8,err:runtime::Allocator_Error)"(i64 %11, { i64, i64 } %13, ptr %2, ptr %7, ptr %__.context_ptr)
  %15 = load { ptr, i64 }, ptr %7, align 8
  %16 = load { { ptr, i64 }, i8 }, ptr %8, align 8
  %17 = icmp eq i8 %14, 0
  br i1 %17, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %entry
  store i8 %14, ptr %err, align 1
  %18 = load ptr, ptr %res, align 8
  %19 = load i8, ptr %err, align 1
  store ptr %18, ptr %res, align 8
  store i8 %19, ptr %err, align 1
  store ptr %18, ptr %3, align 8
  ret i8 %19

or_return.continue:                               ; preds = %entry
  store { ptr, i64 } %15, ptr %c, align 8
  %20 = load { ptr, i64 }, ptr %c, align 8
  %21 = call i64 @"runtime::copy_from_string:proc\22contextless\22(dst:[]u8,src:string)->(:int)"({ ptr, i64 } %20, %..string %0)
  %22 = load { ptr, i64 }, ptr %c, align 8
  %23 = getelementptr inbounds nuw { ptr, i64 }, ptr %c, i32 0, i32 0
  %24 = load ptr, ptr %23, align 8
  %25 = extractvalue %..string %0, 1
  %26 = getelementptr inbounds nuw { ptr, i64 }, ptr %c, i32 0, i32 1
  %27 = load i64, ptr %26, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1f1", i64 39 }, i32 49, i32 4, i64 %25, i64 %27)
  %28 = getelementptr i8, ptr %24, i64 %25
  store i8 0, ptr %28, align 1
  %29 = load { ptr, i64 }, ptr %c, align 8
  %30 = getelementptr inbounds nuw { ptr, i64 }, ptr %c, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr inbounds nuw { ptr, i64 }, ptr %c, i32 0, i32 1
  %33 = load i64, ptr %32, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1f1", i64 39 }, i32 50, i32 20, i64 0, i64 %33)
  %34 = getelementptr i8, ptr %31, i64 0
  store ptr %34, ptr %res, align 8
  store i8 0, ptr %err, align 1
  store ptr %34, ptr %3, align 8
  ret i8 0
}

define internal void @"sync::[futex_linux.odin]::_futex_broadcast"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca i64, align 8
  %3 = alloca { i64, i32 }, align 8
  %errno = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  store i64 0, ptr %2, align 8
  %4 = call i32 @"linux::futex_wake"(ptr %0, i32 1, i32 128, i32 2147483647, ptr %2)
  %5 = load i64, ptr %2, align 8
  %6 = load { i64, i32 }, ptr %3, align 8
  store i32 %4, ptr %errno, align 4
  %7 = load i32, ptr %errno, align 4
  switch i32 %7, label %switch.default.body [
    i32 0, label %switch.case.body
  ]

switch.case.body:                                 ; preds = %entry
  ret void

switch.default.body:                              ; preds = %entry
  %8 = load %"runtime::Source_Code_Location", ptr @"scl$[_futex_broadcast1469]", align 8
  call void @"runtime::panic_contextless"(%..string { ptr @"csbs$byte_world$1f2", i64 23 }, ptr @"scl$[_futex_broadcast1469]")
  unreachable

switch.done:                                      ; No predecessors!
  ret void
}

declare i32 @getrlimit(i32, ptr)

define internal i32 @"bufio::writer_flush"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca { i64, i64 }, align 16
  %4 = alloca i64, align 8
  %5 = alloca { i64, i32 }, align 8
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  %6 = alloca { ptr, i64 }, align 8
  %7 = alloca { ptr, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr inbounds nuw %"bufio::Writer", ptr %8, i32 0, i32 4
  %10 = load i32, ptr %9, align 4
  %11 = icmp ne i32 %10, 0
  %12 = zext i1 %11 to i8
  %13 = icmp ne i8 %12, 0
  br i1 %13, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %14 = load ptr, ptr %1, align 8
  %15 = getelementptr inbounds nuw %"bufio::Writer", ptr %14, i32 0, i32 4
  %16 = load i32, ptr %15, align 4
  ret i32 %16

if.done:                                          ; preds = %entry
  %17 = load ptr, ptr %1, align 8
  %18 = getelementptr inbounds nuw %"bufio::Writer", ptr %17, i32 0, i32 3
  %19 = load i64, ptr %18, align 8
  %20 = icmp eq i64 %19, 0
  %21 = zext i1 %20 to i8
  %22 = icmp ne i8 %21, 0
  br i1 %22, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.done
  ret i32 0

if.done2:                                         ; preds = %if.done
  %23 = load ptr, ptr %1, align 8
  %24 = getelementptr inbounds nuw %"bufio::Writer", ptr %23, i32 0, i32 2
  %25 = load %"io::Stream", ptr %24, align 8
  %26 = load ptr, ptr %1, align 8
  %27 = getelementptr inbounds nuw %"bufio::Writer", ptr %26, i32 0, i32 0
  %28 = load { ptr, i64 }, ptr %27, align 8
  %29 = load ptr, ptr %1, align 8
  %30 = getelementptr inbounds nuw %"bufio::Writer", ptr %29, i32 0, i32 3
  %31 = load i64, ptr %30, align 8
  %32 = getelementptr inbounds nuw { ptr, i64 }, ptr %27, i32 0, i32 1
  %33 = load i64, ptr %32, align 8
  call void @"runtime::slice_expr_error_lo_hi"(%..string { ptr @"csbs$byte_world$1e4", i64 36 }, i32 65, i32 32, i64 0, i64 %31, i64 %33)
  %34 = getelementptr inbounds nuw { ptr, i64 }, ptr %27, i32 0, i32 0
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr i8, ptr %35, i64 0
  %37 = sub i64 %31, 0
  %38 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  store ptr %36, ptr %38, align 8
  %39 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  store i64 %37, ptr %39, align 8
  %40 = load { ptr, i64 }, ptr %2, align 8
  store %"io::Stream" %25, ptr %3, align 8
  %41 = load { i64, i64 }, ptr %3, align 8
  store i64 0, ptr %4, align 8
  %42 = call i32 @"io::write"({ i64, i64 } %41, { ptr, i64 } %40, ptr null, ptr %4, ptr %__.context_ptr)
  %43 = load i64, ptr %4, align 8
  %44 = load { i64, i32 }, ptr %5, align 8
  store i64 %43, ptr %n, align 8
  store i32 %42, ptr %err, align 4
  %45 = load i64, ptr %n, align 8
  %46 = load ptr, ptr %1, align 8
  %47 = getelementptr inbounds nuw %"bufio::Writer", ptr %46, i32 0, i32 3
  %48 = load i64, ptr %47, align 8
  %49 = icmp slt i64 %45, %48
  %50 = zext i1 %49 to i8
  %51 = icmp ne i8 %50, 0
  br i1 %51, label %cmp.and, label %if.done4

cmp.and:                                          ; preds = %if.done2
  %52 = load i32, ptr %err, align 4
  %53 = icmp eq i32 %52, 0
  %54 = zext i1 %53 to i8
  %55 = icmp ne i8 %54, 0
  br i1 %55, label %if.then3, label %if.done4

if.then3:                                         ; preds = %cmp.and
  store i32 3, ptr %err, align 4
  br label %if.done4

if.done4:                                         ; preds = %if.then3, %cmp.and, %if.done2
  %56 = load i32, ptr %err, align 4
  %57 = icmp ne i32 %56, 0
  %58 = zext i1 %57 to i8
  %59 = icmp ne i8 %58, 0
  br i1 %59, label %if.then5, label %if.done9

if.then5:                                         ; preds = %if.done4
  %60 = load i64, ptr %n, align 8
  %61 = icmp sgt i64 %60, 0
  %62 = zext i1 %61 to i8
  %63 = icmp ne i8 %62, 0
  br i1 %63, label %cmp.and6, label %if.done8

cmp.and6:                                         ; preds = %if.then5
  %64 = load i64, ptr %n, align 8
  %65 = load ptr, ptr %1, align 8
  %66 = getelementptr inbounds nuw %"bufio::Writer", ptr %65, i32 0, i32 3
  %67 = load i64, ptr %66, align 8
  %68 = icmp slt i64 %64, %67
  %69 = zext i1 %68 to i8
  %70 = icmp ne i8 %69, 0
  br i1 %70, label %if.then7, label %if.done8

if.then7:                                         ; preds = %cmp.and6
  %71 = load ptr, ptr %1, align 8
  %72 = getelementptr inbounds nuw %"bufio::Writer", ptr %71, i32 0, i32 0
  %73 = load { ptr, i64 }, ptr %72, align 8
  %74 = load ptr, ptr %1, align 8
  %75 = getelementptr inbounds nuw %"bufio::Writer", ptr %74, i32 0, i32 3
  %76 = load i64, ptr %75, align 8
  %77 = load i64, ptr %n, align 8
  %78 = sub i64 %76, %77
  %79 = getelementptr inbounds nuw { ptr, i64 }, ptr %72, i32 0, i32 1
  %80 = load i64, ptr %79, align 8
  call void @"runtime::slice_expr_error_hi"(%..string { ptr @"csbs$byte_world$1e4", i64 36 }, i32 71, i32 14, i64 %78, i64 %80)
  %81 = getelementptr inbounds nuw { ptr, i64 }, ptr %72, i32 0, i32 0
  %82 = load ptr, ptr %81, align 8
  %83 = getelementptr i8, ptr %82, i64 0
  %84 = sub i64 %78, 0
  %85 = getelementptr inbounds nuw { ptr, i64 }, ptr %6, i32 0, i32 0
  store ptr %83, ptr %85, align 8
  %86 = getelementptr inbounds nuw { ptr, i64 }, ptr %6, i32 0, i32 1
  store i64 %84, ptr %86, align 8
  %87 = load { ptr, i64 }, ptr %6, align 8
  %88 = load ptr, ptr %1, align 8
  %89 = getelementptr inbounds nuw %"bufio::Writer", ptr %88, i32 0, i32 0
  %90 = load { ptr, i64 }, ptr %89, align 8
  %91 = load i64, ptr %n, align 8
  %92 = load ptr, ptr %1, align 8
  %93 = getelementptr inbounds nuw %"bufio::Writer", ptr %92, i32 0, i32 3
  %94 = load i64, ptr %93, align 8
  %95 = getelementptr inbounds nuw { ptr, i64 }, ptr %89, i32 0, i32 1
  %96 = load i64, ptr %95, align 8
  call void @"runtime::slice_expr_error_lo_hi"(%..string { ptr @"csbs$byte_world$1e4", i64 36 }, i32 71, i32 29, i64 %91, i64 %94, i64 %96)
  %97 = getelementptr inbounds nuw { ptr, i64 }, ptr %89, i32 0, i32 0
  %98 = load ptr, ptr %97, align 8
  %99 = getelementptr i8, ptr %98, i64 %91
  %100 = sub i64 %94, %91
  %101 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 0
  store ptr %99, ptr %101, align 8
  %102 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 1
  store i64 %100, ptr %102, align 8
  %103 = load { ptr, i64 }, ptr %7, align 8
  %104 = call i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]u8,src:[]u8)->(:int)"({ ptr, i64 } %87, { ptr, i64 } %103)
  br label %if.done8

if.done8:                                         ; preds = %if.then7, %cmp.and6, %if.then5
  %105 = load ptr, ptr %1, align 8
  %106 = getelementptr inbounds nuw %"bufio::Writer", ptr %105, i32 0, i32 3
  %107 = load i64, ptr %n, align 8
  %108 = load i64, ptr %106, align 8
  %109 = sub i64 %108, %107
  store i64 %109, ptr %106, align 8
  %110 = load ptr, ptr %1, align 8
  %111 = getelementptr inbounds nuw %"bufio::Writer", ptr %110, i32 0, i32 4
  %112 = load i32, ptr %err, align 4
  store i32 %112, ptr %111, align 4
  %113 = load i32, ptr %err, align 4
  ret i32 %113

if.done9:                                         ; preds = %if.done4
  %114 = load ptr, ptr %1, align 8
  %115 = getelementptr inbounds nuw %"bufio::Writer", ptr %114, i32 0, i32 3
  store i64 0, ptr %115, align 8
  ret i32 0
}

define internal i32 @"io::write_int"({ i64, i64 } %0, i64 %1, i64 %2, ptr %3, ptr noalias nonnull %4, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %5 = alloca %"io::Stream", align 16
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca ptr, align 8
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  %9 = alloca { i64, i64 }, align 16
  %10 = alloca i64, align 8
  %11 = alloca { i64, i32 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %5, align 8
  %12 = load %"io::Stream", ptr %5, align 8
  store i64 %1, ptr %6, align 8
  store i64 %2, ptr %7, align 8
  store ptr %3, ptr %8, align 8
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  store %"io::Stream" %12, ptr %9, align 8
  %13 = load { i64, i64 }, ptr %9, align 8
  store i64 0, ptr %10, align 8
  %14 = call i32 @"io::write_i64"({ i64, i64 } %13, i64 %1, i64 %2, ptr %3, ptr %10, ptr %__.context_ptr)
  %15 = load i64, ptr %10, align 8
  %16 = load { i64, i32 }, ptr %11, align 8
  store i64 %15, ptr %n, align 8
  store i32 %14, ptr %err, align 4
  store i64 %15, ptr %4, align 8
  ret i32 %14
}

; Function Attrs: noreturn
define internal void @"runtime::multi_pointer_slice_handle_error"(%..string %0, i32 %1, i32 %2, i64 %3, i64 %4) #2 {
decls:
  %5 = alloca %..string, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca %"runtime::Source_Code_Location", align 8
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %5, align 8
  store i32 %1, ptr %6, align 4
  store i32 %2, ptr %7, align 4
  store i64 %3, ptr %8, align 8
  store i64 %4, ptr %9, align 8
  call void @llvm.memset.p0.i64(ptr %10, i8 0, i64 40, i1 false)
  call void @llvm.memset.p0.i64(ptr %10, i8 0, i64 40, i1 false)
  %11 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %10, i32 0, i32 0
  store %..string %0, ptr %11, align 8
  %12 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %10, i32 0, i32 1
  store i32 %1, ptr %12, align 4
  %13 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %10, i32 0, i32 2
  store i32 %2, ptr %13, align 4
  %14 = load %"runtime::Source_Code_Location", ptr %10, align 8
  call void @"runtime::print_caller_location"(ptr %10)
  %15 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$1ee", i64 23 })
  call void @"runtime::print_i64"(i64 %3)
  %16 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$1ef", i64 1 })
  call void @"runtime::print_i64"(i64 %4)
  %17 = call i64 @"runtime::print_byte"(i8 10)
  call void @"runtime::bounds_trap"()
  unreachable
}

define internal i64 @"utf8::encode_rune"(i32 %0, ptr noalias nonnull %1) {
decls:
  %2 = alloca i32, align 4
  %r = alloca i32, align 4
  %buf = alloca [4 x i8], align 1
  %i = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %2, align 4
  store i32 %0, ptr %r, align 4
  call void @llvm.memset.inline.p0.i64(ptr %buf, i8 0, i64 4, i1 false)
  %3 = load i32, ptr %r, align 4
  store i32 %3, ptr %i, align 4
  %4 = load i32, ptr %i, align 4
  %5 = icmp ule i32 %4, 127
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %8 = getelementptr [4 x i8], ptr %buf, i64 0, i64 0
  %9 = load i32, ptr %r, align 4
  %10 = trunc i32 %9 to i8
  store i8 %10, ptr %8, align 1
  %11 = load [4 x i8], ptr %buf, align 1
  store [4 x i8] %11, ptr %1, align 1
  ret i64 1

if.done:                                          ; preds = %entry
  %12 = load i32, ptr %i, align 4
  %13 = icmp ule i32 %12, 2047
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.done
  %16 = getelementptr [4 x i8], ptr %buf, i64 0, i64 0
  %17 = load i32, ptr %r, align 4
  %18 = ashr i32 %17, 6
  %19 = select i1 true, i32 %18, i32 0
  %20 = trunc i32 %19 to i8
  %21 = or i8 -64, %20
  store i8 %21, ptr %16, align 1
  %22 = getelementptr [4 x i8], ptr %buf, i64 0, i64 1
  %23 = load i32, ptr %r, align 4
  %24 = trunc i32 %23 to i8
  %25 = and i8 %24, 63
  %26 = or i8 -128, %25
  store i8 %26, ptr %22, align 1
  %27 = load [4 x i8], ptr %buf, align 1
  store [4 x i8] %27, ptr %1, align 1
  ret i64 2

if.done2:                                         ; preds = %if.done
  %28 = load i32, ptr %i, align 4
  %29 = icmp ugt i32 %28, 1114111
  %30 = zext i1 %29 to i8
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %if.then3, label %cmp.or

cmp.or:                                           ; preds = %if.done2
  %32 = load i32, ptr %i, align 4
  %33 = icmp ule i32 55296, %32
  %34 = zext i1 %33 to i8
  %35 = icmp ne i8 %34, 0
  br i1 %35, label %cmp.and, label %if.done4

cmp.and:                                          ; preds = %cmp.or
  %36 = load i32, ptr %i, align 4
  %37 = icmp ule i32 %36, 57343
  %38 = zext i1 %37 to i8
  %39 = icmp ne i8 %38, 0
  br i1 %39, label %if.then3, label %if.done4

if.then3:                                         ; preds = %cmp.and, %if.done2
  store i32 65533, ptr %r, align 4
  br label %if.done4

if.done4:                                         ; preds = %if.then3, %cmp.and, %cmp.or
  %40 = load i32, ptr %i, align 4
  %41 = icmp ule i32 %40, 65535
  %42 = zext i1 %41 to i8
  %43 = icmp ne i8 %42, 0
  br i1 %43, label %if.then5, label %if.done6

if.then5:                                         ; preds = %if.done4
  %44 = getelementptr [4 x i8], ptr %buf, i64 0, i64 0
  %45 = load i32, ptr %r, align 4
  %46 = ashr i32 %45, 12
  %47 = select i1 true, i32 %46, i32 0
  %48 = trunc i32 %47 to i8
  %49 = or i8 -32, %48
  store i8 %49, ptr %44, align 1
  %50 = getelementptr [4 x i8], ptr %buf, i64 0, i64 1
  %51 = load i32, ptr %r, align 4
  %52 = ashr i32 %51, 6
  %53 = select i1 true, i32 %52, i32 0
  %54 = trunc i32 %53 to i8
  %55 = and i8 %54, 63
  %56 = or i8 -128, %55
  store i8 %56, ptr %50, align 1
  %57 = getelementptr [4 x i8], ptr %buf, i64 0, i64 2
  %58 = load i32, ptr %r, align 4
  %59 = trunc i32 %58 to i8
  %60 = and i8 %59, 63
  %61 = or i8 -128, %60
  store i8 %61, ptr %57, align 1
  %62 = load [4 x i8], ptr %buf, align 1
  store [4 x i8] %62, ptr %1, align 1
  ret i64 3

if.done6:                                         ; preds = %if.done4
  %63 = getelementptr [4 x i8], ptr %buf, i64 0, i64 0
  %64 = load i32, ptr %r, align 4
  %65 = ashr i32 %64, 18
  %66 = select i1 true, i32 %65, i32 0
  %67 = trunc i32 %66 to i8
  %68 = or i8 -16, %67
  store i8 %68, ptr %63, align 1
  %69 = getelementptr [4 x i8], ptr %buf, i64 0, i64 1
  %70 = load i32, ptr %r, align 4
  %71 = ashr i32 %70, 12
  %72 = select i1 true, i32 %71, i32 0
  %73 = trunc i32 %72 to i8
  %74 = and i8 %73, 63
  %75 = or i8 -128, %74
  store i8 %75, ptr %69, align 1
  %76 = getelementptr [4 x i8], ptr %buf, i64 0, i64 2
  %77 = load i32, ptr %r, align 4
  %78 = ashr i32 %77, 6
  %79 = select i1 true, i32 %78, i32 0
  %80 = trunc i32 %79 to i8
  %81 = and i8 %80, 63
  %82 = or i8 -128, %81
  store i8 %82, ptr %76, align 1
  %83 = getelementptr [4 x i8], ptr %buf, i64 0, i64 3
  %84 = load i32, ptr %r, align 4
  %85 = trunc i32 %84 to i8
  %86 = and i8 %85, 63
  %87 = or i8 -128, %86
  store i8 %87, ptr %83, align 1
  %88 = load [4 x i8], ptr %buf, align 1
  store [4 x i8] %88, ptr %1, align 1
  ret i64 4
}

; Function Attrs: alwaysinline
define internal void @"sys_valgrind::helgrind_client_request_stmt"(i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %5) #3 {
decls:
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca [6 x i64], align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %6, align 8
  store i64 %1, ptr %7, align 8
  store i64 %2, ptr %8, align 8
  store i64 %3, ptr %9, align 8
  store i64 %4, ptr %10, align 8
  store i64 %5, ptr %11, align 8
  %13 = getelementptr [6 x i64], ptr %12, i64 0, i64 0
  store i64 %0, ptr %13, align 8
  %14 = getelementptr [6 x i64], ptr %12, i64 0, i64 1
  store i64 %1, ptr %14, align 8
  %15 = getelementptr [6 x i64], ptr %12, i64 0, i64 2
  store i64 %2, ptr %15, align 8
  %16 = getelementptr [6 x i64], ptr %12, i64 0, i64 3
  store i64 %3, ptr %16, align 8
  %17 = getelementptr [6 x i64], ptr %12, i64 0, i64 4
  store i64 %4, ptr %17, align 8
  %18 = getelementptr [6 x i64], ptr %12, i64 0, i64 5
  store i64 %5, ptr %18, align 8
  %19 = call i64 asm sideeffect "rolq $$3, %rdi; rolq $$13, %rdi\0A rolq $$61, %rdi; rolq $$51, %rdi\0A xchgq %rbx, %rbx", "={rdx},{rdx},{rax},~{cc},~{memory}"(i64 0, ptr %12)
  ret void
}

define internal void @"runtime::default_temp_allocator_destroy"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = icmp ne ptr %0, null
  %3 = zext i1 %2 to i8
  %4 = icmp ne i8 %3, 0
  br i1 %4, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %5 = load ptr, ptr %1, align 8
  %6 = getelementptr inbounds nuw %"runtime::Default_Temp_Allocator", ptr %5, i32 0, i32 0
  %7 = load %"runtime::Source_Code_Location", ptr @"scl$[default_temp_allocator_destroy1583]", align 8
  call void @"runtime::arena_destroy"(ptr %6, ptr @"scl$[default_temp_allocator_destroy1583]")
  call void @llvm.memset.p0.i64(ptr %0, i8 0, i64 56, i1 false)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  ret void
}

declare i32 @pthread_attr_setdetachstate(ptr, i32)

define internal i8 @"runtime::default_temp_allocator_proc"(ptr %0, i8 %1, i64 %2, i64 %3, ptr %4, i64 %5, ptr %6, ptr noalias nonnull %7, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %8 = alloca ptr, align 8
  %9 = alloca i8, align 1
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca ptr, align 8
  %13 = alloca i64, align 8
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %s = alloca ptr, align 8
  %14 = alloca { ptr, i64 }, align 8
  %15 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %8, align 8
  store i8 %1, ptr %9, align 1
  store i64 %2, ptr %10, align 8
  store i64 %3, ptr %11, align 8
  store ptr %4, ptr %12, align 8
  store i64 %5, ptr %13, align 8
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  store ptr %0, ptr %s, align 8
  %16 = load ptr, ptr %s, align 8
  %17 = getelementptr inbounds nuw %"runtime::Default_Temp_Allocator", ptr %16, i32 0, i32 0
  %18 = load %"runtime::Source_Code_Location", ptr %6, align 8
  call void @llvm.memset.inline.p0.i64(ptr %14, i8 0, i64 16, i1 false)
  %19 = call i8 @"runtime::arena_allocator_proc"(ptr %17, i8 %1, i64 %2, i64 %3, ptr %4, i64 %5, ptr %6, ptr %14, ptr %__.context_ptr)
  %20 = load { ptr, i64 }, ptr %14, align 8
  %21 = load { { ptr, i64 }, i8 }, ptr %15, align 8
  store { ptr, i64 } %20, ptr %data, align 8
  store i8 %19, ptr %err, align 1
  store { ptr, i64 } %20, ptr %7, align 8
  ret i8 %19
}

define internal void @"runtime::memory_block_dealloc"(ptr %0, ptr %1) {
decls:
  %2 = alloca ptr, align 8
  %allocator = alloca %"runtime::Allocator", align 8
  %3 = alloca %"runtime::Context", align 8
  %4 = alloca %"runtime::Context", align 8
  %5 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  %6 = icmp ne ptr %0, null
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %9, i32 0, i32 1
  %11 = load %"runtime::Allocator", ptr %10, align 8
  store %"runtime::Allocator" %11, ptr %allocator, align 8
  call void @llvm.memset.p0.i64(ptr %3, i8 0, i64 112, i1 false)
  call void @"runtime::[core.odin]::__init_context"(ptr %3)
  call void @llvm.memset.p0.i64(ptr %4, i8 0, i64 112, i1 false)
  call void @"runtime::default_context"(ptr sret(ptr) %4)
  %12 = load %"runtime::Context", ptr %4, align 8
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %3, ptr align 8 %4, i64 112, i1 false)
  %13 = load %"runtime::Allocator", ptr %allocator, align 8
  %14 = getelementptr inbounds nuw %"runtime::Context", ptr %3, i32 0, i32 0
  store %"runtime::Allocator" %13, ptr %14, align 8
  %15 = load %"runtime::Allocator", ptr %allocator, align 8
  %16 = load %"runtime::Source_Code_Location", ptr %1, align 8
  store %"runtime::Allocator" %15, ptr %5, align 8
  %17 = load { i64, i64 }, ptr %5, align 8
  %18 = call i8 @"runtime::mem_free"(ptr %0, { i64, i64 } %17, ptr %1, ptr %3)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  ret void
}

define internal i64 @"bufio::writer_available"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = load ptr, ptr %1, align 8
  %3 = getelementptr inbounds nuw %"bufio::Writer", ptr %2, i32 0, i32 0
  %4 = load { ptr, i64 }, ptr %3, align 8
  %5 = getelementptr inbounds nuw { ptr, i64 }, ptr %3, i32 0, i32 1
  %6 = load i64, ptr %5, align 8
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr inbounds nuw %"bufio::Writer", ptr %7, i32 0, i32 3
  %9 = load i64, ptr %8, align 8
  %10 = sub i64 %6, %9
  ret i64 %10
}

; Function Attrs: noinline
define dso_local i32 @main(i32 %0, ptr %1) #4 {
decls:
  %2 = alloca i32, align 4
  %3 = alloca ptr, align 8
  %4 = alloca { ptr, i64 }, align 8
  %5 = alloca %"runtime::Context", align 8
  %6 = alloca %"runtime::Context", align 8
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %2, align 4
  store ptr %1, ptr %3, align 8
  %7 = load ptr, ptr %3, align 8
  %8 = sext i32 %0 to i64
  call void @"runtime::multi_pointer_slice_expr_error"(%..string { ptr @"csbs$byte_world$1f6", i64 42 }, i32 54, i32 17, i64 0, i64 %8)
  %9 = getelementptr ptr, ptr %7, i64 0
  %10 = sub i64 %8, 0
  %11 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 0
  %12 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 1
  store ptr %9, ptr %11, align 8
  store i64 %10, ptr %12, align 8
  %13 = load { ptr, i64 }, ptr %4, align 8
  store { ptr, i64 } %13, ptr @"runtime::args__", align 8
  call void @llvm.memset.p0.i64(ptr %5, i8 0, i64 112, i1 false)
  call void @"runtime::[core.odin]::__init_context"(ptr %5)
  call void @llvm.memset.p0.i64(ptr %6, i8 0, i64 112, i1 false)
  call void @"runtime::default_context"(ptr sret(ptr) %6)
  %14 = load %"runtime::Context", ptr %6, align 8
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %5, ptr align 8 %6, i64 112, i1 false)
  call void @"__$startup_runtime"(ptr %5) #4
  call void @"main::main"(ptr %5)
  call void @"__$cleanup_runtime"(ptr %5) #4
  ret i32 0
}

define internal %..string @"strconv::write_bits"({ ptr, i64 } %0, i64 %1, i64 %2, i8 %3, i64 %4, ptr byval(%..string) align 8 %5, i8 %6, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %7 = alloca { ptr, i64 }, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca i8, align 1
  %11 = alloca i64, align 8
  %12 = alloca %..string, align 8
  %13 = alloca i8, align 1
  %a = alloca [129 x i8], align 1
  %i = alloca i64, align 8
  %14 = alloca i64, align 8
  %15 = alloca { i64, i8 }, align 8
  %u = alloca i64, align 8
  %neg = alloca i8, align 1
  %b = alloca i64, align 8
  %ok = alloca i8, align 1
  %16 = alloca { ptr, i64 }, align 8
  %out = alloca { ptr, i64 }, align 8
  %17 = alloca { ptr, i64 }, align 8
  %18 = alloca %..string, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %7, align 8
  store i64 %1, ptr %8, align 8
  store i64 %2, ptr %9, align 8
  store i8 %3, ptr %10, align 1
  store i64 %4, ptr %11, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %12, ptr %5, i64 16, i1 false)
  store i8 %6, ptr %13, align 1
  %19 = icmp slt i64 %2, 2
  %20 = zext i1 %19 to i8
  %21 = icmp ne i8 %20, 0
  br i1 %21, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %entry
  %22 = icmp sgt i64 %2, 32
  %23 = zext i1 %22 to i8
  %24 = icmp ne i8 %23, 0
  br i1 %24, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %entry
  %25 = load %"runtime::Source_Code_Location", ptr @"scl$[write_bits1948]", align 8
  call void @"runtime::panic"(%..string { ptr @"csbs$byte_world$1f7", i64 42 }, ptr @"scl$[write_bits1948]", ptr %__.context_ptr)
  unreachable

if.done:                                          ; preds = %cmp.or
  call void @llvm.memset.p0.i64(ptr %a, i8 0, i64 129, i1 false)
  store i64 129, ptr %i, align 8
  store i64 0, ptr %14, align 8
  %26 = call i8 @"strconv::is_integer_negative"(i64 %1, i8 %3, i64 %4, ptr %14, ptr %__.context_ptr)
  %27 = load i64, ptr %14, align 8
  %28 = load { i64, i8 }, ptr %15, align 8
  store i64 %27, ptr %u, align 8
  store i8 %26, ptr %neg, align 1
  store i64 %2, ptr %b, align 8
  br label %for.loop

for.loop:                                         ; preds = %div.done, %if.done
  %29 = load i64, ptr %u, align 8
  %30 = load i64, ptr %b, align 8
  %31 = icmp uge i64 %29, %30
  %32 = zext i1 %31 to i8
  %33 = icmp ne i8 %32, 0
  br i1 %33, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %34 = load i64, ptr %i, align 8
  %35 = sub i64 %34, 1
  store i64 %35, ptr %i, align 8
  %36 = load i64, ptr %i, align 8
  %37 = getelementptr [129 x i8], ptr %a, i64 0, i64 %36
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 75, i32 11, i64 %36, i64 129)
  %38 = load %..string, ptr %12, align 8
  %39 = getelementptr inbounds nuw %..string, ptr %12, i32 0, i32 0
  %40 = load ptr, ptr %39, align 8
  %41 = getelementptr inbounds nuw %..string, ptr %12, i32 0, i32 1
  %42 = load i64, ptr %41, align 8
  %43 = load i64, ptr %u, align 8
  %44 = load i64, ptr %b, align 8
  %45 = icmp ne i64 %44, 0
  br i1 %45, label %mod.safe, label %mod.edge

mod.safe:                                         ; preds = %for.body
  %46 = urem i64 %43, %44
  br label %mod.done

mod.edge:                                         ; preds = %for.body
  call void @llvm.trap()
  unreachable

mod.done:                                         ; preds = %mod.safe
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 75, i32 23, i64 %46, i64 %42)
  %47 = getelementptr i8, ptr %40, i64 %46
  %48 = load i8, ptr %47, align 1
  store i8 %48, ptr %37, align 1
  %49 = load i64, ptr %b, align 8
  %50 = load i64, ptr %u, align 8
  %51 = icmp ne i64 %49, 0
  br i1 %51, label %div.safe, label %div.edge

div.safe:                                         ; preds = %mod.done
  %52 = udiv i64 %50, %49
  br label %div.done

div.edge:                                         ; preds = %mod.done
  call void @llvm.trap()
  unreachable

div.done:                                         ; preds = %div.safe
  store i64 %52, ptr %u, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %53 = load i64, ptr %i, align 8
  %54 = sub i64 %53, 1
  store i64 %54, ptr %i, align 8
  %55 = load i64, ptr %i, align 8
  %56 = getelementptr [129 x i8], ptr %a, i64 0, i64 %55
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 78, i32 10, i64 %55, i64 129)
  %57 = load %..string, ptr %12, align 8
  %58 = getelementptr inbounds nuw %..string, ptr %12, i32 0, i32 0
  %59 = load ptr, ptr %58, align 8
  %60 = getelementptr inbounds nuw %..string, ptr %12, i32 0, i32 1
  %61 = load i64, ptr %60, align 8
  %62 = load i64, ptr %u, align 8
  %63 = load i64, ptr %b, align 8
  %64 = icmp ne i64 %63, 0
  br i1 %64, label %mod.safe1, label %mod.edge2

mod.safe1:                                        ; preds = %for.done
  %65 = urem i64 %62, %63
  br label %mod.done3

mod.edge2:                                        ; preds = %for.done
  call void @llvm.trap()
  unreachable

mod.done3:                                        ; preds = %mod.safe1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 78, i32 22, i64 %65, i64 %61)
  %66 = getelementptr i8, ptr %59, i64 %65
  %67 = load i8, ptr %66, align 1
  store i8 %67, ptr %56, align 1
  %68 = and i8 %6, 1
  %69 = icmp ne i8 %68, 0
  %70 = zext i1 %69 to i8
  %71 = icmp ne i8 %70, 0
  br i1 %71, label %if.then4, label %if.done10

if.then4:                                         ; preds = %mod.done3
  store i8 1, ptr %ok, align 1
  switch i64 %2, label %switch.default.body [
    i64 2, label %switch.case.body
    i64 8, label %switch.case.body5
    i64 12, label %switch.case.body6
    i64 16, label %switch.case.body7
  ]

switch.case.body:                                 ; preds = %if.then4
  %72 = load i64, ptr %i, align 8
  %73 = sub i64 %72, 1
  store i64 %73, ptr %i, align 8
  %74 = load i64, ptr %i, align 8
  %75 = getelementptr [129 x i8], ptr %a, i64 0, i64 %74
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 83, i32 20, i64 %74, i64 129)
  store i8 98, ptr %75, align 1
  br label %switch.done

switch.case.body5:                                ; preds = %if.then4
  %76 = load i64, ptr %i, align 8
  %77 = sub i64 %76, 1
  store i64 %77, ptr %i, align 8
  %78 = load i64, ptr %i, align 8
  %79 = getelementptr [129 x i8], ptr %a, i64 0, i64 %78
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 84, i32 20, i64 %78, i64 129)
  store i8 111, ptr %79, align 1
  br label %switch.done

switch.case.body6:                                ; preds = %if.then4
  %80 = load i64, ptr %i, align 8
  %81 = sub i64 %80, 1
  store i64 %81, ptr %i, align 8
  %82 = load i64, ptr %i, align 8
  %83 = getelementptr [129 x i8], ptr %a, i64 0, i64 %82
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 86, i32 20, i64 %82, i64 129)
  store i8 122, ptr %83, align 1
  br label %switch.done

switch.case.body7:                                ; preds = %if.then4
  %84 = load i64, ptr %i, align 8
  %85 = sub i64 %84, 1
  store i64 %85, ptr %i, align 8
  %86 = load i64, ptr %i, align 8
  %87 = getelementptr [129 x i8], ptr %a, i64 0, i64 %86
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 87, i32 20, i64 %86, i64 129)
  store i8 120, ptr %87, align 1
  br label %switch.done

switch.default.body:                              ; preds = %if.then4
  store i8 0, ptr %ok, align 1
  br label %switch.done

switch.done:                                      ; preds = %switch.default.body, %switch.case.body7, %switch.case.body6, %switch.case.body5, %switch.case.body
  %88 = load i8, ptr %ok, align 1
  %89 = icmp ne i8 %88, 0
  br i1 %89, label %if.then8, label %if.done9

if.then8:                                         ; preds = %switch.done
  %90 = load i64, ptr %i, align 8
  %91 = sub i64 %90, 1
  store i64 %91, ptr %i, align 8
  %92 = load i64, ptr %i, align 8
  %93 = getelementptr [129 x i8], ptr %a, i64 0, i64 %92
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 91, i32 12, i64 %92, i64 129)
  store i8 48, ptr %93, align 1
  br label %if.done9

if.done9:                                         ; preds = %if.then8, %switch.done
  br label %if.done10

if.done10:                                        ; preds = %if.done9, %mod.done3
  %94 = load i8, ptr %neg, align 1
  %95 = icmp eq i8 1, %94
  br i1 %95, label %switch.case.body11, label %switch.case.next

switch.case.next:                                 ; preds = %if.done10
  %96 = and i8 %6, 2
  %97 = icmp ne i8 %96, 0
  %98 = zext i1 %97 to i8
  %99 = icmp eq i8 1, %98
  br i1 %99, label %switch.case.body13, label %switch.case.next12

switch.case.body11:                               ; preds = %if.done10
  %100 = load i64, ptr %i, align 8
  %101 = sub i64 %100, 1
  store i64 %101, ptr %i, align 8
  %102 = load i64, ptr %i, align 8
  %103 = getelementptr [129 x i8], ptr %a, i64 0, i64 %102
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 97, i32 11, i64 %102, i64 129)
  store i8 45, ptr %103, align 1
  br label %switch.done14

switch.case.next12:                               ; preds = %switch.case.next
  br label %switch.done14

switch.case.body13:                               ; preds = %switch.case.next
  %104 = load i64, ptr %i, align 8
  %105 = sub i64 %104, 1
  store i64 %105, ptr %i, align 8
  %106 = load i64, ptr %i, align 8
  %107 = getelementptr [129 x i8], ptr %a, i64 0, i64 %106
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 99, i32 11, i64 %106, i64 129)
  store i8 43, ptr %107, align 1
  br label %switch.done14

switch.done14:                                    ; preds = %switch.case.next12, %switch.case.body13, %switch.case.body11
  %108 = load [129 x i8], ptr %a, align 1
  %109 = load i64, ptr %i, align 8
  call void @"runtime::slice_expr_error_lo_hi"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 102, i32 10, i64 %109, i64 129, i64 129)
  %110 = getelementptr [129 x i8], ptr %a, i64 0, i64 0
  %111 = getelementptr i8, ptr %110, i64 %109
  %112 = sub i64 129, %109
  %113 = getelementptr inbounds nuw { ptr, i64 }, ptr %16, i32 0, i32 0
  store ptr %111, ptr %113, align 8
  %114 = getelementptr inbounds nuw { ptr, i64 }, ptr %16, i32 0, i32 1
  store i64 %112, ptr %114, align 8
  %115 = load { ptr, i64 }, ptr %16, align 8
  store { ptr, i64 } %115, ptr %out, align 8
  %116 = load { ptr, i64 }, ptr %out, align 8
  %117 = call i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]u8,src:[]u8)->(:int)"({ ptr, i64 } %0, { ptr, i64 } %116)
  %118 = load { ptr, i64 }, ptr %7, align 8
  %119 = load { ptr, i64 }, ptr %out, align 8
  %120 = getelementptr inbounds nuw { ptr, i64 }, ptr %out, i32 0, i32 1
  %121 = load i64, ptr %120, align 8
  %122 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 1
  %123 = load i64, ptr %122, align 8
  call void @"runtime::slice_expr_error_lo_hi"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 104, i32 19, i64 0, i64 %121, i64 %123)
  %124 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 0
  %125 = load ptr, ptr %124, align 8
  %126 = getelementptr i8, ptr %125, i64 0
  %127 = sub i64 %121, 0
  %128 = getelementptr inbounds nuw { ptr, i64 }, ptr %17, i32 0, i32 0
  store ptr %126, ptr %128, align 8
  %129 = getelementptr inbounds nuw { ptr, i64 }, ptr %17, i32 0, i32 1
  store i64 %127, ptr %129, align 8
  %130 = load { ptr, i64 }, ptr %17, align 8
  %131 = load %..string, ptr %17, align 8
  store %..string %131, ptr %18, align 8
  %132 = load %..string, ptr %18, align 8
  ret %..string %132
}

define internal void @"runtime::multi_pointer_slice_expr_error"(%..string %0, i32 %1, i32 %2, i64 %3, i64 %4) {
decls:
  %5 = alloca %..string, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %5, align 8
  store i32 %1, ptr %6, align 4
  store i32 %2, ptr %7, align 4
  store i64 %3, ptr %8, align 8
  store i64 %4, ptr %9, align 8
  %10 = icmp sle i64 %3, %4
  %11 = zext i1 %10 to i8
  %12 = icmp ne i8 %11, 0
  br i1 %12, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  call void @"runtime::multi_pointer_slice_handle_error"(%..string %0, i32 %1, i32 %2, i64 %3, i64 %4)
  unreachable
}

define internal i64 @"bufio::writer_buffered"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = load ptr, ptr %1, align 8
  %3 = getelementptr inbounds nuw %"bufio::Writer", ptr %2, i32 0, i32 3
  %4 = load i64, ptr %3, align 8
  ret i64 %4
}

define internal ptr @"mem::zero"(ptr %0, i64 %1) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  call void @llvm.memset.p0.i64(ptr %0, i8 0, i64 %1, i1 false)
  ret ptr %0
}

define internal i64 @"os::read_at_least"(i32 %0, { ptr, i64 } %1, i64 %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca i32, align 4
  %5 = alloca { ptr, i64 }, align 8
  %6 = alloca i64, align 8
  %n = alloca i64, align 8
  %err = alloca %"os::Error", align 8
  %7 = alloca %"os::Error", align 4
  %8 = alloca %"os::Error", align 8
  %9 = alloca i64, align 16
  %nn = alloca i64, align 8
  %10 = alloca { ptr, i64 }, align 8
  %11 = alloca i64, align 8
  %12 = alloca %"os::Error", align 16
  %13 = alloca { i64, %"os::Error" }, align 8
  %14 = alloca i64, align 16
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %4, align 4
  store { ptr, i64 } %1, ptr %5, align 8
  store i64 %2, ptr %6, align 8
  store i64 0, ptr %n, align 8
  call void @llvm.memset.inline.p0.i64(ptr %err, i8 0, i64 8, i1 false)
  %15 = extractvalue { ptr, i64 } %1, 1
  %16 = icmp slt i64 %15, %2
  %17 = zext i1 %16 to i8
  %18 = icmp ne i8 %17, 0
  br i1 %18, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  call void @llvm.memset.inline.p0.i64(ptr %7, i8 0, i64 8, i1 false)
  br i1 false, label %shared_nil.if_nil, label %shared_nil.if_not_nil

shared_nil.if_nil:                                ; preds = %if.then
  store %"os::Error" zeroinitializer, ptr %7, align 4
  br label %shared_nil.done

shared_nil.if_not_nil:                            ; preds = %if.then
  store i32 5, ptr %7, align 4
  %19 = getelementptr inbounds nuw %"os::Error", ptr %7, i32 0, i32 1
  store i32 2, ptr %19, align 4
  br label %shared_nil.done

shared_nil.done:                                  ; preds = %shared_nil.if_not_nil, %shared_nil.if_nil
  %20 = load %"os::Error", ptr %7, align 4
  store i64 0, ptr %n, align 8
  store %"os::Error" %20, ptr %err, align 4
  call void @llvm.memset.inline.p0.i64(ptr %8, i8 0, i64 8, i1 false)
  br i1 false, label %shared_nil.if_nil1, label %shared_nil.if_not_nil2

shared_nil.if_nil1:                               ; preds = %shared_nil.done
  store %"os::Error" zeroinitializer, ptr %8, align 4
  br label %shared_nil.done3

shared_nil.if_not_nil2:                           ; preds = %shared_nil.done
  store i32 5, ptr %8, align 4
  %21 = getelementptr inbounds nuw %"os::Error", ptr %8, i32 0, i32 1
  store i32 2, ptr %21, align 4
  br label %shared_nil.done3

shared_nil.done3:                                 ; preds = %shared_nil.if_not_nil2, %shared_nil.if_nil1
  %22 = load %"os::Error", ptr %8, align 4
  store i64 0, ptr %3, align 8
  store %"os::Error" %22, ptr %9, align 4
  %23 = load i64, ptr %9, align 8
  ret i64 %23

if.done:                                          ; preds = %entry
  store i64 9223372036854775807, ptr %nn, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.body, %if.done
  %24 = load i64, ptr %nn, align 8
  %25 = icmp sgt i64 %24, 0
  %26 = zext i1 %25 to i8
  %27 = icmp ne i8 %26, 0
  br i1 %27, label %cmp.and, label %for.done

cmp.and:                                          ; preds = %for.loop
  %28 = load i64, ptr %n, align 8
  %29 = icmp slt i64 %28, %2
  %30 = zext i1 %29 to i8
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %cmp.and4, label %for.done

cmp.and4:                                         ; preds = %cmp.and
  %32 = load %"os::Error", ptr %err, align 4
  %33 = getelementptr inbounds nuw %"os::Error", ptr %err, i32 0, i32 1
  %34 = load i32, ptr %33, align 4
  %35 = icmp eq i32 %34, 0
  %36 = zext i1 %35 to i8
  %37 = icmp ne i8 %36, 0
  br i1 %37, label %for.body, label %for.done

for.body:                                         ; preds = %cmp.and4
  %38 = load { ptr, i64 }, ptr %5, align 8
  %39 = load i64, ptr %n, align 8
  %40 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 1
  %41 = load i64, ptr %40, align 8
  call void @"runtime::slice_expr_error_lo_hi"(%..string { ptr @"csbs$byte_world$1f9", i64 29 }, i32 82, i32 25, i64 %39, i64 %41, i64 %41)
  %42 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 0
  %43 = load ptr, ptr %42, align 8
  %44 = getelementptr i8, ptr %43, i64 %39
  %45 = sub i64 %41, %39
  %46 = getelementptr inbounds nuw { ptr, i64 }, ptr %10, i32 0, i32 0
  store ptr %44, ptr %46, align 8
  %47 = getelementptr inbounds nuw { ptr, i64 }, ptr %10, i32 0, i32 1
  store i64 %45, ptr %47, align 8
  %48 = load { ptr, i64 }, ptr %10, align 8
  store i64 0, ptr %11, align 8
  %49 = call i64 @"os::read"(i32 %0, { ptr, i64 } %48, ptr %11, ptr %__.context_ptr)
  store i64 %49, ptr %12, align 8
  %50 = load %"os::Error", ptr %12, align 4
  %51 = load i64, ptr %11, align 8
  %52 = load { i64, %"os::Error" }, ptr %13, align 8
  store i64 %51, ptr %nn, align 8
  store %"os::Error" %50, ptr %err, align 4
  %53 = load i64, ptr %nn, align 8
  %54 = load i64, ptr %n, align 8
  %55 = add i64 %54, %53
  store i64 %55, ptr %n, align 8
  br label %for.loop

for.done:                                         ; preds = %cmp.and4, %cmp.and, %for.loop
  %56 = load i64, ptr %n, align 8
  %57 = icmp sge i64 %56, %2
  %58 = zext i1 %57 to i8
  %59 = icmp ne i8 %58, 0
  br i1 %59, label %if.then5, label %if.done6

if.then5:                                         ; preds = %for.done
  store %"os::Error" zeroinitializer, ptr %err, align 4
  br label %if.done6

if.done6:                                         ; preds = %if.then5, %for.done
  %60 = load i64, ptr %n, align 8
  %61 = load %"os::Error", ptr %err, align 4
  store i64 %60, ptr %n, align 8
  store %"os::Error" %61, ptr %err, align 4
  store i64 %60, ptr %3, align 8
  store %"os::Error" %61, ptr %14, align 4
  %62 = load i64, ptr %14, align 8
  ret i64 %62
}

define internal i8 @"runtime::alloc_from_memory_block"(ptr %0, i64 %1, i64 %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %alignment_offset = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca { i64, i8 }, align 8
  %size = alloca i64, align 8
  %size_ok = alloca i8, align 1
  %9 = alloca i64, align 8
  %10 = alloca { i64, i8 }, align 8
  %to_be_used = alloca i64, align 8
  %ok = alloca i8, align 1
  %11 = alloca ptr, align 8
  %12 = alloca { ptr, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %4, align 8
  store i64 %1, ptr %5, align 8
  store i64 %2, ptr %6, align 8
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %13 = icmp eq ptr %0, null
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store { ptr, i64 } zeroinitializer, ptr %data, align 8
  store i8 1, ptr %err, align 1
  store { ptr, i64 } zeroinitializer, ptr %3, align 8
  ret i8 1

if.done:                                          ; preds = %entry
  %16 = call i64 @"runtime::alloc_from_memory_block.calc_alignment_offset-0"(ptr %0, i64 %2)
  store i64 %16, ptr %alignment_offset, align 8
  %17 = load i64, ptr %alignment_offset, align 8
  store i64 0, ptr %7, align 8
  %18 = call i8 @"runtime::[default_temp_allocator_arena.odin]::safe_add"(i64 %1, i64 %17, ptr %7)
  %19 = load i64, ptr %7, align 8
  %20 = load { i64, i8 }, ptr %8, align 8
  store i64 %19, ptr %size, align 8
  store i8 %18, ptr %size_ok, align 1
  %21 = load i8, ptr %size_ok, align 1
  %22 = icmp ne i8 %21, 0
  br i1 %22, label %if.done2, label %if.then1

if.then1:                                         ; preds = %if.done
  store i8 1, ptr %err, align 1
  %23 = load { ptr, i64 }, ptr %data, align 8
  %24 = load i8, ptr %err, align 1
  store { ptr, i64 } %23, ptr %data, align 8
  store i8 %24, ptr %err, align 1
  store { ptr, i64 } %23, ptr %3, align 8
  ret i8 %24

if.done2:                                         ; preds = %if.done
  br label %if.init

if.init:                                          ; preds = %if.done2
  %25 = load ptr, ptr %4, align 8
  %26 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %25, i32 0, i32 3
  %27 = load i64, ptr %26, align 8
  %28 = load i64, ptr %size, align 8
  store i64 0, ptr %9, align 8
  %29 = call i8 @"runtime::[default_temp_allocator_arena.odin]::safe_add"(i64 %27, i64 %28, ptr %9)
  %30 = load i64, ptr %9, align 8
  %31 = load { i64, i8 }, ptr %10, align 8
  store i64 %30, ptr %to_be_used, align 8
  store i8 %29, ptr %ok, align 1
  %32 = load i8, ptr %ok, align 1
  %33 = icmp ne i8 %32, 0
  br i1 %33, label %cmp.or, label %if.then3

cmp.or:                                           ; preds = %if.init
  %34 = load i64, ptr %to_be_used, align 8
  %35 = load ptr, ptr %4, align 8
  %36 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %35, i32 0, i32 4
  %37 = load i64, ptr %36, align 8
  %38 = icmp ugt i64 %34, %37
  %39 = zext i1 %38 to i8
  %40 = icmp ne i8 %39, 0
  br i1 %40, label %if.then3, label %if.done4

if.then3:                                         ; preds = %cmp.or, %if.init
  store i8 1, ptr %err, align 1
  %41 = load { ptr, i64 }, ptr %data, align 8
  %42 = load i8, ptr %err, align 1
  store { ptr, i64 } %41, ptr %data, align 8
  store i8 %42, ptr %err, align 1
  store { ptr, i64 } %41, ptr %3, align 8
  ret i8 %42

if.done4:                                         ; preds = %cmp.or
  %43 = load ptr, ptr %4, align 8
  %44 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %43, i32 0, i32 2
  %45 = load ptr, ptr %44, align 8
  %46 = load ptr, ptr %4, align 8
  %47 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %46, i32 0, i32 3
  %48 = load i64, ptr %47, align 8
  %49 = load i64, ptr %alignment_offset, align 8
  %50 = add i64 %48, %49
  %51 = getelementptr i8, ptr %45, i64 %50
  store ptr %51, ptr %11, align 8
  %52 = load ptr, ptr %11, align 8
  call void @"runtime::multi_pointer_slice_expr_error"(%..string { ptr @"csbs$byte_world$1e1", i64 60 }, i32 92, i32 49, i64 0, i64 %1)
  %53 = getelementptr i8, ptr %52, i64 0
  %54 = sub i64 %1, 0
  %55 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  %56 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  store ptr %53, ptr %55, align 8
  store i64 %54, ptr %56, align 8
  %57 = load { ptr, i64 }, ptr %12, align 8
  store { ptr, i64 } %57, ptr %data, align 8
  %58 = load ptr, ptr %4, align 8
  %59 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %58, i32 0, i32 3
  %60 = load i64, ptr %size, align 8
  %61 = load i64, ptr %59, align 8
  %62 = add i64 %61, %60
  store i64 %62, ptr %59, align 8
  %63 = load { ptr, i64 }, ptr %data, align 8
  %64 = load i8, ptr %err, align 1
  store { ptr, i64 } %63, ptr %data, align 8
  store i8 %64, ptr %err, align 1
  store { ptr, i64 } %63, ptr %3, align 8
  ret i8 %64
}

define internal void @"runtime::slice_expr_error_hi"(%..string %0, i32 %1, i32 %2, i64 %3, i64 %4) {
decls:
  %5 = alloca %..string, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %5, align 8
  store i32 %1, ptr %6, align 4
  store i32 %2, ptr %7, align 4
  store i64 %3, ptr %8, align 8
  store i64 %4, ptr %9, align 8
  %10 = icmp sle i64 0, %3
  %11 = zext i1 %10 to i8
  %12 = icmp ne i8 %11, 0
  br i1 %12, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %entry
  %13 = icmp sle i64 %3, %4
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and
  ret void

if.done:                                          ; preds = %cmp.and, %entry
  call void @"runtime::slice_handle_error"(%..string %0, i32 %1, i32 %2, i64 0, i64 %3, i64 %4)
  unreachable
}

define internal void @"runtime::default_temp_allocator_temp_begin"(ptr noalias sret(%"runtime::Arena_Temp") %agg.result, ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %temp = alloca %"runtime::Arena_Temp", align 8
  %1 = alloca %"runtime::Arena_Temp", align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memset.inline.p0.i64(ptr %temp, i8 0, i64 24, i1 false)
  %2 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 1
  %3 = getelementptr inbounds nuw %"runtime::Allocator", ptr %2, i32 0, i32 1
  %4 = load ptr, ptr %3, align 8
  %5 = icmp eq ptr %4, @"runtime::global_default_temp_allocator_data"
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %8 = load %"runtime::Source_Code_Location", ptr %0, align 8
  call void @llvm.memset.inline.p0.i64(ptr %1, i8 0, i64 24, i1 false)
  call void @"runtime::arena_temp_begin"(ptr sret(ptr) %1, ptr @"runtime::global_default_temp_allocator_data", ptr %0, ptr %__.context_ptr)
  %9 = load %"runtime::Arena_Temp", ptr %1, align 8
  store %"runtime::Arena_Temp" %9, ptr %temp, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %10 = load %"runtime::Arena_Temp", ptr %temp, align 8
  store %"runtime::Arena_Temp" %10, ptr %temp, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %agg.result, ptr %temp, i64 24, i1 false)
  ret void
}

define internal i32 @"bufio::writer_write"(ptr %0, { ptr, i64 } %1, ptr noalias nonnull %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca { ptr, i64 }, align 8
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  %p = alloca { ptr, i64 }, align 8
  %m = alloca i64, align 8
  %5 = alloca { i64, i64 }, align 16
  %6 = alloca i64, align 8
  %7 = alloca { i64, i32 }, align 8
  %8 = alloca { ptr, i64 }, align 8
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca { ptr, i64 }, align 8
  %m6 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store { ptr, i64 } %1, ptr %4, align 8
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  store { ptr, i64 } %1, ptr %p, align 8
  br label %for.loop

for.loop:                                         ; preds = %if.done3, %entry
  %11 = load { ptr, i64 }, ptr %p, align 8
  %12 = getelementptr inbounds nuw { ptr, i64 }, ptr %p, i32 0, i32 1
  %13 = load i64, ptr %12, align 8
  %14 = call i64 @"bufio::writer_available"(ptr %0, ptr %__.context_ptr)
  %15 = icmp sgt i64 %13, %14
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %cmp.and, label %for.done

cmp.and:                                          ; preds = %for.loop
  %18 = load ptr, ptr %3, align 8
  %19 = getelementptr inbounds nuw %"bufio::Writer", ptr %18, i32 0, i32 4
  %20 = load i32, ptr %19, align 4
  %21 = icmp eq i32 %20, 0
  %22 = zext i1 %21 to i8
  %23 = icmp ne i8 %22, 0
  br i1 %23, label %for.body, label %for.done

for.body:                                         ; preds = %cmp.and
  store i64 0, ptr %m, align 8
  %24 = call i64 @"bufio::writer_buffered"(ptr %0, ptr %__.context_ptr)
  %25 = icmp eq i64 %24, 0
  %26 = zext i1 %25 to i8
  %27 = icmp ne i8 %26, 0
  br i1 %27, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %28 = load ptr, ptr %3, align 8
  %29 = getelementptr inbounds nuw %"bufio::Writer", ptr %28, i32 0, i32 4
  %30 = load ptr, ptr %3, align 8
  %31 = getelementptr inbounds nuw %"bufio::Writer", ptr %30, i32 0, i32 2
  %32 = load %"io::Stream", ptr %31, align 8
  %33 = load { ptr, i64 }, ptr %p, align 8
  store %"io::Stream" %32, ptr %5, align 8
  %34 = load { i64, i64 }, ptr %5, align 8
  store i64 0, ptr %6, align 8
  %35 = call i32 @"io::write"({ i64, i64 } %34, { ptr, i64 } %33, ptr null, ptr %6, ptr %__.context_ptr)
  %36 = load i64, ptr %6, align 8
  %37 = load { i64, i32 }, ptr %7, align 8
  store i64 %36, ptr %m, align 8
  store i32 %35, ptr %29, align 4
  %38 = load i64, ptr %m, align 8
  %39 = icmp slt i64 %38, 0
  %40 = zext i1 %39 to i8
  %41 = icmp ne i8 %40, 0
  br i1 %41, label %cmp.and1, label %if.done

cmp.and1:                                         ; preds = %if.then
  %42 = load ptr, ptr %3, align 8
  %43 = getelementptr inbounds nuw %"bufio::Writer", ptr %42, i32 0, i32 4
  %44 = load i32, ptr %43, align 4
  %45 = icmp eq i32 %44, 0
  %46 = zext i1 %45 to i8
  %47 = icmp ne i8 %46, 0
  br i1 %47, label %if.then2, label %if.done

if.then2:                                         ; preds = %cmp.and1
  %48 = load ptr, ptr %3, align 8
  %49 = getelementptr inbounds nuw %"bufio::Writer", ptr %48, i32 0, i32 4
  store i32 11, ptr %49, align 4
  br label %for.done

unreachable:                                      ; No predecessors!
  br label %if.done

if.done:                                          ; preds = %unreachable, %cmp.and1, %if.then
  br label %if.done3

if.else:                                          ; preds = %for.body
  %50 = load ptr, ptr %3, align 8
  %51 = getelementptr inbounds nuw %"bufio::Writer", ptr %50, i32 0, i32 0
  %52 = load { ptr, i64 }, ptr %51, align 8
  %53 = load ptr, ptr %3, align 8
  %54 = getelementptr inbounds nuw %"bufio::Writer", ptr %53, i32 0, i32 3
  %55 = load i64, ptr %54, align 8
  %56 = getelementptr inbounds nuw { ptr, i64 }, ptr %51, i32 0, i32 1
  %57 = load i64, ptr %56, align 8
  call void @"runtime::slice_expr_error_lo_hi"(%..string { ptr @"csbs$byte_world$1e4", i64 36 }, i32 105, i32 18, i64 %55, i64 %57, i64 %57)
  %58 = getelementptr inbounds nuw { ptr, i64 }, ptr %51, i32 0, i32 0
  %59 = load ptr, ptr %58, align 8
  %60 = getelementptr i8, ptr %59, i64 %55
  %61 = sub i64 %57, %55
  %62 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 0
  store ptr %60, ptr %62, align 8
  %63 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 1
  store i64 %61, ptr %63, align 8
  %64 = load { ptr, i64 }, ptr %8, align 8
  %65 = load { ptr, i64 }, ptr %p, align 8
  %66 = call i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]u8,src:[]u8)->(:int)"({ ptr, i64 } %64, { ptr, i64 } %65)
  store i64 %66, ptr %m, align 8
  %67 = load ptr, ptr %3, align 8
  %68 = getelementptr inbounds nuw %"bufio::Writer", ptr %67, i32 0, i32 3
  %69 = load i64, ptr %m, align 8
  %70 = load i64, ptr %68, align 8
  %71 = add i64 %70, %69
  store i64 %71, ptr %68, align 8
  %72 = call i32 @"bufio::writer_flush"(ptr %0, ptr %__.context_ptr)
  br label %if.done3

if.done3:                                         ; preds = %if.else, %if.done
  %73 = load i64, ptr %m, align 8
  %74 = load i64, ptr %n, align 8
  %75 = add i64 %74, %73
  store i64 %75, ptr %n, align 8
  %76 = load { ptr, i64 }, ptr %p, align 8
  %77 = load i64, ptr %m, align 8
  %78 = getelementptr inbounds nuw { ptr, i64 }, ptr %p, i32 0, i32 1
  %79 = load i64, ptr %78, align 8
  call void @"runtime::slice_expr_error_lo_hi"(%..string { ptr @"csbs$byte_world$1e4", i64 36 }, i32 110, i32 8, i64 %77, i64 %79, i64 %79)
  %80 = getelementptr inbounds nuw { ptr, i64 }, ptr %p, i32 0, i32 0
  %81 = load ptr, ptr %80, align 8
  %82 = getelementptr i8, ptr %81, i64 %77
  %83 = sub i64 %79, %77
  %84 = getelementptr inbounds nuw { ptr, i64 }, ptr %9, i32 0, i32 0
  store ptr %82, ptr %84, align 8
  %85 = getelementptr inbounds nuw { ptr, i64 }, ptr %9, i32 0, i32 1
  store i64 %83, ptr %85, align 8
  %86 = load { ptr, i64 }, ptr %9, align 8
  store { ptr, i64 } %86, ptr %p, align 8
  br label %for.loop

for.done:                                         ; preds = %if.then2, %cmp.and, %for.loop
  %87 = load ptr, ptr %3, align 8
  %88 = getelementptr inbounds nuw %"bufio::Writer", ptr %87, i32 0, i32 4
  %89 = load i32, ptr %88, align 4
  %90 = icmp ne i32 %89, 0
  %91 = zext i1 %90 to i8
  %92 = icmp ne i8 %91, 0
  br i1 %92, label %if.then4, label %if.done5

if.then4:                                         ; preds = %for.done
  %93 = load i64, ptr %n, align 8
  %94 = load ptr, ptr %3, align 8
  %95 = getelementptr inbounds nuw %"bufio::Writer", ptr %94, i32 0, i32 4
  %96 = load i32, ptr %95, align 4
  store i64 %93, ptr %n, align 8
  store i32 %96, ptr %err, align 4
  store i64 %93, ptr %2, align 8
  ret i32 %96

if.done5:                                         ; preds = %for.done
  %97 = load ptr, ptr %3, align 8
  %98 = getelementptr inbounds nuw %"bufio::Writer", ptr %97, i32 0, i32 0
  %99 = load { ptr, i64 }, ptr %98, align 8
  %100 = load ptr, ptr %3, align 8
  %101 = getelementptr inbounds nuw %"bufio::Writer", ptr %100, i32 0, i32 3
  %102 = load i64, ptr %101, align 8
  %103 = getelementptr inbounds nuw { ptr, i64 }, ptr %98, i32 0, i32 1
  %104 = load i64, ptr %103, align 8
  call void @"runtime::slice_expr_error_lo_hi"(%..string { ptr @"csbs$byte_world$1e4", i64 36 }, i32 115, i32 17, i64 %102, i64 %104, i64 %104)
  %105 = getelementptr inbounds nuw { ptr, i64 }, ptr %98, i32 0, i32 0
  %106 = load ptr, ptr %105, align 8
  %107 = getelementptr i8, ptr %106, i64 %102
  %108 = sub i64 %104, %102
  %109 = getelementptr inbounds nuw { ptr, i64 }, ptr %10, i32 0, i32 0
  store ptr %107, ptr %109, align 8
  %110 = getelementptr inbounds nuw { ptr, i64 }, ptr %10, i32 0, i32 1
  store i64 %108, ptr %110, align 8
  %111 = load { ptr, i64 }, ptr %10, align 8
  %112 = load { ptr, i64 }, ptr %p, align 8
  %113 = call i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]u8,src:[]u8)->(:int)"({ ptr, i64 } %111, { ptr, i64 } %112)
  store i64 %113, ptr %m6, align 8
  %114 = load ptr, ptr %3, align 8
  %115 = getelementptr inbounds nuw %"bufio::Writer", ptr %114, i32 0, i32 3
  %116 = load i64, ptr %m6, align 8
  %117 = load i64, ptr %115, align 8
  %118 = add i64 %117, %116
  store i64 %118, ptr %115, align 8
  %119 = load i64, ptr %n, align 8
  %120 = load i64, ptr %m6, align 8
  %121 = add i64 %120, %119
  store i64 %121, ptr %m6, align 8
  %122 = load i64, ptr %m6, align 8
  store i64 %122, ptr %n, align 8
  store i32 0, ptr %err, align 4
  store i64 %122, ptr %2, align 8
  ret i32 0
}

define internal i64 @"utf16::decode_rune_in_string"(%..string16 %0, ptr noalias nonnull %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca %..string16, align 8
  %r = alloca i32, align 4
  %width = alloca i64, align 8
  %n = alloca i64, align 8
  %c = alloca i16, align 2
  br label %entry

entry:                                            ; preds = %decls
  store %..string16 %0, ptr %2, align 8
  store i32 0, ptr %r, align 4
  store i64 0, ptr %width, align 8
  store i32 65533, ptr %r, align 4
  %3 = extractvalue %..string16 %0, 1
  store i64 %3, ptr %n, align 8
  %4 = load i64, ptr %n, align 8
  %5 = icmp slt i64 %4, 1
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %8 = load i32, ptr %r, align 4
  %9 = load i64, ptr %width, align 8
  store i32 %8, ptr %r, align 4
  store i64 %9, ptr %width, align 8
  store i32 %8, ptr %1, align 4
  ret i64 %9

if.done:                                          ; preds = %entry
  store i64 1, ptr %width, align 8
  %10 = extractvalue %..string16 %0, 0
  %11 = extractvalue %..string16 %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1df", i64 43 }, i32 119, i32 16, i64 0, i64 %11)
  %12 = getelementptr i16, ptr %10, i64 0
  %13 = load i16, ptr %12, align 2
  store i16 %13, ptr %c, align 2
  %14 = load i16, ptr %c, align 2
  %15 = icmp ult i16 %14, -10240
  %16 = zext i1 %15 to i8
  %17 = icmp eq i8 1, %16
  br i1 %17, label %switch.case.body, label %switch.case.next

switch.case.next:                                 ; preds = %if.done
  %18 = load i16, ptr %c, align 2
  %19 = icmp ule i16 -8192, %18
  %20 = zext i1 %19 to i8
  %21 = icmp eq i8 1, %20
  br i1 %21, label %switch.case.body, label %switch.case.next1

switch.case.next1:                                ; preds = %switch.case.next
  %22 = load i16, ptr %c, align 2
  %23 = icmp ule i16 -10240, %22
  %24 = zext i1 %23 to i8
  %25 = icmp ne i8 %24, 0
  br i1 %25, label %cmp.and, label %logical.cmp.done

switch.case.body:                                 ; preds = %switch.case.next, %if.done
  %26 = load i16, ptr %c, align 2
  %27 = zext i16 %26 to i32
  store i32 %27, ptr %r, align 4
  br label %switch.done

cmp.and:                                          ; preds = %switch.case.next1
  %28 = load i16, ptr %c, align 2
  %29 = icmp ult i16 %28, -9216
  %30 = zext i1 %29 to i8
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %cmp.and2, label %logical.cmp.done

cmp.and2:                                         ; preds = %cmp.and
  %32 = extractvalue %..string16 %0, 1
  %33 = icmp slt i64 1, %32
  %34 = zext i1 %33 to i8
  %35 = icmp ne i8 %34, 0
  br i1 %35, label %cmp.and3, label %logical.cmp.done

cmp.and3:                                         ; preds = %cmp.and2
  %36 = extractvalue %..string16 %0, 0
  %37 = extractvalue %..string16 %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1df", i64 43 }, i32 123, i32 15, i64 1, i64 %37)
  %38 = getelementptr i16, ptr %36, i64 1
  %39 = load i16, ptr %38, align 2
  %40 = icmp ule i16 -9216, %39
  %41 = zext i1 %40 to i8
  %42 = icmp ne i8 %41, 0
  br i1 %42, label %logical.cmp.rhs, label %logical.cmp.done

logical.cmp.rhs:                                  ; preds = %cmp.and3
  %43 = extractvalue %..string16 %0, 0
  %44 = extractvalue %..string16 %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1df", i64 43 }, i32 123, i32 23, i64 1, i64 %44)
  %45 = getelementptr i16, ptr %43, i64 1
  %46 = load i16, ptr %45, align 2
  %47 = icmp ult i16 %46, -8192
  %48 = zext i1 %47 to i8
  %49 = icmp ne i8 %48, 0
  br label %logical.cmp.done

logical.cmp.done:                                 ; preds = %logical.cmp.rhs, %cmp.and3, %cmp.and2, %cmp.and, %switch.case.next1
  %50 = phi i1 [ false, %switch.case.next1 ], [ false, %cmp.and ], [ false, %cmp.and2 ], [ false, %cmp.and3 ], [ %49, %logical.cmp.rhs ]
  %51 = zext i1 %50 to i8
  %52 = icmp eq i8 1, %51
  br i1 %52, label %switch.case.body5, label %switch.case.next4

switch.case.next4:                                ; preds = %logical.cmp.done
  br label %switch.done

switch.case.body5:                                ; preds = %logical.cmp.done
  %53 = load i16, ptr %c, align 2
  %54 = zext i16 %53 to i32
  %55 = extractvalue %..string16 %0, 0
  %56 = extractvalue %..string16 %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1df", i64 43 }, i32 124, i32 45, i64 1, i64 %56)
  %57 = getelementptr i16, ptr %55, i64 1
  %58 = load i16, ptr %57, align 2
  %59 = zext i16 %58 to i32
  %60 = call i32 @"utf16::decode_surrogate_pair"(i32 %54, i32 %59, ptr %__.context_ptr)
  store i32 %60, ptr %r, align 4
  %61 = load i64, ptr %width, align 8
  %62 = add i64 %61, 1
  store i64 %62, ptr %width, align 8
  br label %switch.done

switch.done:                                      ; preds = %switch.case.next4, %switch.case.body5, %switch.case.body
  %63 = load i32, ptr %r, align 4
  %64 = load i64, ptr %width, align 8
  store i32 %63, ptr %r, align 4
  store i64 %64, ptr %width, align 8
  store i32 %63, ptr %1, align 4
  ret i64 %64
}

define internal i64 @"runtime::encode_rune"(i32 %0, ptr noalias nonnull %1) {
decls:
  %2 = alloca i32, align 4
  %r = alloca i32, align 4
  %buf = alloca [4 x i8], align 1
  %i = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %2, align 4
  store i32 %0, ptr %r, align 4
  call void @llvm.memset.inline.p0.i64(ptr %buf, i8 0, i64 4, i1 false)
  %3 = load i32, ptr %r, align 4
  store i32 %3, ptr %i, align 4
  %4 = load i32, ptr %i, align 4
  %5 = icmp ule i32 %4, 127
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %8 = getelementptr [4 x i8], ptr %buf, i64 0, i64 0
  %9 = load i32, ptr %r, align 4
  %10 = trunc i32 %9 to i8
  store i8 %10, ptr %8, align 1
  %11 = load [4 x i8], ptr %buf, align 1
  store [4 x i8] %11, ptr %1, align 1
  ret i64 1

if.done:                                          ; preds = %entry
  %12 = load i32, ptr %i, align 4
  %13 = icmp ule i32 %12, 2047
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.done
  %16 = getelementptr [4 x i8], ptr %buf, i64 0, i64 0
  %17 = load i32, ptr %r, align 4
  %18 = ashr i32 %17, 6
  %19 = select i1 true, i32 %18, i32 0
  %20 = trunc i32 %19 to i8
  %21 = or i8 -64, %20
  store i8 %21, ptr %16, align 1
  %22 = getelementptr [4 x i8], ptr %buf, i64 0, i64 1
  %23 = load i32, ptr %r, align 4
  %24 = trunc i32 %23 to i8
  %25 = and i8 %24, 63
  %26 = or i8 -128, %25
  store i8 %26, ptr %22, align 1
  %27 = load [4 x i8], ptr %buf, align 1
  store [4 x i8] %27, ptr %1, align 1
  ret i64 2

if.done2:                                         ; preds = %if.done
  %28 = load i32, ptr %i, align 4
  %29 = icmp ugt i32 %28, 1114111
  %30 = zext i1 %29 to i8
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %if.then3, label %cmp.or

cmp.or:                                           ; preds = %if.done2
  %32 = load i32, ptr %i, align 4
  %33 = icmp ule i32 55296, %32
  %34 = zext i1 %33 to i8
  %35 = icmp ne i8 %34, 0
  br i1 %35, label %cmp.and, label %if.done4

cmp.and:                                          ; preds = %cmp.or
  %36 = load i32, ptr %i, align 4
  %37 = icmp ule i32 %36, 57343
  %38 = zext i1 %37 to i8
  %39 = icmp ne i8 %38, 0
  br i1 %39, label %if.then3, label %if.done4

if.then3:                                         ; preds = %cmp.and, %if.done2
  store i32 65533, ptr %r, align 4
  br label %if.done4

if.done4:                                         ; preds = %if.then3, %cmp.and, %cmp.or
  %40 = load i32, ptr %i, align 4
  %41 = icmp ule i32 %40, 65535
  %42 = zext i1 %41 to i8
  %43 = icmp ne i8 %42, 0
  br i1 %43, label %if.then5, label %if.done6

if.then5:                                         ; preds = %if.done4
  %44 = getelementptr [4 x i8], ptr %buf, i64 0, i64 0
  %45 = load i32, ptr %r, align 4
  %46 = ashr i32 %45, 12
  %47 = select i1 true, i32 %46, i32 0
  %48 = trunc i32 %47 to i8
  %49 = or i8 -32, %48
  store i8 %49, ptr %44, align 1
  %50 = getelementptr [4 x i8], ptr %buf, i64 0, i64 1
  %51 = load i32, ptr %r, align 4
  %52 = ashr i32 %51, 6
  %53 = select i1 true, i32 %52, i32 0
  %54 = trunc i32 %53 to i8
  %55 = and i8 %54, 63
  %56 = or i8 -128, %55
  store i8 %56, ptr %50, align 1
  %57 = getelementptr [4 x i8], ptr %buf, i64 0, i64 2
  %58 = load i32, ptr %r, align 4
  %59 = trunc i32 %58 to i8
  %60 = and i8 %59, 63
  %61 = or i8 -128, %60
  store i8 %61, ptr %57, align 1
  %62 = load [4 x i8], ptr %buf, align 1
  store [4 x i8] %62, ptr %1, align 1
  ret i64 3

if.done6:                                         ; preds = %if.done4
  %63 = getelementptr [4 x i8], ptr %buf, i64 0, i64 0
  %64 = load i32, ptr %r, align 4
  %65 = ashr i32 %64, 18
  %66 = select i1 true, i32 %65, i32 0
  %67 = trunc i32 %66 to i8
  %68 = or i8 -16, %67
  store i8 %68, ptr %63, align 1
  %69 = getelementptr [4 x i8], ptr %buf, i64 0, i64 1
  %70 = load i32, ptr %r, align 4
  %71 = ashr i32 %70, 12
  %72 = select i1 true, i32 %71, i32 0
  %73 = trunc i32 %72 to i8
  %74 = and i8 %73, 63
  %75 = or i8 -128, %74
  store i8 %75, ptr %69, align 1
  %76 = getelementptr [4 x i8], ptr %buf, i64 0, i64 2
  %77 = load i32, ptr %r, align 4
  %78 = ashr i32 %77, 6
  %79 = select i1 true, i32 %78, i32 0
  %80 = trunc i32 %79 to i8
  %81 = and i8 %80, 63
  %82 = or i8 -128, %81
  store i8 %82, ptr %76, align 1
  %83 = getelementptr [4 x i8], ptr %buf, i64 0, i64 3
  %84 = load i32, ptr %r, align 4
  %85 = trunc i32 %84 to i8
  %86 = and i8 %85, 63
  %87 = or i8 -128, %86
  store i8 %87, ptr %83, align 1
  %88 = load [4 x i8], ptr %buf, align 1
  store [4 x i8] %88, ptr %1, align 1
  ret i64 4
}

define internal i64 @"time::now"() {
decls:
  %0 = alloca %"time::Time", align 16
  %1 = alloca i64, align 16
  br label %entry

entry:                                            ; preds = %decls
  %2 = call i64 @"time::_now"()
  store i64 %2, ptr %0, align 8
  %3 = load %"time::Time", ptr %0, align 8
  store %"time::Time" %3, ptr %1, align 8
  %4 = load i64, ptr %1, align 8
  ret i64 %4
}

; Function Attrs: alwaysinline
define internal i64 @"utf8::decode_rune_in_string"(%..string %0, ptr noalias nonnull %1) #3 {
decls:
  %2 = alloca %..string, align 8
  %3 = alloca %..string, align 8
  %4 = alloca i32, align 4
  %5 = alloca { i32, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %2, align 8
  store %..string %0, ptr %3, align 8
  %6 = load { ptr, i64 }, ptr %3, align 8
  store i32 0, ptr %4, align 4
  %7 = call i64 @"utf8::decode_rune_in_bytes"({ ptr, i64 } %6, ptr %4)
  %8 = load i32, ptr %4, align 4
  %9 = load { i32, i64 }, ptr %5, align 8
  store i32 %8, ptr %1, align 4
  ret i64 %7
}

define internal i64 @"runtime::copy_slice_raw"(ptr %0, ptr %1, i64 %2, i64 %3, i64 %4) {
decls:
  %5 = alloca ptr, align 8
  %6 = alloca ptr, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %n = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %5, align 8
  store ptr %1, ptr %6, align 8
  store i64 %2, ptr %7, align 8
  store i64 %3, ptr %8, align 8
  store i64 %4, ptr %9, align 8
  %10 = icmp slt i64 %2, %3
  %11 = select i1 %10, i64 %2, i64 %3
  store i64 %11, ptr %n, align 8
  %12 = load i64, ptr %n, align 8
  %13 = icmp sgt i64 %12, 0
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %16 = load i64, ptr %n, align 8
  %17 = mul i64 %16, %4
  call void @llvm.memmove.p0.p0.i64(ptr %0, ptr %1, i64 %17, i1 false)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %18 = load i64, ptr %n, align 8
  ret i64 %18
}

define internal void @"runtime::slice_expr_error_lo_hi"(%..string %0, i32 %1, i32 %2, i64 %3, i64 %4, i64 %5) {
decls:
  %6 = alloca %..string, align 8
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %6, align 8
  store i32 %1, ptr %7, align 4
  store i32 %2, ptr %8, align 4
  store i64 %3, ptr %9, align 8
  store i64 %4, ptr %10, align 8
  store i64 %5, ptr %11, align 8
  %12 = icmp sle i64 0, %3
  %13 = zext i1 %12 to i8
  %14 = icmp ne i8 %13, 0
  br i1 %14, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %entry
  %15 = icmp sle i64 %3, %5
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %cmp.and1, label %if.done

cmp.and1:                                         ; preds = %cmp.and
  %18 = icmp sle i64 %3, %4
  %19 = zext i1 %18 to i8
  %20 = icmp ne i8 %19, 0
  br i1 %20, label %cmp.and2, label %if.done

cmp.and2:                                         ; preds = %cmp.and1
  %21 = icmp sle i64 %4, %5
  %22 = zext i1 %21 to i8
  %23 = icmp ne i8 %22, 0
  br i1 %23, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and2
  ret void

if.done:                                          ; preds = %cmp.and2, %cmp.and1, %cmp.and, %entry
  call void @"runtime::slice_handle_error"(%..string %0, i32 %1, i32 %2, i64 %3, i64 %4, i64 %5)
  unreachable
}

define internal i64 @"os::read_full"(i32 %0, { ptr, i64 } %1, ptr noalias nonnull %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca i32, align 4
  %4 = alloca { ptr, i64 }, align 8
  %n = alloca i64, align 8
  %err = alloca %"os::Error", align 4
  %5 = alloca i64, align 8
  %6 = alloca %"os::Error", align 16
  %7 = alloca { i64, %"os::Error" }, align 8
  %8 = alloca i64, align 16
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %3, align 4
  store { ptr, i64 } %1, ptr %4, align 8
  store i64 0, ptr %n, align 8
  call void @llvm.memset.inline.p0.i64(ptr %err, i8 0, i64 8, i1 false)
  %9 = extractvalue { ptr, i64 } %1, 1
  store i64 0, ptr %5, align 8
  %10 = call i64 @"os::read_at_least"(i32 %0, { ptr, i64 } %1, i64 %9, ptr %5, ptr %__.context_ptr)
  store i64 %10, ptr %6, align 8
  %11 = load %"os::Error", ptr %6, align 4
  %12 = load i64, ptr %5, align 8
  %13 = load { i64, %"os::Error" }, ptr %7, align 8
  store i64 %12, ptr %n, align 8
  store %"os::Error" %11, ptr %err, align 4
  store i64 %12, ptr %2, align 8
  store %"os::Error" %11, ptr %8, align 4
  %14 = load i64, ptr %8, align 8
  ret i64 %14
}

define internal i64 @"reflect::type_kind"(i64 %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca i64, align 8
  %ti = alloca ptr, align 8
  %2 = alloca [72 x i8], align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %3 = call ptr @"runtime::__type_info_of"(i64 %0)
  store ptr %3, ptr %ti, align 8
  %4 = load ptr, ptr %ti, align 8
  %5 = icmp ne ptr %4, null
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %8 = load ptr, ptr %ti, align 8
  %9 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %8, i32 0, i32 5
  %10 = load { [9 x i64], i64 }, ptr %9, align 8
  %11 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %9, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  switch i64 %12, label %typeswitch.done [
    i64 1, label %typeswitch.body
    i64 2, label %typeswitch.body1
    i64 3, label %typeswitch.body2
    i64 4, label %typeswitch.body3
    i64 5, label %typeswitch.body4
    i64 6, label %typeswitch.body5
    i64 7, label %typeswitch.body6
    i64 8, label %typeswitch.body7
    i64 9, label %typeswitch.body8
    i64 10, label %typeswitch.body9
    i64 11, label %typeswitch.body10
    i64 12, label %typeswitch.body11
    i64 13, label %typeswitch.body12
    i64 14, label %typeswitch.body13
    i64 15, label %typeswitch.body14
    i64 16, label %typeswitch.body15
    i64 17, label %typeswitch.body16
    i64 18, label %typeswitch.body17
    i64 19, label %typeswitch.body18
    i64 20, label %typeswitch.body19
    i64 21, label %typeswitch.body20
    i64 22, label %typeswitch.body21
    i64 23, label %typeswitch.body22
    i64 24, label %typeswitch.body23
    i64 25, label %typeswitch.body24
    i64 26, label %typeswitch.body25
    i64 27, label %typeswitch.body26
  ]

typeswitch.body:                                  ; preds = %if.then
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %9, i64 48, i1 false)
  ret i64 1

typeswitch.body1:                                 ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 2, i1 false)
  ret i64 2

typeswitch.body2:                                 ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 0, i1 false)
  ret i64 3

typeswitch.body3:                                 ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 1, i1 false)
  ret i64 4

typeswitch.body4:                                 ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 0, i1 false)
  ret i64 5

typeswitch.body5:                                 ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 0, i1 false)
  ret i64 6

typeswitch.body6:                                 ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 2, i1 false)
  ret i64 7

typeswitch.body7:                                 ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 0, i1 false)
  ret i64 8

typeswitch.body8:                                 ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 0, i1 false)
  ret i64 9

typeswitch.body9:                                 ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 0, i1 false)
  ret i64 10

typeswitch.body10:                                ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 8, i1 false)
  ret i64 11

typeswitch.body11:                                ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 8, i1 false)
  ret i64 12

typeswitch.body12:                                ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 24, i1 false)
  ret i64 13

typeswitch.body13:                                ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 24, i1 false)
  ret i64 14

typeswitch.body14:                                ; preds = %if.then
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %9, i64 56, i1 false)
  ret i64 15

typeswitch.body15:                                ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 16, i1 false)
  ret i64 16

typeswitch.body16:                                ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 16, i1 false)
  ret i64 17

typeswitch.body17:                                ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 32, i1 false)
  ret i64 18

typeswitch.body18:                                ; preds = %if.then
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %9, i64 72, i1 false)
  ret i64 19

typeswitch.body19:                                ; preds = %if.then
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %9, i64 48, i1 false)
  ret i64 20

typeswitch.body20:                                ; preds = %if.then
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %9, i64 40, i1 false)
  ret i64 21

typeswitch.body21:                                ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 24, i1 false)
  ret i64 22

typeswitch.body22:                                ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 32, i1 false)
  ret i64 23

typeswitch.body23:                                ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 24, i1 false)
  ret i64 24

typeswitch.body24:                                ; preds = %if.then
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %9, i64 48, i1 false)
  ret i64 25

typeswitch.body25:                                ; preds = %if.then
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 8, i1 false)
  ret i64 26

typeswitch.body26:                                ; preds = %if.then
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %9, i64 56, i1 false)
  ret i64 27

typeswitch.done:                                  ; preds = %if.then
  br label %if.done

if.done:                                          ; preds = %typeswitch.done, %entry
  ret i64 0
}

define internal void @"runtime::default_temp_allocator_temp_end"(ptr %0, ptr %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %2 = load %"runtime::Arena_Temp", ptr %0, align 8
  %3 = load %"runtime::Source_Code_Location", ptr %1, align 8
  call void @"runtime::arena_temp_end"(ptr %0, ptr %1, ptr %__.context_ptr)
  ret void
}

define internal i64 @"utf8::decode_rune_in_bytes"({ ptr, i64 } %0, ptr noalias nonnull %1) {
decls:
  %2 = alloca { ptr, i64 }, align 8
  %n = alloca i64, align 8
  %s0 = alloca i8, align 1
  %x = alloca i8, align 1
  %mask = alloca i32, align 4
  %sz = alloca i8, align 1
  %accept = alloca %"utf8::Accept_Range", align 1
  %b1 = alloca i8, align 1
  %b2 = alloca i8, align 1
  %b3 = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %2, align 8
  %3 = extractvalue { ptr, i64 } %0, 1
  store i64 %3, ptr %n, align 8
  %4 = load i64, ptr %n, align 8
  %5 = icmp slt i64 %4, 1
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store i32 65533, ptr %1, align 4
  ret i64 0

if.done:                                          ; preds = %entry
  %8 = extractvalue { ptr, i64 } %0, 0
  %9 = extractvalue { ptr, i64 } %0, 1
  %10 = getelementptr i8, ptr %8, i64 0
  %11 = load i8, ptr %10, align 1
  store i8 %11, ptr %s0, align 1
  %12 = load i8, ptr %s0, align 1
  %13 = zext i8 %12 to i64
  %14 = getelementptr [256 x i8], ptr @"utf8::accept_sizes", i64 0, i64 %13
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1fa", i64 41 }, i32 113, i32 20, i64 %13, i64 256)
  %15 = load i8, ptr %14, align 1
  store i8 %15, ptr %x, align 1
  %16 = load i8, ptr %x, align 1
  %17 = icmp uge i8 %16, -16
  %18 = zext i1 %17 to i8
  %19 = icmp ne i8 %18, 0
  br i1 %19, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.done
  %20 = load i8, ptr %x, align 1
  %21 = zext i8 %20 to i32
  %22 = shl i32 %21, 31
  %23 = select i1 true, i32 %22, i32 0
  %24 = ashr i32 %23, 31
  %25 = select i1 true, i32 %24, i32 0
  store i32 %25, ptr %mask, align 4
  %26 = extractvalue { ptr, i64 } %0, 0
  %27 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1fa", i64 41 }, i32 116, i32 17, i64 0, i64 %27)
  %28 = getelementptr i8, ptr %26, i64 0
  %29 = load i8, ptr %28, align 1
  %30 = zext i8 %29 to i32
  %31 = load i32, ptr %mask, align 4
  %32 = xor i32 %31, -1
  %33 = and i32 %30, %32
  %34 = load i32, ptr %mask, align 4
  %35 = and i32 65533, %34
  %36 = or i32 %33, %35
  store i32 %36, ptr %1, align 4
  ret i64 1

if.done2:                                         ; preds = %if.done
  %37 = load i8, ptr %x, align 1
  %38 = and i8 %37, 7
  store i8 %38, ptr %sz, align 1
  %39 = load i8, ptr %x, align 1
  %40 = lshr i8 %39, 4
  %41 = select i1 true, i8 %40, i8 0
  %42 = zext i8 %41 to i64
  %43 = getelementptr [5 x %"utf8::Accept_Range"], ptr @"utf8::accept_ranges", i64 0, i64 %42
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1fa", i64 41 }, i32 119, i32 26, i64 %42, i64 5)
  %44 = load %"utf8::Accept_Range", ptr %43, align 1
  store %"utf8::Accept_Range" %44, ptr %accept, align 1
  %45 = load i64, ptr %n, align 8
  %46 = load i8, ptr %sz, align 1
  %47 = zext i8 %46 to i64
  %48 = icmp slt i64 %45, %47
  %49 = zext i1 %48 to i8
  %50 = icmp ne i8 %49, 0
  br i1 %50, label %if.then3, label %if.done4

if.then3:                                         ; preds = %if.done2
  store i32 65533, ptr %1, align 4
  ret i64 1

if.done4:                                         ; preds = %if.done2
  %51 = extractvalue { ptr, i64 } %0, 0
  %52 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1fa", i64 41 }, i32 123, i32 10, i64 1, i64 %52)
  %53 = getelementptr i8, ptr %51, i64 1
  %54 = load i8, ptr %53, align 1
  store i8 %54, ptr %b1, align 1
  %55 = load i8, ptr %b1, align 1
  %56 = getelementptr inbounds nuw %"utf8::Accept_Range", ptr %accept, i32 0, i32 0
  %57 = load i8, ptr %56, align 1
  %58 = icmp ult i8 %55, %57
  %59 = zext i1 %58 to i8
  %60 = icmp ne i8 %59, 0
  br i1 %60, label %if.then5, label %cmp.or

cmp.or:                                           ; preds = %if.done4
  %61 = getelementptr inbounds nuw %"utf8::Accept_Range", ptr %accept, i32 0, i32 1
  %62 = load i8, ptr %61, align 1
  %63 = load i8, ptr %b1, align 1
  %64 = icmp ult i8 %62, %63
  %65 = zext i1 %64 to i8
  %66 = icmp ne i8 %65, 0
  br i1 %66, label %if.then5, label %if.done6

if.then5:                                         ; preds = %cmp.or, %if.done4
  store i32 65533, ptr %1, align 4
  ret i64 1

if.done6:                                         ; preds = %cmp.or
  %67 = load i8, ptr %sz, align 1
  %68 = icmp eq i8 %67, 2
  %69 = zext i1 %68 to i8
  %70 = icmp ne i8 %69, 0
  br i1 %70, label %if.then7, label %if.done8

if.then7:                                         ; preds = %if.done6
  %71 = load i8, ptr %s0, align 1
  %72 = and i8 %71, 31
  %73 = zext i8 %72 to i32
  %74 = shl i32 %73, 6
  %75 = select i1 true, i32 %74, i32 0
  %76 = load i8, ptr %b1, align 1
  %77 = and i8 %76, 63
  %78 = zext i8 %77 to i32
  %79 = or i32 %75, %78
  store i32 %79, ptr %1, align 4
  ret i64 2

if.done8:                                         ; preds = %if.done6
  %80 = extractvalue { ptr, i64 } %0, 0
  %81 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1fa", i64 41 }, i32 130, i32 10, i64 2, i64 %81)
  %82 = getelementptr i8, ptr %80, i64 2
  %83 = load i8, ptr %82, align 1
  store i8 %83, ptr %b2, align 1
  %84 = load i8, ptr %b2, align 1
  %85 = icmp ult i8 %84, -128
  %86 = zext i1 %85 to i8
  %87 = icmp ne i8 %86, 0
  br i1 %87, label %if.then10, label %cmp.or9

cmp.or9:                                          ; preds = %if.done8
  %88 = load i8, ptr %b2, align 1
  %89 = icmp ult i8 -65, %88
  %90 = zext i1 %89 to i8
  %91 = icmp ne i8 %90, 0
  br i1 %91, label %if.then10, label %if.done11

if.then10:                                        ; preds = %cmp.or9, %if.done8
  store i32 65533, ptr %1, align 4
  ret i64 1

if.done11:                                        ; preds = %cmp.or9
  %92 = load i8, ptr %sz, align 1
  %93 = icmp eq i8 %92, 3
  %94 = zext i1 %93 to i8
  %95 = icmp ne i8 %94, 0
  br i1 %95, label %if.then12, label %if.done13

if.then12:                                        ; preds = %if.done11
  %96 = load i8, ptr %s0, align 1
  %97 = and i8 %96, 15
  %98 = zext i8 %97 to i32
  %99 = shl i32 %98, 12
  %100 = select i1 true, i32 %99, i32 0
  %101 = load i8, ptr %b1, align 1
  %102 = and i8 %101, 63
  %103 = zext i8 %102 to i32
  %104 = shl i32 %103, 6
  %105 = select i1 true, i32 %104, i32 0
  %106 = or i32 %100, %105
  %107 = load i8, ptr %b2, align 1
  %108 = and i8 %107, 63
  %109 = zext i8 %108 to i32
  %110 = or i32 %106, %109
  store i32 %110, ptr %1, align 4
  ret i64 3

if.done13:                                        ; preds = %if.done11
  %111 = extractvalue { ptr, i64 } %0, 0
  %112 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1fa", i64 41 }, i32 137, i32 10, i64 3, i64 %112)
  %113 = getelementptr i8, ptr %111, i64 3
  %114 = load i8, ptr %113, align 1
  store i8 %114, ptr %b3, align 1
  %115 = load i8, ptr %b3, align 1
  %116 = icmp ult i8 %115, -128
  %117 = zext i1 %116 to i8
  %118 = icmp ne i8 %117, 0
  br i1 %118, label %if.then15, label %cmp.or14

cmp.or14:                                         ; preds = %if.done13
  %119 = load i8, ptr %b3, align 1
  %120 = icmp ult i8 -65, %119
  %121 = zext i1 %120 to i8
  %122 = icmp ne i8 %121, 0
  br i1 %122, label %if.then15, label %if.done16

if.then15:                                        ; preds = %cmp.or14, %if.done13
  store i32 65533, ptr %1, align 4
  ret i64 1

if.done16:                                        ; preds = %cmp.or14
  %123 = load i8, ptr %s0, align 1
  %124 = and i8 %123, 7
  %125 = zext i8 %124 to i32
  %126 = shl i32 %125, 18
  %127 = select i1 true, i32 %126, i32 0
  %128 = load i8, ptr %b1, align 1
  %129 = and i8 %128, 63
  %130 = zext i8 %129 to i32
  %131 = shl i32 %130, 12
  %132 = select i1 true, i32 %131, i32 0
  %133 = or i32 %127, %132
  %134 = load i8, ptr %b2, align 1
  %135 = and i8 %134, 63
  %136 = zext i8 %135 to i32
  %137 = shl i32 %136, 6
  %138 = select i1 true, i32 %137, i32 0
  %139 = or i32 %133, %138
  %140 = load i8, ptr %b3, align 1
  %141 = and i8 %140, 63
  %142 = zext i8 %141 to i32
  %143 = or i32 %139, %142
  store i32 %143, ptr %1, align 4
  ret i64 4
}

define internal i64 @"fmt::println"({ ptr, i64 } %0, %..string %1, i8 %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca { ptr, i64 }, align 8
  %4 = alloca %..string, align 8
  %5 = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %3, align 8
  store %..string %1, ptr %4, align 8
  store i8 %2, ptr %5, align 1
  %6 = load i32, ptr @"os::stdout", align 4
  %7 = call i64 @"fmt::fprintln"(i32 %6, { ptr, i64 } %0, %..string %1, i8 %2, ptr %__.context_ptr)
  ret i64 %7
}

; Function Attrs: alwaysinline
define internal i64 @"linux::syscall2:proc\22contextless\22(nr:uintptr,p1:linux::Clock_Id,p2:^linux::Time_Spec)->(:int)"(i64 %0, i64 %1, ptr %2) #3 {
decls:
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %3, align 8
  store i64 %1, ptr %4, align 8
  store ptr %2, ptr %5, align 8
  %6 = ptrtoint ptr %2 to i64
  %7 = call i64 asm sideeffect "syscall", "={rax},{rax},{rdi},{rsi},~{rcx},~{r11},~{memory}"(i64 %0, i64 %1, i64 %6)
  ret i64 %7
}

; Function Attrs: alwaysinline
define internal i64 @"linux::syscall3:proc\22contextless\22(nr:uintptr,p1:^u32,p2:u32,p3:i32)->(:int)"(i64 %0, ptr %1, i32 %2, i32 %3) #3 {
decls:
  %4 = alloca i64, align 8
  %5 = alloca ptr, align 8
  %6 = alloca i32, align 4
  %7 = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %4, align 8
  store ptr %1, ptr %5, align 8
  store i32 %2, ptr %6, align 4
  store i32 %3, ptr %7, align 4
  %8 = ptrtoint ptr %1 to i64
  %9 = zext i32 %2 to i64
  %10 = sext i32 %3 to i64
  %11 = call i64 asm sideeffect "syscall", "={rax},{rax},{rdi},{rsi},{rdx},~{rcx},~{r11},~{memory}"(i64 %0, i64 %8, i64 %9, i64 %10)
  ret i64 %11
}

define internal ptr @"runtime::memset"(ptr %0, i32 %1, i64 %2) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca i32, align 4
  %5 = alloca i64, align 8
  %b = alloca i8, align 1
  %p = alloca ptr, align 8
  %i = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store i32 %1, ptr %4, align 4
  store i64 %2, ptr %5, align 8
  %6 = icmp ne ptr %0, null
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %entry
  %9 = icmp ne i64 %2, 0
  %10 = zext i1 %9 to i8
  %11 = icmp ne i8 %10, 0
  br i1 %11, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and
  %12 = trunc i32 %1 to i8
  store i8 %12, ptr %b, align 1
  store ptr %0, ptr %p, align 8
  br label %for.init

for.init:                                         ; preds = %if.then
  store i64 0, ptr %i, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %for.init
  %13 = load i64, ptr %i, align 8
  %14 = icmp slt i64 %13, %2
  %15 = zext i1 %14 to i8
  %16 = icmp ne i8 %15, 0
  br i1 %16, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %17 = load ptr, ptr %p, align 8
  %18 = load i64, ptr %i, align 8
  %19 = getelementptr i8, ptr %17, i64 %18
  %20 = load i8, ptr %b, align 1
  store i8 %20, ptr %19, align 1
  br label %for.post

for.post:                                         ; preds = %for.body
  %21 = load i64, ptr %i, align 8
  %22 = add i64 %21, 1
  store i64 %22, ptr %i, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  br label %if.done

if.done:                                          ; preds = %for.done, %cmp.and, %entry
  ret ptr %0
}

; Function Attrs: alwaysinline
define internal i64 @"linux::syscall4:proc\22contextless\22(nr:uintptr,p1:^u32,p2:u32,p3:u32,p4:^linux::Time_Spec)->(:int)"(i64 %0, ptr %1, i32 %2, i32 %3, ptr %4) #3 {
decls:
  %5 = alloca i64, align 8
  %6 = alloca ptr, align 8
  %7 = alloca i32, align 4
  %8 = alloca i32, align 4
  %9 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %5, align 8
  store ptr %1, ptr %6, align 8
  store i32 %2, ptr %7, align 4
  store i32 %3, ptr %8, align 4
  store ptr %4, ptr %9, align 8
  %10 = ptrtoint ptr %1 to i64
  %11 = zext i32 %2 to i64
  %12 = zext i32 %3 to i64
  %13 = ptrtoint ptr %4 to i64
  %14 = call i64 asm sideeffect "syscall", "={rax},{rax},{rdi},{rsi},{rdx},{r10},~{rcx},~{r11},~{memory}"(i64 %0, i64 %10, i64 %11, i64 %12, i64 %13)
  ret i64 %14
}

define internal i64 @"io::query"({ i64, i64 } %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca %"io::Stream", align 16
  %set = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca { i64, i32 }, align 8
  %n = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %1, align 8
  %4 = load %"io::Stream", ptr %1, align 8
  store i64 0, ptr %set, align 8
  %5 = getelementptr inbounds nuw %"io::Stream", ptr %1, i32 0, i32 0
  %6 = load ptr, ptr %5, align 8
  %7 = icmp ne ptr %6, null
  %8 = zext i1 %7 to i8
  %9 = icmp ne i8 %8, 0
  br i1 %9, label %if.then, label %if.done2

if.then:                                          ; preds = %entry
  %10 = getelementptr inbounds nuw %"io::Stream", ptr %1, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr inbounds nuw %"io::Stream", ptr %1, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store i64 0, ptr %2, align 8
  %14 = call i32 %11(ptr %13, i64 9, { ptr, i64 } zeroinitializer, i64 0, i64 0, ptr %2, ptr %__.context_ptr)
  %15 = load i64, ptr %2, align 8
  %16 = load { i64, i32 }, ptr %3, align 8
  store i64 %15, ptr %n, align 8
  %17 = load i64, ptr %n, align 8
  store i64 %17, ptr %set, align 8
  %18 = load i64, ptr %set, align 8
  %19 = icmp ne i64 %18, 0
  %20 = zext i1 %19 to i8
  %21 = icmp ne i8 %20, 0
  br i1 %21, label %if.then1, label %if.done

if.then1:                                         ; preds = %if.then
  %22 = load i64, ptr %set, align 8
  %23 = or i64 %22, 512
  store i64 %23, ptr %set, align 8
  br label %if.done

if.done:                                          ; preds = %if.then1, %if.then
  br label %if.done2

if.done2:                                         ; preds = %if.done, %entry
  %24 = load i64, ptr %set, align 8
  store i64 %24, ptr %set, align 8
  ret i64 %24
}

define internal ptr @"runtime::mem_copy_non_overlapping"(ptr %0, ptr %1, i64 %2) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store ptr %1, ptr %4, align 8
  store i64 %2, ptr %5, align 8
  %6 = icmp ne ptr %1, null
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %entry
  %9 = icmp ne ptr %0, %1
  %10 = zext i1 %9 to i8
  %11 = icmp ne i8 %10, 0
  br i1 %11, label %cmp.and1, label %if.done

cmp.and1:                                         ; preds = %cmp.and
  %12 = icmp sgt i64 %2, 0
  %13 = zext i1 %12 to i8
  %14 = icmp ne i8 %13, 0
  br i1 %14, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and1
  call void @llvm.memcpy.p0.p0.i64(ptr %0, ptr %1, i64 %2, i1 false)
  br label %if.done

if.done:                                          ; preds = %if.then, %cmp.and1, %cmp.and, %entry
  ret ptr %0
}

define internal i8 @"os::read_entire_file_from_filename"(%..string %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca %..string, align 8
  %5 = alloca %"runtime::Allocator", align 16
  %data = alloca { ptr, i64 }, align 8
  %success = alloca i8, align 1
  %err = alloca %"os::Error", align 4
  %6 = alloca { i64, i64 }, align 16
  %7 = alloca { ptr, i64 }, align 8
  %8 = alloca %"os::Error", align 16
  %9 = alloca { { ptr, i64 }, %"os::Error" }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %4, align 8
  store { i64, i64 } %1, ptr %5, align 8
  %10 = load %"runtime::Allocator", ptr %5, align 8
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  store i8 0, ptr %success, align 1
  call void @llvm.memset.inline.p0.i64(ptr %err, i8 0, i64 8, i1 false)
  %11 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %10, ptr %6, align 8
  %12 = load { i64, i64 }, ptr %6, align 8
  call void @llvm.memset.inline.p0.i64(ptr %7, i8 0, i64 16, i1 false)
  %13 = call i64 @"os::read_entire_file_from_filename_or_err"(%..string %0, { i64, i64 } %12, ptr %2, ptr %7, ptr %__.context_ptr)
  store i64 %13, ptr %8, align 8
  %14 = load %"os::Error", ptr %8, align 4
  %15 = load { ptr, i64 }, ptr %7, align 8
  %16 = load { { ptr, i64 }, %"os::Error" }, ptr %9, align 8
  store { ptr, i64 } %15, ptr %data, align 8
  store %"os::Error" %14, ptr %err, align 4
  %17 = load %"os::Error", ptr %err, align 4
  %18 = getelementptr inbounds nuw %"os::Error", ptr %err, i32 0, i32 1
  %19 = load i32, ptr %18, align 4
  %20 = icmp eq i32 %19, 0
  %21 = zext i1 %20 to i8
  store i8 %21, ptr %success, align 1
  %22 = load { ptr, i64 }, ptr %data, align 8
  %23 = load i8, ptr %success, align 1
  store { ptr, i64 } %22, ptr %data, align 8
  store i8 %23, ptr %success, align 1
  store { ptr, i64 } %22, ptr %3, align 8
  ret i8 %23
}

; Function Attrs: alwaysinline
define internal void @"runtime::DEFAULT_TEMP_ALLOCATOR_TEMP_GUARD"(ptr noalias sret(%"runtime::Source_Code_Location") %agg.result, i8 %0, ptr %1, ptr noalias nonnull %2, ptr noalias nonnull "captures"="none" %__.context_ptr) #3 {
decls:
  %3 = alloca i8, align 1
  %4 = alloca %"runtime::Arena_Temp", align 8
  br label %entry

entry:                                            ; preds = %decls
  store i8 %0, ptr %3, align 1
  %5 = icmp ne i8 %0, 0
  br i1 %5, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load %"runtime::Source_Code_Location", ptr %1, align 8
  store %"runtime::Arena_Temp" zeroinitializer, ptr %2, align 8
  store %"runtime::Source_Code_Location" %6, ptr %agg.result, align 8
  ret void

if.else:                                          ; preds = %entry
  %7 = load %"runtime::Source_Code_Location", ptr %1, align 8
  call void @llvm.memset.inline.p0.i64(ptr %4, i8 0, i64 24, i1 false)
  call void @"runtime::default_temp_allocator_temp_begin"(ptr sret(ptr) %4, ptr %1, ptr %__.context_ptr)
  %8 = load %"runtime::Arena_Temp", ptr %4, align 8
  %9 = load %"runtime::Source_Code_Location", ptr %1, align 8
  store %"runtime::Arena_Temp" %8, ptr %2, align 8
  store %"runtime::Source_Code_Location" %9, ptr %agg.result, align 8
  ret void

if.done:                                          ; No predecessors!
  unreachable
}

; Function Attrs: alwaysinline
define internal i32 @"io::query_utility"(i64 %0, ptr noalias nonnull %1) #3 {
decls:
  %2 = alloca i64, align 8
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %2, align 8
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  store i64 %0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  store i64 %0, ptr %1, align 8
  ret i32 0
}

; Function Attrs: noinline
define internal i64 @"runtime::print_string"(%..string %0) #4 {
decls:
  %1 = alloca %..string, align 8
  %n = alloca i64, align 8
  %2 = alloca %..string, align 8
  %3 = alloca i64, align 8
  %4 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %1, align 8
  store i64 0, ptr %n, align 8
  store %..string %0, ptr %2, align 8
  %5 = load { ptr, i64 }, ptr %2, align 8
  store i64 0, ptr %3, align 8
  %6 = call i64 @"runtime::stderr_write"({ ptr, i64 } %5, ptr %3)
  %7 = load i64, ptr %3, align 8
  %8 = load { i64, i64 }, ptr %4, align 8
  store i64 %7, ptr %n, align 8
  %9 = load i64, ptr %n, align 8
  store i64 %9, ptr %n, align 8
  ret i64 %9
}

; Function Attrs: noinline
define internal i8 @"runtime::mem_alloc_bytes"(i64 %0, i64 %1, { i64, i64 } %2, ptr %3, ptr noalias nonnull %4, ptr noalias nonnull "captures"="none" %__.context_ptr) #4 {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca %"runtime::Allocator", align 16
  %8 = alloca { ptr, i64 }, align 8
  %9 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %5, align 8
  store i64 %1, ptr %6, align 8
  store { i64, i64 } %2, ptr %7, align 8
  %10 = load %"runtime::Allocator", ptr %7, align 8
  %11 = call i8 @"runtime::is_power_of_two_int"(i64 %1)
  %12 = load %"runtime::Source_Code_Location", ptr %3, align 8
  call void @"runtime::assert"(i8 %11, %..string { ptr @"csbs$byte_world$1fb", i64 32 }, ptr %3, ptr %__.context_ptr)
  %13 = icmp eq i64 %0, 0
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %entry
  %16 = getelementptr inbounds nuw %"runtime::Allocator", ptr %7, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = icmp eq ptr %17, null
  %19 = zext i1 %18 to i8
  %20 = icmp ne i8 %19, 0
  br i1 %20, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %entry
  store { ptr, i64 } zeroinitializer, ptr %4, align 8
  ret i8 0

if.done:                                          ; preds = %cmp.or
  %21 = getelementptr inbounds nuw %"runtime::Allocator", ptr %7, i32 0, i32 0
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr inbounds nuw %"runtime::Allocator", ptr %7, i32 0, i32 1
  %24 = load ptr, ptr %23, align 8
  %25 = load %"runtime::Source_Code_Location", ptr %3, align 8
  call void @llvm.memset.inline.p0.i64(ptr %8, i8 0, i64 16, i1 false)
  %26 = call i8 %22(ptr %24, i8 0, i64 %0, i64 %1, ptr null, i64 0, ptr %3, ptr %8, ptr %__.context_ptr)
  %27 = load { ptr, i64 }, ptr %8, align 8
  %28 = load { { ptr, i64 }, i8 }, ptr %9, align 8
  store { ptr, i64 } %27, ptr %4, align 8
  ret i8 %26
}

define internal i8 @"mem::nil_allocator_proc"(ptr %0, i8 %1, i64 %2, i64 %3, ptr %4, i64 %5, ptr %6, ptr noalias nonnull %7, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %8 = alloca ptr, align 8
  %9 = alloca i8, align 1
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca ptr, align 8
  %13 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %8, align 8
  store i8 %1, ptr %9, align 1
  store i64 %2, ptr %10, align 8
  store i64 %3, ptr %11, align 8
  store ptr %4, ptr %12, align 8
  store i64 %5, ptr %13, align 8
  store { ptr, i64 } zeroinitializer, ptr %7, align 8
  ret i8 0
}

define internal i8 @"runtime::arena_alloc"(ptr %0, i64 %1, i64 %2, ptr %3, ptr noalias nonnull %4, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %5 = alloca ptr, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %size = alloca i64, align 8
  %prev_used = alloca i64, align 8
  %8 = alloca { ptr, i64 }, align 8
  %9 = alloca { { ptr, i64 }, i8 }, align 8
  %needed = alloca i64, align 8
  %block_size = alloca i64, align 8
  %10 = alloca %"runtime::Allocator", align 16
  %11 = alloca { i64, i64 }, align 16
  %12 = alloca ptr, align 8
  %13 = alloca { ptr, i8 }, align 8
  %new_block = alloca ptr, align 8
  %14 = alloca { ptr, i64 }, align 8
  %15 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %5, align 8
  store i64 %1, ptr %6, align 8
  store i64 %2, ptr %7, align 8
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %16 = sub i64 %2, 1
  %17 = and i64 %2, %16
  %18 = icmp eq i64 %17, 0
  %19 = zext i1 %18 to i8
  %20 = load %"runtime::Source_Code_Location", ptr %3, align 8
  call void @"runtime::assert"(i8 %19, %..string { ptr @"csbs$byte_world$1fc", i64 26 }, ptr %3, ptr %__.context_ptr)
  store i64 %1, ptr %size, align 8
  %21 = load i64, ptr %size, align 8
  %22 = icmp eq i64 %21, 0
  %23 = zext i1 %22 to i8
  %24 = icmp ne i8 %23, 0
  br i1 %24, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %25 = load { ptr, i64 }, ptr %data, align 8
  %26 = load i8, ptr %err, align 1
  store { ptr, i64 } %25, ptr %data, align 8
  store i8 %26, ptr %err, align 1
  store { ptr, i64 } %25, ptr %4, align 8
  ret i8 %26

if.done:                                          ; preds = %entry
  %27 = load ptr, ptr %5, align 8
  %28 = getelementptr inbounds nuw %"runtime::Arena", ptr %27, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  %30 = icmp eq ptr %29, null
  %31 = zext i1 %30 to i8
  %32 = icmp ne i8 %31, 0
  br i1 %32, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.done
  br label %if.done2

if.else:                                          ; preds = %if.done
  %33 = load ptr, ptr %5, align 8
  %34 = getelementptr inbounds nuw %"runtime::Arena", ptr %33, i32 0, i32 1
  %35 = load ptr, ptr %34, align 8
  %36 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %35, i32 0, i32 3
  %37 = load i64, ptr %36, align 8
  br label %if.done2

if.done2:                                         ; preds = %if.else, %if.then1
  %38 = phi i64 [ 0, %if.then1 ], [ %37, %if.else ]
  store i64 %38, ptr %prev_used, align 8
  %39 = load ptr, ptr %5, align 8
  %40 = getelementptr inbounds nuw %"runtime::Arena", ptr %39, i32 0, i32 1
  %41 = load ptr, ptr %40, align 8
  %42 = load i64, ptr %size, align 8
  call void @llvm.memset.inline.p0.i64(ptr %8, i8 0, i64 16, i1 false)
  %43 = call i8 @"runtime::alloc_from_memory_block"(ptr %41, i64 %42, i64 %2, ptr %8, ptr %__.context_ptr)
  %44 = load { ptr, i64 }, ptr %8, align 8
  %45 = load { { ptr, i64 }, i8 }, ptr %9, align 8
  store { ptr, i64 } %44, ptr %data, align 8
  store i8 %43, ptr %err, align 1
  %46 = load i8, ptr %err, align 1
  %47 = icmp eq i8 %46, 1
  %48 = zext i1 %47 to i8
  %49 = icmp ne i8 %48, 0
  br i1 %49, label %if.then3, label %if.done8

if.then3:                                         ; preds = %if.done2
  %50 = load ptr, ptr %5, align 8
  %51 = getelementptr inbounds nuw %"runtime::Arena", ptr %50, i32 0, i32 4
  %52 = load i64, ptr %51, align 8
  %53 = icmp eq i64 %52, 0
  %54 = zext i1 %53 to i8
  %55 = icmp ne i8 %54, 0
  br i1 %55, label %if.then4, label %if.done5

if.then4:                                         ; preds = %if.then3
  %56 = load ptr, ptr %5, align 8
  %57 = getelementptr inbounds nuw %"runtime::Arena", ptr %56, i32 0, i32 4
  store i64 4194304, ptr %57, align 8
  br label %if.done5

if.done5:                                         ; preds = %if.then4, %if.then3
  %58 = load i64, ptr %size, align 8
  %59 = call i64 @"runtime::arena_alloc.align_forward_uint-0"(i64 %58, i64 %2)
  store i64 %59, ptr %needed, align 8
  %60 = load i64, ptr %needed, align 8
  %61 = load ptr, ptr %5, align 8
  %62 = getelementptr inbounds nuw %"runtime::Arena", ptr %61, i32 0, i32 4
  %63 = load i64, ptr %62, align 8
  %64 = icmp ugt i64 %60, %63
  %65 = select i1 %64, i64 %60, i64 %63
  store i64 %65, ptr %block_size, align 8
  %66 = load ptr, ptr %5, align 8
  %67 = getelementptr inbounds nuw %"runtime::Arena", ptr %66, i32 0, i32 0
  %68 = getelementptr inbounds nuw %"runtime::Allocator", ptr %67, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  %70 = icmp eq ptr %69, null
  %71 = zext i1 %70 to i8
  %72 = icmp ne i8 %71, 0
  br i1 %72, label %if.then6, label %if.done7

if.then6:                                         ; preds = %if.done5
  %73 = load ptr, ptr %5, align 8
  %74 = getelementptr inbounds nuw %"runtime::Arena", ptr %73, i32 0, i32 0
  %75 = call { i64, i64 } @"runtime::heap_allocator"(ptr %__.context_ptr)
  store { i64, i64 } %75, ptr %10, align 8
  %76 = load %"runtime::Allocator", ptr %10, align 8
  store %"runtime::Allocator" %76, ptr %74, align 8
  br label %if.done7

if.done7:                                         ; preds = %if.then6, %if.done5
  %77 = load ptr, ptr %5, align 8
  %78 = getelementptr inbounds nuw %"runtime::Arena", ptr %77, i32 0, i32 0
  %79 = load %"runtime::Allocator", ptr %78, align 8
  %80 = load i64, ptr %block_size, align 8
  %81 = load %"runtime::Source_Code_Location", ptr %3, align 8
  store %"runtime::Allocator" %79, ptr %11, align 8
  %82 = load { i64, i64 }, ptr %11, align 8
  store ptr null, ptr %12, align 8
  %83 = call i8 @"runtime::memory_block_alloc"({ i64, i64 } %82, i64 %80, i64 %2, ptr %3, ptr %12, ptr %__.context_ptr)
  %84 = load ptr, ptr %12, align 8
  %85 = load { ptr, i8 }, ptr %13, align 8
  %86 = icmp eq i8 %83, 0
  br i1 %86, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %if.done7
  store i8 %83, ptr %err, align 1
  %87 = load { ptr, i64 }, ptr %data, align 8
  %88 = load i8, ptr %err, align 1
  store { ptr, i64 } %87, ptr %data, align 8
  store i8 %88, ptr %err, align 1
  store { ptr, i64 } %87, ptr %4, align 8
  ret i8 %88

or_return.continue:                               ; preds = %if.done7
  store ptr %84, ptr %new_block, align 8
  %89 = load ptr, ptr %new_block, align 8
  %90 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %89, i32 0, i32 0
  %91 = load ptr, ptr %5, align 8
  %92 = getelementptr inbounds nuw %"runtime::Arena", ptr %91, i32 0, i32 1
  %93 = load ptr, ptr %92, align 8
  store ptr %93, ptr %90, align 8
  %94 = load ptr, ptr %5, align 8
  %95 = getelementptr inbounds nuw %"runtime::Arena", ptr %94, i32 0, i32 1
  %96 = load ptr, ptr %new_block, align 8
  store ptr %96, ptr %95, align 8
  %97 = load ptr, ptr %5, align 8
  %98 = getelementptr inbounds nuw %"runtime::Arena", ptr %97, i32 0, i32 3
  %99 = load ptr, ptr %new_block, align 8
  %100 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %99, i32 0, i32 4
  %101 = load i64, ptr %100, align 8
  %102 = load i64, ptr %98, align 8
  %103 = add i64 %102, %101
  store i64 %103, ptr %98, align 8
  store i64 0, ptr %prev_used, align 8
  %104 = load ptr, ptr %5, align 8
  %105 = getelementptr inbounds nuw %"runtime::Arena", ptr %104, i32 0, i32 1
  %106 = load ptr, ptr %105, align 8
  %107 = load i64, ptr %size, align 8
  call void @llvm.memset.inline.p0.i64(ptr %14, i8 0, i64 16, i1 false)
  %108 = call i8 @"runtime::alloc_from_memory_block"(ptr %106, i64 %107, i64 %2, ptr %14, ptr %__.context_ptr)
  %109 = load { ptr, i64 }, ptr %14, align 8
  %110 = load { { ptr, i64 }, i8 }, ptr %15, align 8
  store { ptr, i64 } %109, ptr %data, align 8
  store i8 %108, ptr %err, align 1
  br label %if.done8

if.done8:                                         ; preds = %or_return.continue, %if.done2
  %111 = load ptr, ptr %5, align 8
  %112 = getelementptr inbounds nuw %"runtime::Arena", ptr %111, i32 0, i32 2
  %113 = load ptr, ptr %5, align 8
  %114 = getelementptr inbounds nuw %"runtime::Arena", ptr %113, i32 0, i32 1
  %115 = load ptr, ptr %114, align 8
  %116 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %115, i32 0, i32 3
  %117 = load i64, ptr %116, align 8
  %118 = load i64, ptr %prev_used, align 8
  %119 = sub i64 %117, %118
  %120 = load i64, ptr %112, align 8
  %121 = add i64 %120, %119
  store i64 %121, ptr %112, align 8
  %122 = load { ptr, i64 }, ptr %data, align 8
  %123 = load i8, ptr %err, align 1
  store { ptr, i64 } %122, ptr %data, align 8
  store i8 %123, ptr %err, align 1
  store { ptr, i64 } %122, ptr %4, align 8
  ret i8 %123
}

define internal i8 @"strconv::is_integer_negative_128"(i128 %0, i8 %1, i64 %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca i128, align 16
  %5 = alloca i8, align 1
  %6 = alloca i64, align 8
  %u = alloca i128, align 16
  %neg = alloca i8, align 1
  %i = alloca i8, align 1
  %i2 = alloca i16, align 2
  %i4 = alloca i32, align 4
  %i6 = alloca i64, align 8
  %i8 = alloca i128, align 16
  br label %entry

entry:                                            ; preds = %decls
  store i128 %0, ptr %4, align 16
  store i8 %1, ptr %5, align 1
  store i64 %2, ptr %6, align 8
  store i128 0, ptr %u, align 16
  store i8 0, ptr %neg, align 1
  store i128 %0, ptr %u, align 16
  %7 = icmp ne i8 %1, 0
  br i1 %7, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  switch i64 %2, label %switch.default.body [
    i64 8, label %switch.case.body
    i64 16, label %switch.case.body1
    i64 32, label %switch.case.body3
    i64 64, label %switch.case.body5
    i64 128, label %switch.case.body7
  ]

switch.case.body:                                 ; preds = %if.then
  %8 = load i128, ptr %u, align 16
  %9 = trunc i128 %8 to i8
  store i8 %9, ptr %i, align 1
  %10 = load i8, ptr %i, align 1
  %11 = icmp slt i8 %10, 0
  %12 = zext i1 %11 to i8
  store i8 %12, ptr %neg, align 1
  %13 = load i8, ptr %i, align 1
  %14 = sext i8 %13 to i128
  %15 = icmp slt i128 %14, 0
  %16 = sub i128 0, %14
  %17 = select i1 %15, i128 %16, i128 %14
  store i128 %17, ptr %u, align 16
  br label %switch.done

switch.case.body1:                                ; preds = %if.then
  %18 = load i128, ptr %u, align 16
  %19 = trunc i128 %18 to i16
  store i16 %19, ptr %i2, align 2
  %20 = load i16, ptr %i2, align 2
  %21 = icmp slt i16 %20, 0
  %22 = zext i1 %21 to i8
  store i8 %22, ptr %neg, align 1
  %23 = load i16, ptr %i2, align 2
  %24 = sext i16 %23 to i128
  %25 = icmp slt i128 %24, 0
  %26 = sub i128 0, %24
  %27 = select i1 %25, i128 %26, i128 %24
  store i128 %27, ptr %u, align 16
  br label %switch.done

switch.case.body3:                                ; preds = %if.then
  %28 = load i128, ptr %u, align 16
  %29 = trunc i128 %28 to i32
  store i32 %29, ptr %i4, align 4
  %30 = load i32, ptr %i4, align 4
  %31 = icmp slt i32 %30, 0
  %32 = zext i1 %31 to i8
  store i8 %32, ptr %neg, align 1
  %33 = load i32, ptr %i4, align 4
  %34 = sext i32 %33 to i128
  %35 = icmp slt i128 %34, 0
  %36 = sub i128 0, %34
  %37 = select i1 %35, i128 %36, i128 %34
  store i128 %37, ptr %u, align 16
  br label %switch.done

switch.case.body5:                                ; preds = %if.then
  %38 = load i128, ptr %u, align 16
  %39 = trunc i128 %38 to i64
  store i64 %39, ptr %i6, align 8
  %40 = load i64, ptr %i6, align 8
  %41 = icmp slt i64 %40, 0
  %42 = zext i1 %41 to i8
  store i8 %42, ptr %neg, align 1
  %43 = load i64, ptr %i6, align 8
  %44 = sext i64 %43 to i128
  %45 = icmp slt i128 %44, 0
  %46 = sub i128 0, %44
  %47 = select i1 %45, i128 %46, i128 %44
  store i128 %47, ptr %u, align 16
  br label %switch.done

switch.case.body7:                                ; preds = %if.then
  %48 = load i128, ptr %u, align 16
  store i128 %48, ptr %i8, align 16
  %49 = load i128, ptr %i8, align 16
  %50 = icmp slt i128 %49, 0
  %51 = zext i1 %50 to i8
  store i8 %51, ptr %neg, align 1
  %52 = load i128, ptr %i8, align 16
  %53 = icmp slt i128 %52, 0
  %54 = sub i128 0, %52
  %55 = select i1 %53, i128 %54, i128 %52
  store i128 %55, ptr %u, align 16
  br label %switch.done

switch.default.body:                              ; preds = %if.then
  %56 = load %"runtime::Source_Code_Location", ptr @"scl$[is_integer_negative_1283587]", align 8
  call void @"runtime::panic"(%..string { ptr @"csbs$byte_world$1dc", i64 41 }, ptr @"scl$[is_integer_negative_1283587]", ptr %__.context_ptr)
  unreachable

switch.done:                                      ; preds = %switch.case.body7, %switch.case.body5, %switch.case.body3, %switch.case.body1, %switch.case.body
  br label %if.done

if.done:                                          ; preds = %switch.done, %entry
  %57 = load i128, ptr %u, align 16
  %58 = load i8, ptr %neg, align 1
  store i128 %57, ptr %u, align 16
  store i8 %58, ptr %neg, align 1
  store i128 %57, ptr %3, align 16
  ret i8 %58
}

; Function Attrs: noinline
define internal i64 @"runtime::print_byte"(i8 %0) #4 {
decls:
  %1 = alloca i8, align 1
  %n = alloca i64, align 8
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca [1 x i8], align 16
  %4 = alloca { ptr, i64 }, align 8
  %5 = alloca i64, align 8
  %6 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i8 %0, ptr %1, align 1
  store i64 0, ptr %n, align 8
  call void @llvm.memset.inline.p0.i64(ptr %2, i8 0, i64 16, i1 false)
  store [1 x i8] zeroinitializer, ptr %3, align 1
  %7 = getelementptr inbounds [1 x i8], ptr %3, i64 0, i64 0
  %8 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 0
  store ptr %7, ptr %8, align 8
  %9 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 1
  store i64 1, ptr %9, align 8
  %10 = load { ptr, i64 }, ptr %4, align 8
  %11 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  %13 = getelementptr i8, ptr %12, i64 0
  store i8 %0, ptr %13, align 1
  %14 = extractvalue { ptr, i64 } %10, 1
  %15 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  store ptr %12, ptr %15, align 8
  %16 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  store i64 %14, ptr %16, align 8
  %17 = load { ptr, i64 }, ptr %2, align 8
  store i64 0, ptr %5, align 8
  %18 = call i64 @"runtime::stderr_write"({ ptr, i64 } %17, ptr %5)
  %19 = load i64, ptr %5, align 8
  %20 = load { i64, i64 }, ptr %6, align 8
  store i64 %19, ptr %n, align 8
  %21 = load i64, ptr %n, align 8
  store i64 %21, ptr %n, align 8
  ret i64 %21
}

define internal { ptr, i64 } @"strconv::format_digits"({ ptr, i64 } %0, i8 %1, i8 %2, ptr %3, i64 %4, i8 %5, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %6 = alloca { ptr, i64 }, align 8
  %7 = alloca i8, align 1
  %8 = alloca i8, align 1
  %9 = alloca i64, align 8
  %10 = alloca i8, align 1
  %11 = alloca %"strconv::format_digits::Buffer::$1", align 8
  %b = alloca %"strconv::format_digits::Buffer::$1", align 8
  %prec = alloca i64, align 8
  %12 = alloca { ptr, i64 }, align 8
  %13 = alloca [3 x i8], align 16
  %m = alloca i64, align 8
  %14 = alloca { ptr, i64 }, align 8
  %i = alloca i64, align 8
  %15 = alloca i64, align 8
  %i5 = alloca i64, align 8
  %c = alloca i8, align 1
  %j = alloca i64, align 8
  %16 = alloca { ptr, i64 }, align 8
  %ch = alloca i8, align 1
  %i16 = alloca i64, align 8
  %m17 = alloca i64, align 8
  %17 = alloca { ptr, i64 }, align 8
  %exp = alloca i64, align 8
  %eprec = alloca i64, align 8
  %exp38 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %6, align 8
  store i8 %1, ptr %7, align 1
  store i8 %2, ptr %8, align 1
  store i64 %4, ptr %9, align 8
  store i8 %5, ptr %10, align 1
  call void @llvm.memset.inline.p0.i64(ptr %11, i8 0, i64 24, i1 false)
  store %"strconv::format_digits::Buffer::$1" zeroinitializer, ptr %11, align 8
  %18 = getelementptr inbounds nuw %"strconv::format_digits::Buffer::$1", ptr %11, i32 0, i32 0
  store { ptr, i64 } %0, ptr %18, align 8
  %19 = load %"strconv::format_digits::Buffer::$1", ptr %11, align 8
  store %"strconv::format_digits::Buffer::$1" %19, ptr %b, align 8
  store i64 %4, ptr %prec, align 8
  switch i8 %5, label %switch.default.body45 [
    i8 102, label %switch.case.body
    i8 70, label %switch.case.body
    i8 101, label %switch.case.body9
    i8 69, label %switch.case.body9
    i8 103, label %switch.case.body32
    i8 71, label %switch.case.body32
  ]

switch.case.body:                                 ; preds = %entry, %entry
  %20 = icmp ne i8 %2, 0
  br i1 %20, label %if.then, label %if.else

if.then:                                          ; preds = %switch.case.body
  br label %if.done

if.else:                                          ; preds = %switch.case.body
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then
  %21 = phi i8 [ 45, %if.then ], [ 43, %if.else ]
  call void @llvm.memset.inline.p0.i64(ptr %12, i8 0, i64 16, i1 false)
  call void @llvm.memset.inline.p0.i64(ptr %13, i8 0, i64 3, i1 false)
  %22 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  store i8 %21, ptr %22, align 1
  %23 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  %24 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  store ptr %23, ptr %24, align 8
  %25 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  store i64 1, ptr %25, align 8
  %26 = load { ptr, i64 }, ptr %12, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %26, ptr %__.context_ptr)
  %27 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 2
  %28 = load i64, ptr %27, align 8
  %29 = icmp sgt i64 %28, 0
  %30 = zext i1 %29 to i8
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %if.then1, label %if.else2

if.then1:                                         ; preds = %if.done
  %32 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 1
  %33 = load i64, ptr %32, align 8
  %34 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 2
  %35 = load i64, ptr %34, align 8
  %36 = icmp slt i64 %33, %35
  %37 = select i1 %36, i64 %33, i64 %35
  store i64 %37, ptr %m, align 8
  %38 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 0
  %39 = load { ptr, i64 }, ptr %38, align 8
  %40 = load i64, ptr %m, align 8
  %41 = getelementptr inbounds nuw { ptr, i64 }, ptr %38, i32 0, i32 1
  %42 = load i64, ptr %41, align 8
  call void @"runtime::slice_expr_error_lo_hi"(%..string { ptr @"csbs$byte_world$1e7", i64 45 }, i32 159, i32 31, i64 0, i64 %40, i64 %42)
  %43 = getelementptr inbounds nuw { ptr, i64 }, ptr %38, i32 0, i32 0
  %44 = load ptr, ptr %43, align 8
  %45 = getelementptr i8, ptr %44, i64 0
  %46 = sub i64 %40, 0
  %47 = getelementptr inbounds nuw { ptr, i64 }, ptr %14, i32 0, i32 0
  store ptr %45, ptr %47, align 8
  %48 = getelementptr inbounds nuw { ptr, i64 }, ptr %14, i32 0, i32 1
  store i64 %46, ptr %48, align 8
  %49 = load { ptr, i64 }, ptr %14, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %49, ptr %__.context_ptr)
  br label %for.loop

for.loop:                                         ; preds = %for.post, %if.then1
  %50 = load i64, ptr %m, align 8
  %51 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 2
  %52 = load i64, ptr %51, align 8
  %53 = icmp slt i64 %50, %52
  %54 = zext i1 %53 to i8
  %55 = icmp ne i8 %54, 0
  br i1 %55, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %56 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  store i8 48, ptr %56, align 1
  %57 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  %58 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  store ptr %57, ptr %58, align 8
  %59 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  store i64 1, ptr %59, align 8
  %60 = load { ptr, i64 }, ptr %12, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %60, ptr %__.context_ptr)
  br label %for.post

for.post:                                         ; preds = %for.body
  %61 = load i64, ptr %m, align 8
  %62 = add i64 %61, 1
  store i64 %62, ptr %m, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  br label %if.done3

if.else2:                                         ; preds = %if.done
  %63 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  store i8 48, ptr %63, align 1
  %64 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  %65 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  store ptr %64, ptr %65, align 8
  %66 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  store i64 1, ptr %66, align 8
  %67 = load { ptr, i64 }, ptr %12, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %67, ptr %__.context_ptr)
  br label %if.done3

if.done3:                                         ; preds = %if.else2, %for.done
  %68 = load i64, ptr %prec, align 8
  %69 = icmp sgt i64 %68, 0
  %70 = zext i1 %69 to i8
  %71 = icmp ne i8 %70, 0
  br i1 %71, label %if.then4, label %if.done8

if.then4:                                         ; preds = %if.done3
  %72 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  store i8 46, ptr %72, align 1
  %73 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  %74 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  store ptr %73, ptr %74, align 8
  %75 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  store i64 1, ptr %75, align 8
  %76 = load { ptr, i64 }, ptr %12, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %76, ptr %__.context_ptr)
  store i64 0, ptr %i, align 8
  store i64 0, ptr %15, align 8
  br label %for.interval.loop

for.interval.loop:                                ; preds = %for.interval.post, %if.then4
  %77 = load i64, ptr %prec, align 8
  %78 = load i64, ptr %i, align 8
  %79 = icmp slt i64 %78, %77
  br i1 %79, label %for.interval.body, label %for.interval.done

for.interval.body:                                ; preds = %for.interval.loop
  %80 = load i64, ptr %i, align 8
  %81 = load i64, ptr %15, align 8
  store i64 %80, ptr %i5, align 8
  store i8 48, ptr %c, align 1
  br label %if.init

if.init:                                          ; preds = %for.interval.body
  %82 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 2
  %83 = load i64, ptr %82, align 8
  %84 = load i64, ptr %i5, align 8
  %85 = add i64 %83, %84
  store i64 %85, ptr %j, align 8
  %86 = load i64, ptr %j, align 8
  %87 = icmp sle i64 0, %86
  %88 = zext i1 %87 to i8
  %89 = icmp ne i8 %88, 0
  br i1 %89, label %cmp.and, label %if.done7

cmp.and:                                          ; preds = %if.init
  %90 = load i64, ptr %j, align 8
  %91 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 1
  %92 = load i64, ptr %91, align 8
  %93 = icmp slt i64 %90, %92
  %94 = zext i1 %93 to i8
  %95 = icmp ne i8 %94, 0
  br i1 %95, label %if.then6, label %if.done7

if.then6:                                         ; preds = %cmp.and
  %96 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 0
  %97 = load { ptr, i64 }, ptr %96, align 8
  %98 = getelementptr inbounds nuw { ptr, i64 }, ptr %96, i32 0, i32 0
  %99 = load ptr, ptr %98, align 8
  %100 = load i64, ptr %j, align 8
  %101 = getelementptr inbounds nuw { ptr, i64 }, ptr %96, i32 0, i32 1
  %102 = load i64, ptr %101, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1e7", i64 45 }, i32 174, i32 22, i64 %100, i64 %102)
  %103 = getelementptr i8, ptr %99, i64 %100
  %104 = load i8, ptr %103, align 1
  store i8 %104, ptr %c, align 1
  br label %if.done7

if.done7:                                         ; preds = %if.then6, %cmp.and, %if.init
  %105 = load i8, ptr %c, align 1
  %106 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  store i8 %105, ptr %106, align 1
  %107 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  %108 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  store ptr %107, ptr %108, align 8
  %109 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  store i64 1, ptr %109, align 8
  %110 = load { ptr, i64 }, ptr %12, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %110, ptr %__.context_ptr)
  br label %for.interval.post

for.interval.post:                                ; preds = %if.done7
  %111 = load i64, ptr %i, align 8
  %112 = add i64 %111, 1
  store i64 %112, ptr %i, align 8
  %113 = load i64, ptr %15, align 8
  %114 = add i64 %113, 1
  store i64 %114, ptr %15, align 8
  br label %for.interval.loop

for.interval.done:                                ; preds = %for.interval.loop
  br label %if.done8

if.done8:                                         ; preds = %for.interval.done, %if.done3
  %115 = load %"strconv::format_digits::Buffer::$1", ptr %b, align 8
  %116 = call { ptr, i64 } @"strconv::format_digits.to_bytes-0"(ptr %b, ptr %__.context_ptr)
  store { ptr, i64 } %116, ptr %16, align 8
  %117 = load { ptr, i64 }, ptr %16, align 8
  ret { ptr, i64 } %117

switch.case.body9:                                ; preds = %entry, %entry
  %118 = icmp ne i8 %2, 0
  br i1 %118, label %if.then10, label %if.else11

if.then10:                                        ; preds = %switch.case.body9
  br label %if.done12

if.else11:                                        ; preds = %switch.case.body9
  br label %if.done12

if.done12:                                        ; preds = %if.else11, %if.then10
  %119 = phi i8 [ 45, %if.then10 ], [ 43, %if.else11 ]
  %120 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  store i8 %119, ptr %120, align 1
  %121 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  %122 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  store ptr %121, ptr %122, align 8
  %123 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  store i64 1, ptr %123, align 8
  %124 = load { ptr, i64 }, ptr %12, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %124, ptr %__.context_ptr)
  store i8 48, ptr %ch, align 1
  %125 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 1
  %126 = load i64, ptr %125, align 8
  %127 = icmp ne i64 %126, 0
  %128 = zext i1 %127 to i8
  %129 = icmp ne i8 %128, 0
  br i1 %129, label %if.then13, label %if.done14

if.then13:                                        ; preds = %if.done12
  %130 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 0
  %131 = load { ptr, i64 }, ptr %130, align 8
  %132 = getelementptr inbounds nuw { ptr, i64 }, ptr %130, i32 0, i32 0
  %133 = load ptr, ptr %132, align 8
  %134 = getelementptr inbounds nuw { ptr, i64 }, ptr %130, i32 0, i32 1
  %135 = load i64, ptr %134, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1e7", i64 45 }, i32 186, i32 21, i64 0, i64 %135)
  %136 = getelementptr i8, ptr %133, i64 0
  %137 = load i8, ptr %136, align 1
  store i8 %137, ptr %ch, align 1
  br label %if.done14

if.done14:                                        ; preds = %if.then13, %if.done12
  %138 = load i8, ptr %ch, align 1
  %139 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  store i8 %138, ptr %139, align 1
  %140 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  %141 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  store ptr %140, ptr %141, align 8
  %142 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  store i64 1, ptr %142, align 8
  %143 = load { ptr, i64 }, ptr %12, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %143, ptr %__.context_ptr)
  %144 = load i64, ptr %prec, align 8
  %145 = icmp sgt i64 %144, 0
  %146 = zext i1 %145 to i8
  %147 = icmp ne i8 %146, 0
  br i1 %147, label %if.then15, label %if.done24

if.then15:                                        ; preds = %if.done14
  %148 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  store i8 46, ptr %148, align 1
  %149 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  %150 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  store ptr %149, ptr %150, align 8
  %151 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  store i64 1, ptr %151, align 8
  %152 = load { ptr, i64 }, ptr %12, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %152, ptr %__.context_ptr)
  store i64 1, ptr %i16, align 8
  %153 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 1
  %154 = load i64, ptr %153, align 8
  %155 = load i64, ptr %prec, align 8
  %156 = add i64 %155, 1
  %157 = icmp slt i64 %154, %156
  %158 = select i1 %157, i64 %154, i64 %156
  store i64 %158, ptr %m17, align 8
  %159 = load i64, ptr %i16, align 8
  %160 = load i64, ptr %m17, align 8
  %161 = icmp slt i64 %159, %160
  %162 = zext i1 %161 to i8
  %163 = icmp ne i8 %162, 0
  br i1 %163, label %if.then18, label %if.done19

if.then18:                                        ; preds = %if.then15
  %164 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 0
  %165 = load { ptr, i64 }, ptr %164, align 8
  %166 = load i64, ptr %i16, align 8
  %167 = load i64, ptr %m17, align 8
  %168 = getelementptr inbounds nuw { ptr, i64 }, ptr %164, i32 0, i32 1
  %169 = load i64, ptr %168, align 8
  call void @"runtime::slice_expr_error_lo_hi"(%..string { ptr @"csbs$byte_world$1e7", i64 45 }, i32 195, i32 32, i64 %166, i64 %167, i64 %169)
  %170 = getelementptr inbounds nuw { ptr, i64 }, ptr %164, i32 0, i32 0
  %171 = load ptr, ptr %170, align 8
  %172 = getelementptr i8, ptr %171, i64 %166
  %173 = sub i64 %167, %166
  %174 = getelementptr inbounds nuw { ptr, i64 }, ptr %17, i32 0, i32 0
  store ptr %172, ptr %174, align 8
  %175 = getelementptr inbounds nuw { ptr, i64 }, ptr %17, i32 0, i32 1
  store i64 %173, ptr %175, align 8
  %176 = load { ptr, i64 }, ptr %17, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %176, ptr %__.context_ptr)
  %177 = load i64, ptr %m17, align 8
  store i64 %177, ptr %i16, align 8
  br label %if.done19

if.done19:                                        ; preds = %if.then18, %if.then15
  br label %for.loop20

for.loop20:                                       ; preds = %for.post22, %if.done19
  %178 = load i64, ptr %i16, align 8
  %179 = load i64, ptr %prec, align 8
  %180 = icmp sle i64 %178, %179
  %181 = zext i1 %180 to i8
  %182 = icmp ne i8 %181, 0
  br i1 %182, label %for.body21, label %for.done23

for.body21:                                       ; preds = %for.loop20
  %183 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  store i8 48, ptr %183, align 1
  %184 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  %185 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  store ptr %184, ptr %185, align 8
  %186 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  store i64 1, ptr %186, align 8
  %187 = load { ptr, i64 }, ptr %12, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %187, ptr %__.context_ptr)
  br label %for.post22

for.post22:                                       ; preds = %for.body21
  %188 = load i64, ptr %i16, align 8
  %189 = add i64 %188, 1
  store i64 %189, ptr %i16, align 8
  br label %for.loop20

for.done23:                                       ; preds = %for.loop20
  br label %if.done24

if.done24:                                        ; preds = %for.done23, %if.done14
  %190 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  store i8 %5, ptr %190, align 1
  %191 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  %192 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  store ptr %191, ptr %192, align 8
  %193 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  store i64 1, ptr %193, align 8
  %194 = load { ptr, i64 }, ptr %12, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %194, ptr %__.context_ptr)
  %195 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 2
  %196 = load i64, ptr %195, align 8
  %197 = sub i64 %196, 1
  store i64 %197, ptr %exp, align 8
  %198 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 1
  %199 = load i64, ptr %198, align 8
  %200 = icmp eq i64 %199, 0
  %201 = zext i1 %200 to i8
  %202 = icmp ne i8 %201, 0
  br i1 %202, label %if.then25, label %if.done26

if.then25:                                        ; preds = %if.done24
  store i64 0, ptr %exp, align 8
  br label %if.done26

if.done26:                                        ; preds = %if.then25, %if.done24
  store i8 43, ptr %ch, align 1
  %203 = load i64, ptr %exp, align 8
  %204 = icmp slt i64 %203, 0
  %205 = zext i1 %204 to i8
  %206 = icmp ne i8 %205, 0
  br i1 %206, label %if.then27, label %if.done28

if.then27:                                        ; preds = %if.done26
  store i8 45, ptr %ch, align 1
  %207 = load i64, ptr %exp, align 8
  %208 = sub i64 0, %207
  store i64 %208, ptr %exp, align 8
  br label %if.done28

if.done28:                                        ; preds = %if.then27, %if.done26
  %209 = load i8, ptr %ch, align 1
  %210 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  store i8 %209, ptr %210, align 1
  %211 = getelementptr [1 x i8], ptr %13, i64 0, i64 0
  %212 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  store ptr %211, ptr %212, align 8
  %213 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  store i64 1, ptr %213, align 8
  %214 = load { ptr, i64 }, ptr %12, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %214, ptr %__.context_ptr)
  %215 = load i64, ptr %exp, align 8
  %216 = icmp slt i64 %215, 10
  %217 = zext i1 %216 to i8
  %218 = icmp eq i8 1, %217
  br i1 %218, label %switch.case.body29, label %switch.case.next

switch.case.next:                                 ; preds = %if.done28
  %219 = load i64, ptr %exp, align 8
  %220 = icmp slt i64 %219, 100
  %221 = zext i1 %220 to i8
  %222 = icmp eq i8 1, %221
  br i1 %222, label %switch.case.body31, label %switch.case.next30

switch.case.body29:                               ; preds = %if.done28
  %223 = load i64, ptr %exp, align 8
  %224 = trunc i64 %223 to i8
  %225 = add i8 %224, 48
  %226 = getelementptr [2 x i8], ptr %13, i64 0, i64 0
  store i8 48, ptr %226, align 1
  %227 = getelementptr [2 x i8], ptr %13, i64 0, i64 1
  store i8 %225, ptr %227, align 1
  %228 = getelementptr [2 x i8], ptr %13, i64 0, i64 0
  %229 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  store ptr %228, ptr %229, align 8
  %230 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  store i64 2, ptr %230, align 8
  %231 = load { ptr, i64 }, ptr %12, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %231, ptr %__.context_ptr)
  br label %switch.done

switch.case.next30:                               ; preds = %switch.case.next
  br label %switch.default.body

switch.case.body31:                               ; preds = %switch.case.next
  %232 = load i64, ptr %exp, align 8
  %233 = sdiv i64 %232, 10
  %234 = trunc i64 %233 to i8
  %235 = add i8 %234, 48
  %236 = load i64, ptr %exp, align 8
  %237 = srem i64 %236, 10
  %238 = trunc i64 %237 to i8
  %239 = add i8 %238, 48
  %240 = getelementptr [2 x i8], ptr %13, i64 0, i64 0
  store i8 %235, ptr %240, align 1
  %241 = getelementptr [2 x i8], ptr %13, i64 0, i64 1
  store i8 %239, ptr %241, align 1
  %242 = getelementptr [2 x i8], ptr %13, i64 0, i64 0
  %243 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  store ptr %242, ptr %243, align 8
  %244 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  store i64 2, ptr %244, align 8
  %245 = load { ptr, i64 }, ptr %12, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %245, ptr %__.context_ptr)
  br label %switch.done

switch.default.body:                              ; preds = %switch.case.next30
  %246 = load i64, ptr %exp, align 8
  %247 = sdiv i64 %246, 100
  %248 = trunc i64 %247 to i8
  %249 = add i8 %248, 48
  %250 = load i64, ptr %exp, align 8
  %251 = sdiv i64 %250, 10
  %252 = trunc i64 %251 to i8
  %253 = urem i8 %252, 10
  %254 = add i8 %253, 48
  %255 = load i64, ptr %exp, align 8
  %256 = srem i64 %255, 10
  %257 = trunc i64 %256 to i8
  %258 = add i8 %257, 48
  %259 = getelementptr [3 x i8], ptr %13, i64 0, i64 0
  store i8 %249, ptr %259, align 1
  %260 = getelementptr [3 x i8], ptr %13, i64 0, i64 1
  store i8 %254, ptr %260, align 1
  %261 = getelementptr [3 x i8], ptr %13, i64 0, i64 2
  store i8 %258, ptr %261, align 1
  %262 = getelementptr [3 x i8], ptr %13, i64 0, i64 0
  %263 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  store ptr %262, ptr %263, align 8
  %264 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  store i64 3, ptr %264, align 8
  %265 = load { ptr, i64 }, ptr %12, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %265, ptr %__.context_ptr)
  br label %switch.done

switch.done:                                      ; preds = %switch.default.body, %switch.case.body31, %switch.case.body29
  %266 = load %"strconv::format_digits::Buffer::$1", ptr %b, align 8
  %267 = call { ptr, i64 } @"strconv::format_digits.to_bytes-0"(ptr %b, ptr %__.context_ptr)
  store { ptr, i64 } %267, ptr %16, align 8
  %268 = load { ptr, i64 }, ptr %16, align 8
  ret { ptr, i64 } %268

switch.case.body32:                               ; preds = %entry, %entry
  %269 = load i64, ptr %prec, align 8
  store i64 %269, ptr %eprec, align 8
  %270 = load i64, ptr %eprec, align 8
  %271 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 1
  %272 = load i64, ptr %271, align 8
  %273 = icmp sgt i64 %270, %272
  %274 = zext i1 %273 to i8
  %275 = icmp ne i8 %274, 0
  br i1 %275, label %cmp.and33, label %if.done35

cmp.and33:                                        ; preds = %switch.case.body32
  %276 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 1
  %277 = load i64, ptr %276, align 8
  %278 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 2
  %279 = load i64, ptr %278, align 8
  %280 = icmp sge i64 %277, %279
  %281 = zext i1 %280 to i8
  %282 = icmp ne i8 %281, 0
  br i1 %282, label %if.then34, label %if.done35

if.then34:                                        ; preds = %cmp.and33
  %283 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 1
  %284 = load i64, ptr %283, align 8
  store i64 %284, ptr %eprec, align 8
  br label %if.done35

if.done35:                                        ; preds = %if.then34, %cmp.and33, %switch.case.body32
  %285 = icmp ne i8 %1, 0
  br i1 %285, label %if.then36, label %if.done37

if.then36:                                        ; preds = %if.done35
  store i64 6, ptr %eprec, align 8
  br label %if.done37

if.done37:                                        ; preds = %if.then36, %if.done35
  %286 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 2
  %287 = load i64, ptr %286, align 8
  %288 = sub i64 %287, 1
  store i64 %288, ptr %exp38, align 8
  %289 = load i64, ptr %exp38, align 8
  %290 = icmp slt i64 %289, -4
  %291 = zext i1 %290 to i8
  %292 = icmp ne i8 %291, 0
  br i1 %292, label %if.then39, label %cmp.or

cmp.or:                                           ; preds = %if.done37
  %293 = load i64, ptr %exp38, align 8
  %294 = load i64, ptr %eprec, align 8
  %295 = icmp sge i64 %293, %294
  %296 = zext i1 %295 to i8
  %297 = icmp ne i8 %296, 0
  br i1 %297, label %if.then39, label %if.done42

if.then39:                                        ; preds = %cmp.or, %if.done37
  %298 = load i64, ptr %prec, align 8
  %299 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 1
  %300 = load i64, ptr %299, align 8
  %301 = icmp sgt i64 %298, %300
  %302 = zext i1 %301 to i8
  %303 = icmp ne i8 %302, 0
  br i1 %303, label %if.then40, label %if.done41

if.then40:                                        ; preds = %if.then39
  %304 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 1
  %305 = load i64, ptr %304, align 8
  store i64 %305, ptr %prec, align 8
  br label %if.done41

if.done41:                                        ; preds = %if.then40, %if.then39
  %306 = load %"strconv::Decimal_Slice", ptr %3, align 8
  %307 = load i64, ptr %prec, align 8
  %308 = sub i64 %307, 1
  %309 = add i8 %5, 101
  %310 = sub i8 %309, 103
  %311 = call { ptr, i64 } @"strconv::format_digits"({ ptr, i64 } %0, i8 %1, i8 %2, ptr %3, i64 %308, i8 %310, ptr %__.context_ptr)
  store { ptr, i64 } %311, ptr %16, align 8
  %312 = load { ptr, i64 }, ptr %16, align 8
  ret { ptr, i64 } %312

if.done42:                                        ; preds = %cmp.or
  %313 = load i64, ptr %prec, align 8
  %314 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 2
  %315 = load i64, ptr %314, align 8
  %316 = icmp sgt i64 %313, %315
  %317 = zext i1 %316 to i8
  %318 = icmp ne i8 %317, 0
  br i1 %318, label %if.then43, label %if.done44

if.then43:                                        ; preds = %if.done42
  %319 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 1
  %320 = load i64, ptr %319, align 8
  store i64 %320, ptr %prec, align 8
  br label %if.done44

if.done44:                                        ; preds = %if.then43, %if.done42
  %321 = load %"strconv::Decimal_Slice", ptr %3, align 8
  %322 = load i64, ptr %prec, align 8
  %323 = getelementptr inbounds nuw %"strconv::Decimal_Slice", ptr %3, i32 0, i32 2
  %324 = load i64, ptr %323, align 8
  %325 = sub i64 %322, %324
  %326 = icmp sgt i64 %325, 0
  %327 = select i1 %326, i64 %325, i64 0
  %328 = call { ptr, i64 } @"strconv::format_digits"({ ptr, i64 } %0, i8 %1, i8 %2, ptr %3, i64 %327, i8 102, ptr %__.context_ptr)
  store { ptr, i64 } %328, ptr %16, align 8
  %329 = load { ptr, i64 }, ptr %16, align 8
  ret { ptr, i64 } %329

switch.default.body45:                            ; preds = %entry
  %330 = getelementptr [2 x i8], ptr %13, i64 0, i64 0
  store i8 37, ptr %330, align 1
  %331 = getelementptr [2 x i8], ptr %13, i64 0, i64 1
  store i8 %5, ptr %331, align 1
  %332 = getelementptr [2 x i8], ptr %13, i64 0, i64 0
  %333 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  store ptr %332, ptr %333, align 8
  %334 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  store i64 2, ptr %334, align 8
  %335 = load { ptr, i64 }, ptr %12, align 8
  call void @"strconv::format_digits.add_bytes-1"(ptr %b, { ptr, i64 } %335, ptr %__.context_ptr)
  %336 = load %"strconv::format_digits::Buffer::$1", ptr %b, align 8
  %337 = call { ptr, i64 } @"strconv::format_digits.to_bytes-0"(ptr %b, ptr %__.context_ptr)
  store { ptr, i64 } %337, ptr %16, align 8
  %338 = load { ptr, i64 }, ptr %16, align 8
  ret { ptr, i64 } %338

switch.done46:                                    ; No predecessors!
  unreachable
}

define internal void @"runtime::matrix_bounds_check_error"(%..string %0, i32 %1, i32 %2, i64 %3, i64 %4, i64 %5, i64 %6) {
decls:
  %7 = alloca %..string, align 8
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %7, align 8
  store i32 %1, ptr %8, align 4
  store i32 %2, ptr %9, align 4
  store i64 %3, ptr %10, align 8
  store i64 %4, ptr %11, align 8
  store i64 %5, ptr %12, align 8
  store i64 %6, ptr %13, align 8
  %14 = icmp ult i64 %3, %5
  %15 = zext i1 %14 to i8
  %16 = icmp ne i8 %15, 0
  br i1 %16, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %entry
  %17 = icmp ult i64 %4, %6
  %18 = zext i1 %17 to i8
  %19 = icmp ne i8 %18, 0
  br i1 %19, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and
  ret void

if.done:                                          ; preds = %cmp.and, %entry
  call void @"runtime::matrix_bounds_check_error.handle_error-0"(%..string %0, i32 %1, i32 %2, i64 %3, i64 %4, i64 %5, i64 %6)
  unreachable
}

define internal i32 @"io::n_wrapper"(i64 %0, i32 %1, ptr %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca i64, align 8
  %4 = alloca i32, align 4
  %5 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %3, align 8
  store i32 %1, ptr %4, align 4
  store ptr %2, ptr %5, align 8
  %6 = load i64, ptr %2, align 8
  %7 = add i64 %6, %0
  store i64 %7, ptr %2, align 8
  ret i32 %1
}

define internal i8 @"strings::builder_init_none"(ptr %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca ptr, align 8
  %5 = alloca %"runtime::Allocator", align 16
  %res = alloca ptr, align 8
  %err = alloca i8, align 1
  %6 = alloca { i64, i64 }, align 16
  %7 = alloca { ptr, i64, i64, %"runtime::Allocator" }, align 8
  %8 = alloca { { ptr, i64, i64, %"runtime::Allocator" }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %4, align 8
  store { i64, i64 } %1, ptr %5, align 8
  %9 = load %"runtime::Allocator", ptr %5, align 8
  store ptr null, ptr %res, align 8
  store i8 0, ptr %err, align 1
  %10 = load ptr, ptr %4, align 8
  %11 = getelementptr inbounds nuw %"strings::Builder", ptr %10, i32 0, i32 0
  %12 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %9, ptr %6, align 8
  %13 = load { i64, i64 }, ptr %6, align 8
  call void @llvm.memset.p0.i64(ptr %7, i8 0, i64 40, i1 false)
  %14 = call i8 @"runtime::make_dynamic_array:proc(T:$[dynamic]u8,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]u8,err:runtime::Allocator_Error)"({ i64, i64 } %13, ptr %2, ptr %7, ptr %__.context_ptr)
  %15 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %7, align 8
  %16 = load { { ptr, i64, i64, %"runtime::Allocator" }, i8 }, ptr %8, align 8
  %17 = icmp eq i8 %14, 0
  br i1 %17, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %entry
  store i8 %14, ptr %err, align 1
  %18 = load ptr, ptr %res, align 8
  %19 = load i8, ptr %err, align 1
  store ptr %18, ptr %res, align 8
  store i8 %19, ptr %err, align 1
  store ptr %18, ptr %3, align 8
  ret i8 %19

or_return.continue:                               ; preds = %entry
  store { ptr, i64, i64, %"runtime::Allocator" } %15, ptr %11, align 8
  store ptr %0, ptr %res, align 8
  store i8 0, ptr %err, align 1
  store ptr %0, ptr %3, align 8
  ret i8 0
}

define internal ptr @"thread::create"(ptr %0, i64 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %4 = call ptr @"thread::[thread_unix.odin]::_create"(ptr %0, i64 %1, ptr %__.context_ptr)
  ret ptr %4
}

; Function Attrs: noinline
define internal void @"runtime::print_encoded_rune"(i32 %0) #4 {
decls:
  %1 = alloca i32, align 4
  %n0 = alloca i8, align 1
  %n1 = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %1, align 4
  %2 = call i64 @"runtime::print_byte"(i8 39)
  switch i32 %0, label %switch.default.body [
    i32 7, label %switch.case.body
    i32 8, label %switch.case.body1
    i32 27, label %switch.case.body2
    i32 12, label %switch.case.body3
    i32 10, label %switch.case.body4
    i32 13, label %switch.case.body5
    i32 9, label %switch.case.body6
    i32 11, label %switch.case.body7
  ]

switch.case.body:                                 ; preds = %entry
  %3 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$1fe", i64 2 })
  br label %switch.done

switch.case.body1:                                ; preds = %entry
  %4 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$1ff", i64 2 })
  br label %switch.done

switch.case.body2:                                ; preds = %entry
  %5 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$200", i64 2 })
  br label %switch.done

switch.case.body3:                                ; preds = %entry
  %6 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$201", i64 2 })
  br label %switch.done

switch.case.body4:                                ; preds = %entry
  %7 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$202", i64 2 })
  br label %switch.done

switch.case.body5:                                ; preds = %entry
  %8 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$203", i64 2 })
  br label %switch.done

switch.case.body6:                                ; preds = %entry
  %9 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$204", i64 2 })
  br label %switch.done

switch.case.body7:                                ; preds = %entry
  %10 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$205", i64 2 })
  br label %switch.done

switch.default.body:                              ; preds = %entry
  %11 = icmp sle i32 %0, 0
  %12 = zext i1 %11 to i8
  %13 = icmp ne i8 %12, 0
  br i1 %13, label %if.then, label %if.else

if.then:                                          ; preds = %switch.default.body
  %14 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$206", i64 4 })
  br label %if.done10

if.else:                                          ; preds = %switch.default.body
  %15 = icmp slt i32 %0, 32
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %if.then8, label %if.else9

if.then8:                                         ; preds = %if.else
  %18 = trunc i32 %0 to i8
  %19 = lshr i8 %18, 4
  %20 = select i1 true, i8 %19, i8 0
  %21 = trunc i32 %0 to i8
  %22 = and i8 %21, 15
  store i8 %20, ptr %n0, align 1
  store i8 %22, ptr %n1, align 1
  %23 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$207", i64 2 })
  %24 = load %..string, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %25 = load ptr, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %26 = load i64, ptr getelementptr (%..string, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", i64 0, i32 1), align 8
  %27 = load i8, ptr %n0, align 1
  %28 = zext i8 %27 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$208", i64 37 }, i32 164, i32 35, i64 %28, i64 %26)
  %29 = getelementptr i8, ptr %25, i64 %28
  %30 = load i8, ptr %29, align 1
  %31 = call i64 @"runtime::print_byte"(i8 %30)
  %32 = load %..string, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %33 = load ptr, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %34 = load i64, ptr getelementptr (%..string, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", i64 0, i32 1), align 8
  %35 = load i8, ptr %n1, align 1
  %36 = zext i8 %35 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$208", i64 37 }, i32 165, i32 35, i64 %36, i64 %34)
  %37 = getelementptr i8, ptr %33, i64 %36
  %38 = load i8, ptr %37, align 1
  %39 = call i64 @"runtime::print_byte"(i8 %38)
  br label %if.done

if.else9:                                         ; preds = %if.else
  %40 = call i64 @"runtime::print_rune"(i32 %0)
  br label %if.done

if.done:                                          ; preds = %if.else9, %if.then8
  br label %if.done10

if.done10:                                        ; preds = %if.done, %if.then
  br label %switch.done

switch.done:                                      ; preds = %if.done10, %switch.case.body7, %switch.case.body6, %switch.case.body5, %switch.case.body4, %switch.case.body3, %switch.case.body2, %switch.case.body1, %switch.case.body
  %41 = call i64 @"runtime::print_byte"(i8 39)
  ret void
}

define internal i8 @"runtime::new:proc(T:$thread::Thread,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(t:^thread::Thread,err:runtime::Allocator_Error)"({ i64, i64 } %0, ptr %1, ptr noalias nonnull %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca %"runtime::Allocator", align 16
  %t = alloca ptr, align 8
  %err = alloca i8, align 1
  %4 = alloca { i64, i64 }, align 16
  %5 = alloca { ptr, i64 }, align 8
  %6 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %3, align 8
  %7 = load %"runtime::Allocator", ptr %3, align 8
  store ptr null, ptr %t, align 8
  store i8 0, ptr %err, align 1
  %8 = load %"runtime::Source_Code_Location", ptr %1, align 8
  store %"runtime::Allocator" %7, ptr %4, align 8
  %9 = load { i64, i64 }, ptr %4, align 8
  call void @llvm.memset.inline.p0.i64(ptr %5, i8 0, i64 16, i1 false)
  %10 = call i8 @"runtime::mem_alloc_bytes"(i64 256, i64 16, { i64, i64 } %9, ptr %1, ptr %5, ptr %__.context_ptr)
  %11 = load { ptr, i64 }, ptr %5, align 8
  %12 = load { { ptr, i64 }, i8 }, ptr %6, align 8
  %13 = icmp eq i8 %10, 0
  br i1 %13, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %entry
  store i8 %10, ptr %err, align 1
  %14 = load ptr, ptr %t, align 8
  %15 = load i8, ptr %err, align 1
  store ptr %14, ptr %t, align 8
  store i8 %15, ptr %err, align 1
  store ptr %14, ptr %2, align 8
  ret i8 %15

or_return.continue:                               ; preds = %entry
  %16 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  store ptr %17, ptr %t, align 8
  %18 = load ptr, ptr %t, align 8
  %19 = load i8, ptr %err, align 1
  store ptr %18, ptr %t, align 8
  store i8 %19, ptr %err, align 1
  store ptr %18, ptr %2, align 8
  ret i8 %19
}

define internal ptr @"runtime::heap_alloc"(i64 %0, i8 %1) {
decls:
  %2 = alloca i64, align 8
  %3 = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %2, align 8
  store i8 %1, ptr %3, align 1
  %4 = call ptr @"runtime::[heap_allocator_unix.odin]::_heap_alloc"(i64 %0, i8 %1)
  ret ptr %4
}

define internal i64 @"os::read_entire_file_from_filename_or_err"(%..string %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca %..string, align 8
  %5 = alloca %"runtime::Allocator", align 16
  %data = alloca { ptr, i64 }, align 8
  %err = alloca %"os::Error", align 8
  %6 = alloca %"runtime::Context", align 8
  %7 = alloca i32, align 4
  %8 = alloca %"os::Error", align 16
  %9 = alloca { i32, %"os::Error" }, align 4
  %10 = alloca i64, align 16
  %fd = alloca i32, align 4
  %11 = alloca { i64, i64 }, align 16
  %12 = alloca { ptr, i64 }, align 8
  %13 = alloca %"os::Error", align 16
  %14 = alloca { { ptr, i64 }, %"os::Error" }, align 8
  %15 = alloca i64, align 16
  %16 = alloca %"os::Error", align 16
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %4, align 8
  store { i64, i64 } %1, ptr %5, align 8
  %17 = load %"runtime::Allocator", ptr %5, align 8
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  call void @llvm.memset.inline.p0.i64(ptr %err, i8 0, i64 8, i1 false)
  %18 = load %"runtime::Context", ptr %__.context_ptr, align 8
  call void @llvm.memset.p0.i64(ptr %6, i8 0, i64 112, i1 false)
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %6, ptr align 1 %__.context_ptr, i64 112, i1 false)
  %19 = getelementptr inbounds nuw %"runtime::Context", ptr %6, i32 0, i32 0
  store %"runtime::Allocator" %17, ptr %19, align 8
  store i32 0, ptr %7, align 4
  %20 = call i64 @"os::open"(%..string %0, i64 0, i64 0, ptr %7, ptr %6)
  store i64 %20, ptr %8, align 8
  %21 = load %"os::Error", ptr %8, align 4
  %22 = load i32, ptr %7, align 4
  %23 = load { i32, %"os::Error" }, ptr %9, align 4
  %24 = getelementptr inbounds nuw %"os::Error", ptr %8, i32 0, i32 1
  %25 = load i32, ptr %24, align 4
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %entry
  store %"os::Error" %21, ptr %err, align 4
  %27 = load { ptr, i64 }, ptr %data, align 8
  %28 = load %"os::Error", ptr %err, align 4
  store { ptr, i64 } %27, ptr %data, align 8
  store %"os::Error" %28, ptr %err, align 4
  store { ptr, i64 } %27, ptr %3, align 8
  store %"os::Error" %28, ptr %10, align 4
  %29 = load i64, ptr %10, align 8
  ret i64 %29

or_return.continue:                               ; preds = %entry
  store i32 %22, ptr %fd, align 4
  %30 = load i32, ptr %fd, align 4
  %31 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %17, ptr %11, align 8
  %32 = load { i64, i64 }, ptr %11, align 8
  call void @llvm.memset.inline.p0.i64(ptr %12, i8 0, i64 16, i1 false)
  %33 = call i64 @"os::read_entire_file_from_handle_or_err"(i32 %30, { i64, i64 } %32, ptr %2, ptr %12, ptr %6)
  store i64 %33, ptr %13, align 8
  %34 = load %"os::Error", ptr %13, align 4
  %35 = load { ptr, i64 }, ptr %12, align 8
  %36 = load { { ptr, i64 }, %"os::Error" }, ptr %14, align 8
  store { ptr, i64 } %35, ptr %data, align 8
  store %"os::Error" %34, ptr %err, align 4
  store { ptr, i64 } %35, ptr %3, align 8
  store %"os::Error" %34, ptr %15, align 4
  %37 = load i64, ptr %15, align 8
  br label %defer

defer:                                            ; preds = %or_return.continue
  %38 = load i32, ptr %fd, align 4
  %39 = call i64 @"os::close"(i32 %38, ptr %6)
  store i64 %39, ptr %16, align 8
  %40 = load %"os::Error", ptr %16, align 4
  ret i64 %37
}

define internal i32 @"io::write_encoded_rune"({ i64, i64 } %0, i32 %1, i8 %2, ptr %3, ptr noalias nonnull %4, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %5 = alloca %"io::Stream", align 16
  %6 = alloca i32, align 4
  %7 = alloca i8, align 1
  %8 = alloca ptr, align 8
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  %9 = alloca { i64, i64 }, align 16
  %10 = alloca { i64, i64 }, align 16
  %11 = alloca i64, align 8
  %12 = alloca { i64, i32 }, align 8
  %13 = alloca { i64, i64 }, align 16
  %14 = alloca i64, align 8
  %15 = alloca { i64, i32 }, align 8
  %16 = alloca { i64, i64 }, align 16
  %17 = alloca i64, align 8
  %18 = alloca { i64, i32 }, align 8
  %19 = alloca { i64, i64 }, align 16
  %20 = alloca i64, align 8
  %21 = alloca { i64, i32 }, align 8
  %22 = alloca { i64, i64 }, align 16
  %23 = alloca i64, align 8
  %24 = alloca { i64, i32 }, align 8
  %25 = alloca { i64, i64 }, align 16
  %26 = alloca i64, align 8
  %27 = alloca { i64, i32 }, align 8
  %28 = alloca { i64, i64 }, align 16
  %29 = alloca i64, align 8
  %30 = alloca { i64, i32 }, align 8
  %31 = alloca { i64, i64 }, align 16
  %32 = alloca i64, align 8
  %33 = alloca { i64, i32 }, align 8
  %34 = alloca { i64, i64 }, align 16
  %35 = alloca i64, align 8
  %36 = alloca { i64, i32 }, align 8
  %buf = alloca [2 x i8], align 1
  %37 = alloca { ptr, i64 }, align 8
  %38 = alloca %..string, align 8
  %s = alloca %..string, align 8
  %39 = alloca { i64, i64 }, align 16
  %40 = alloca i64, align 8
  %41 = alloca { i64, i32 }, align 8
  %42 = alloca { i64, i64 }, align 16
  %43 = alloca { i64, i64 }, align 16
  %44 = alloca i64, align 8
  %45 = alloca { i64, i32 }, align 8
  %46 = alloca { i64, i64 }, align 16
  %47 = alloca i64, align 8
  %48 = alloca { i64, i32 }, align 8
  %49 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %5, align 8
  %50 = load %"io::Stream", ptr %5, align 8
  store i32 %1, ptr %6, align 4
  store i8 %2, ptr %7, align 1
  store ptr %3, ptr %8, align 8
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  %51 = icmp ne i8 %2, 0
  br i1 %51, label %if.then, label %if.done2

if.then:                                          ; preds = %entry
  store %"io::Stream" %50, ptr %9, align 8
  %52 = load { i64, i64 }, ptr %9, align 8
  %53 = call i32 @"io::write_byte"({ i64, i64 } %52, i8 39, ptr %n, ptr %__.context_ptr)
  %54 = icmp eq i32 %53, 0
  br i1 %54, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %if.then
  store i32 %53, ptr %err, align 4
  %55 = load i64, ptr %n, align 8
  %56 = load i32, ptr %err, align 4
  store i64 %55, ptr %n, align 8
  store i32 %56, ptr %err, align 4
  store i64 %55, ptr %4, align 8
  br label %defer

defer:                                            ; preds = %or_return.return
  %57 = icmp ne ptr %3, null
  %58 = zext i1 %57 to i8
  %59 = icmp ne i8 %58, 0
  br i1 %59, label %if.then1, label %if.done

if.then1:                                         ; preds = %defer
  %60 = load i64, ptr %n, align 8
  %61 = load i64, ptr %3, align 8
  %62 = add i64 %61, %60
  store i64 %62, ptr %3, align 8
  br label %if.done

if.done:                                          ; preds = %if.then1, %defer
  ret i32 %56

or_return.continue:                               ; preds = %if.then
  br label %if.done2

if.done2:                                         ; preds = %or_return.continue, %entry
  switch i32 %1, label %switch.default.body [
    i32 7, label %switch.case.body
    i32 8, label %switch.case.body8
    i32 27, label %switch.case.body14
    i32 12, label %switch.case.body20
    i32 10, label %switch.case.body26
    i32 13, label %switch.case.body32
    i32 9, label %switch.case.body38
    i32 11, label %switch.case.body44
  ]

switch.case.body:                                 ; preds = %if.done2
  store %"io::Stream" %50, ptr %10, align 8
  %63 = load { i64, i64 }, ptr %10, align 8
  store i64 0, ptr %11, align 8
  %64 = call i32 @"io::write_string"({ i64, i64 } %63, %..string { ptr @"csbs$byte_world$1fe", i64 2 }, ptr %n, ptr %11, ptr %__.context_ptr)
  %65 = load i64, ptr %11, align 8
  %66 = load { i64, i32 }, ptr %12, align 8
  %67 = icmp eq i32 %64, 0
  br i1 %67, label %or_return.continue7, label %or_return.return3

or_return.return3:                                ; preds = %switch.case.body
  store i32 %64, ptr %err, align 4
  %68 = load i64, ptr %n, align 8
  %69 = load i32, ptr %err, align 4
  store i64 %68, ptr %n, align 8
  store i32 %69, ptr %err, align 4
  store i64 %68, ptr %4, align 8
  br label %defer4

defer4:                                           ; preds = %or_return.return3
  %70 = icmp ne ptr %3, null
  %71 = zext i1 %70 to i8
  %72 = icmp ne i8 %71, 0
  br i1 %72, label %if.then5, label %if.done6

if.then5:                                         ; preds = %defer4
  %73 = load i64, ptr %n, align 8
  %74 = load i64, ptr %3, align 8
  %75 = add i64 %74, %73
  store i64 %75, ptr %3, align 8
  br label %if.done6

if.done6:                                         ; preds = %if.then5, %defer4
  ret i32 %69

or_return.continue7:                              ; preds = %switch.case.body
  br label %switch.done80

switch.case.body8:                                ; preds = %if.done2
  store %"io::Stream" %50, ptr %13, align 8
  %76 = load { i64, i64 }, ptr %13, align 8
  store i64 0, ptr %14, align 8
  %77 = call i32 @"io::write_string"({ i64, i64 } %76, %..string { ptr @"csbs$byte_world$1ff", i64 2 }, ptr %n, ptr %14, ptr %__.context_ptr)
  %78 = load i64, ptr %14, align 8
  %79 = load { i64, i32 }, ptr %15, align 8
  %80 = icmp eq i32 %77, 0
  br i1 %80, label %or_return.continue13, label %or_return.return9

or_return.return9:                                ; preds = %switch.case.body8
  store i32 %77, ptr %err, align 4
  %81 = load i64, ptr %n, align 8
  %82 = load i32, ptr %err, align 4
  store i64 %81, ptr %n, align 8
  store i32 %82, ptr %err, align 4
  store i64 %81, ptr %4, align 8
  br label %defer10

defer10:                                          ; preds = %or_return.return9
  %83 = icmp ne ptr %3, null
  %84 = zext i1 %83 to i8
  %85 = icmp ne i8 %84, 0
  br i1 %85, label %if.then11, label %if.done12

if.then11:                                        ; preds = %defer10
  %86 = load i64, ptr %n, align 8
  %87 = load i64, ptr %3, align 8
  %88 = add i64 %87, %86
  store i64 %88, ptr %3, align 8
  br label %if.done12

if.done12:                                        ; preds = %if.then11, %defer10
  ret i32 %82

or_return.continue13:                             ; preds = %switch.case.body8
  br label %switch.done80

switch.case.body14:                               ; preds = %if.done2
  store %"io::Stream" %50, ptr %16, align 8
  %89 = load { i64, i64 }, ptr %16, align 8
  store i64 0, ptr %17, align 8
  %90 = call i32 @"io::write_string"({ i64, i64 } %89, %..string { ptr @"csbs$byte_world$200", i64 2 }, ptr %n, ptr %17, ptr %__.context_ptr)
  %91 = load i64, ptr %17, align 8
  %92 = load { i64, i32 }, ptr %18, align 8
  %93 = icmp eq i32 %90, 0
  br i1 %93, label %or_return.continue19, label %or_return.return15

or_return.return15:                               ; preds = %switch.case.body14
  store i32 %90, ptr %err, align 4
  %94 = load i64, ptr %n, align 8
  %95 = load i32, ptr %err, align 4
  store i64 %94, ptr %n, align 8
  store i32 %95, ptr %err, align 4
  store i64 %94, ptr %4, align 8
  br label %defer16

defer16:                                          ; preds = %or_return.return15
  %96 = icmp ne ptr %3, null
  %97 = zext i1 %96 to i8
  %98 = icmp ne i8 %97, 0
  br i1 %98, label %if.then17, label %if.done18

if.then17:                                        ; preds = %defer16
  %99 = load i64, ptr %n, align 8
  %100 = load i64, ptr %3, align 8
  %101 = add i64 %100, %99
  store i64 %101, ptr %3, align 8
  br label %if.done18

if.done18:                                        ; preds = %if.then17, %defer16
  ret i32 %95

or_return.continue19:                             ; preds = %switch.case.body14
  br label %switch.done80

switch.case.body20:                               ; preds = %if.done2
  store %"io::Stream" %50, ptr %19, align 8
  %102 = load { i64, i64 }, ptr %19, align 8
  store i64 0, ptr %20, align 8
  %103 = call i32 @"io::write_string"({ i64, i64 } %102, %..string { ptr @"csbs$byte_world$201", i64 2 }, ptr %n, ptr %20, ptr %__.context_ptr)
  %104 = load i64, ptr %20, align 8
  %105 = load { i64, i32 }, ptr %21, align 8
  %106 = icmp eq i32 %103, 0
  br i1 %106, label %or_return.continue25, label %or_return.return21

or_return.return21:                               ; preds = %switch.case.body20
  store i32 %103, ptr %err, align 4
  %107 = load i64, ptr %n, align 8
  %108 = load i32, ptr %err, align 4
  store i64 %107, ptr %n, align 8
  store i32 %108, ptr %err, align 4
  store i64 %107, ptr %4, align 8
  br label %defer22

defer22:                                          ; preds = %or_return.return21
  %109 = icmp ne ptr %3, null
  %110 = zext i1 %109 to i8
  %111 = icmp ne i8 %110, 0
  br i1 %111, label %if.then23, label %if.done24

if.then23:                                        ; preds = %defer22
  %112 = load i64, ptr %n, align 8
  %113 = load i64, ptr %3, align 8
  %114 = add i64 %113, %112
  store i64 %114, ptr %3, align 8
  br label %if.done24

if.done24:                                        ; preds = %if.then23, %defer22
  ret i32 %108

or_return.continue25:                             ; preds = %switch.case.body20
  br label %switch.done80

switch.case.body26:                               ; preds = %if.done2
  store %"io::Stream" %50, ptr %22, align 8
  %115 = load { i64, i64 }, ptr %22, align 8
  store i64 0, ptr %23, align 8
  %116 = call i32 @"io::write_string"({ i64, i64 } %115, %..string { ptr @"csbs$byte_world$202", i64 2 }, ptr %n, ptr %23, ptr %__.context_ptr)
  %117 = load i64, ptr %23, align 8
  %118 = load { i64, i32 }, ptr %24, align 8
  %119 = icmp eq i32 %116, 0
  br i1 %119, label %or_return.continue31, label %or_return.return27

or_return.return27:                               ; preds = %switch.case.body26
  store i32 %116, ptr %err, align 4
  %120 = load i64, ptr %n, align 8
  %121 = load i32, ptr %err, align 4
  store i64 %120, ptr %n, align 8
  store i32 %121, ptr %err, align 4
  store i64 %120, ptr %4, align 8
  br label %defer28

defer28:                                          ; preds = %or_return.return27
  %122 = icmp ne ptr %3, null
  %123 = zext i1 %122 to i8
  %124 = icmp ne i8 %123, 0
  br i1 %124, label %if.then29, label %if.done30

if.then29:                                        ; preds = %defer28
  %125 = load i64, ptr %n, align 8
  %126 = load i64, ptr %3, align 8
  %127 = add i64 %126, %125
  store i64 %127, ptr %3, align 8
  br label %if.done30

if.done30:                                        ; preds = %if.then29, %defer28
  ret i32 %121

or_return.continue31:                             ; preds = %switch.case.body26
  br label %switch.done80

switch.case.body32:                               ; preds = %if.done2
  store %"io::Stream" %50, ptr %25, align 8
  %128 = load { i64, i64 }, ptr %25, align 8
  store i64 0, ptr %26, align 8
  %129 = call i32 @"io::write_string"({ i64, i64 } %128, %..string { ptr @"csbs$byte_world$203", i64 2 }, ptr %n, ptr %26, ptr %__.context_ptr)
  %130 = load i64, ptr %26, align 8
  %131 = load { i64, i32 }, ptr %27, align 8
  %132 = icmp eq i32 %129, 0
  br i1 %132, label %or_return.continue37, label %or_return.return33

or_return.return33:                               ; preds = %switch.case.body32
  store i32 %129, ptr %err, align 4
  %133 = load i64, ptr %n, align 8
  %134 = load i32, ptr %err, align 4
  store i64 %133, ptr %n, align 8
  store i32 %134, ptr %err, align 4
  store i64 %133, ptr %4, align 8
  br label %defer34

defer34:                                          ; preds = %or_return.return33
  %135 = icmp ne ptr %3, null
  %136 = zext i1 %135 to i8
  %137 = icmp ne i8 %136, 0
  br i1 %137, label %if.then35, label %if.done36

if.then35:                                        ; preds = %defer34
  %138 = load i64, ptr %n, align 8
  %139 = load i64, ptr %3, align 8
  %140 = add i64 %139, %138
  store i64 %140, ptr %3, align 8
  br label %if.done36

if.done36:                                        ; preds = %if.then35, %defer34
  ret i32 %134

or_return.continue37:                             ; preds = %switch.case.body32
  br label %switch.done80

switch.case.body38:                               ; preds = %if.done2
  store %"io::Stream" %50, ptr %28, align 8
  %141 = load { i64, i64 }, ptr %28, align 8
  store i64 0, ptr %29, align 8
  %142 = call i32 @"io::write_string"({ i64, i64 } %141, %..string { ptr @"csbs$byte_world$204", i64 2 }, ptr %n, ptr %29, ptr %__.context_ptr)
  %143 = load i64, ptr %29, align 8
  %144 = load { i64, i32 }, ptr %30, align 8
  %145 = icmp eq i32 %142, 0
  br i1 %145, label %or_return.continue43, label %or_return.return39

or_return.return39:                               ; preds = %switch.case.body38
  store i32 %142, ptr %err, align 4
  %146 = load i64, ptr %n, align 8
  %147 = load i32, ptr %err, align 4
  store i64 %146, ptr %n, align 8
  store i32 %147, ptr %err, align 4
  store i64 %146, ptr %4, align 8
  br label %defer40

defer40:                                          ; preds = %or_return.return39
  %148 = icmp ne ptr %3, null
  %149 = zext i1 %148 to i8
  %150 = icmp ne i8 %149, 0
  br i1 %150, label %if.then41, label %if.done42

if.then41:                                        ; preds = %defer40
  %151 = load i64, ptr %n, align 8
  %152 = load i64, ptr %3, align 8
  %153 = add i64 %152, %151
  store i64 %153, ptr %3, align 8
  br label %if.done42

if.done42:                                        ; preds = %if.then41, %defer40
  ret i32 %147

or_return.continue43:                             ; preds = %switch.case.body38
  br label %switch.done80

switch.case.body44:                               ; preds = %if.done2
  store %"io::Stream" %50, ptr %31, align 8
  %154 = load { i64, i64 }, ptr %31, align 8
  store i64 0, ptr %32, align 8
  %155 = call i32 @"io::write_string"({ i64, i64 } %154, %..string { ptr @"csbs$byte_world$205", i64 2 }, ptr %n, ptr %32, ptr %__.context_ptr)
  %156 = load i64, ptr %32, align 8
  %157 = load { i64, i32 }, ptr %33, align 8
  %158 = icmp eq i32 %155, 0
  br i1 %158, label %or_return.continue49, label %or_return.return45

or_return.return45:                               ; preds = %switch.case.body44
  store i32 %155, ptr %err, align 4
  %159 = load i64, ptr %n, align 8
  %160 = load i32, ptr %err, align 4
  store i64 %159, ptr %n, align 8
  store i32 %160, ptr %err, align 4
  store i64 %159, ptr %4, align 8
  br label %defer46

defer46:                                          ; preds = %or_return.return45
  %161 = icmp ne ptr %3, null
  %162 = zext i1 %161 to i8
  %163 = icmp ne i8 %162, 0
  br i1 %163, label %if.then47, label %if.done48

if.then47:                                        ; preds = %defer46
  %164 = load i64, ptr %n, align 8
  %165 = load i64, ptr %3, align 8
  %166 = add i64 %165, %164
  store i64 %166, ptr %3, align 8
  br label %if.done48

if.done48:                                        ; preds = %if.then47, %defer46
  ret i32 %160

or_return.continue49:                             ; preds = %switch.case.body44
  br label %switch.done80

switch.default.body:                              ; preds = %if.done2
  %167 = icmp slt i32 %1, 32
  %168 = zext i1 %167 to i8
  %169 = icmp ne i8 %168, 0
  br i1 %169, label %if.then50, label %if.else

if.then50:                                        ; preds = %switch.default.body
  store %"io::Stream" %50, ptr %34, align 8
  %170 = load { i64, i64 }, ptr %34, align 8
  store i64 0, ptr %35, align 8
  %171 = call i32 @"io::write_string"({ i64, i64 } %170, %..string { ptr @"csbs$byte_world$207", i64 2 }, ptr %n, ptr %35, ptr %__.context_ptr)
  %172 = load i64, ptr %35, align 8
  %173 = load { i64, i32 }, ptr %36, align 8
  %174 = icmp eq i32 %171, 0
  br i1 %174, label %or_return.continue55, label %or_return.return51

or_return.return51:                               ; preds = %if.then50
  store i32 %171, ptr %err, align 4
  %175 = load i64, ptr %n, align 8
  %176 = load i32, ptr %err, align 4
  store i64 %175, ptr %n, align 8
  store i32 %176, ptr %err, align 4
  store i64 %175, ptr %4, align 8
  br label %defer52

defer52:                                          ; preds = %or_return.return51
  %177 = icmp ne ptr %3, null
  %178 = zext i1 %177 to i8
  %179 = icmp ne i8 %178, 0
  br i1 %179, label %if.then53, label %if.done54

if.then53:                                        ; preds = %defer52
  %180 = load i64, ptr %n, align 8
  %181 = load i64, ptr %3, align 8
  %182 = add i64 %181, %180
  store i64 %182, ptr %3, align 8
  br label %if.done54

if.done54:                                        ; preds = %if.then53, %defer52
  ret i32 %176

or_return.continue55:                             ; preds = %if.then50
  call void @llvm.memset.inline.p0.i64(ptr %buf, i8 0, i64 2, i1 false)
  %183 = load [2 x i8], ptr %buf, align 1
  %184 = getelementptr [2 x i8], ptr %buf, i64 0, i64 0
  %185 = getelementptr i8, ptr %184, i64 0
  %186 = getelementptr inbounds nuw { ptr, i64 }, ptr %37, i32 0, i32 0
  store ptr %185, ptr %186, align 8
  %187 = getelementptr inbounds nuw { ptr, i64 }, ptr %37, i32 0, i32 1
  store i64 2, ptr %187, align 8
  %188 = load { ptr, i64 }, ptr %37, align 8
  %189 = sext i32 %1 to i64
  %190 = load %..string, ptr @"strconv::digits", align 8
  store %..string %190, ptr %38, align 8
  %191 = call %..string @"strconv::write_bits"({ ptr, i64 } %188, i64 %189, i64 16, i8 1, i64 64, ptr byval(%..string) %38, i8 0, ptr %__.context_ptr)
  store %..string %191, ptr %s, align 8
  %192 = load %..string, ptr %s, align 8
  %193 = getelementptr inbounds nuw %..string, ptr %s, i32 0, i32 1
  %194 = load i64, ptr %193, align 8
  switch i64 %194, label %switch.done [
    i64 0, label %switch.case.body56
    i64 1, label %switch.case.body62
    i64 2, label %switch.case.body68
  ]

switch.case.body56:                               ; preds = %or_return.continue55
  store %"io::Stream" %50, ptr %39, align 8
  %195 = load { i64, i64 }, ptr %39, align 8
  store i64 0, ptr %40, align 8
  %196 = call i32 @"io::write_string"({ i64, i64 } %195, %..string { ptr @"csbs$byte_world$209", i64 2 }, ptr %n, ptr %40, ptr %__.context_ptr)
  %197 = load i64, ptr %40, align 8
  %198 = load { i64, i32 }, ptr %41, align 8
  %199 = icmp eq i32 %196, 0
  br i1 %199, label %or_return.continue61, label %or_return.return57

or_return.return57:                               ; preds = %switch.case.body56
  store i32 %196, ptr %err, align 4
  %200 = load i64, ptr %n, align 8
  %201 = load i32, ptr %err, align 4
  store i64 %200, ptr %n, align 8
  store i32 %201, ptr %err, align 4
  store i64 %200, ptr %4, align 8
  br label %defer58

defer58:                                          ; preds = %or_return.return57
  %202 = icmp ne ptr %3, null
  %203 = zext i1 %202 to i8
  %204 = icmp ne i8 %203, 0
  br i1 %204, label %if.then59, label %if.done60

if.then59:                                        ; preds = %defer58
  %205 = load i64, ptr %n, align 8
  %206 = load i64, ptr %3, align 8
  %207 = add i64 %206, %205
  store i64 %207, ptr %3, align 8
  br label %if.done60

if.done60:                                        ; preds = %if.then59, %defer58
  ret i32 %201

or_return.continue61:                             ; preds = %switch.case.body56
  br label %switch.done

switch.case.body62:                               ; preds = %or_return.continue55
  store %"io::Stream" %50, ptr %42, align 8
  %208 = load { i64, i64 }, ptr %42, align 8
  %209 = call i32 @"io::write_byte"({ i64, i64 } %208, i8 48, ptr %n, ptr %__.context_ptr)
  %210 = icmp eq i32 %209, 0
  br i1 %210, label %or_return.continue67, label %or_return.return63

or_return.return63:                               ; preds = %switch.case.body62
  store i32 %209, ptr %err, align 4
  %211 = load i64, ptr %n, align 8
  %212 = load i32, ptr %err, align 4
  store i64 %211, ptr %n, align 8
  store i32 %212, ptr %err, align 4
  store i64 %211, ptr %4, align 8
  br label %defer64

defer64:                                          ; preds = %or_return.return63
  %213 = icmp ne ptr %3, null
  %214 = zext i1 %213 to i8
  %215 = icmp ne i8 %214, 0
  br i1 %215, label %if.then65, label %if.done66

if.then65:                                        ; preds = %defer64
  %216 = load i64, ptr %n, align 8
  %217 = load i64, ptr %3, align 8
  %218 = add i64 %217, %216
  store i64 %218, ptr %3, align 8
  br label %if.done66

if.done66:                                        ; preds = %if.then65, %defer64
  ret i32 %212

or_return.continue67:                             ; preds = %switch.case.body62
  br label %switch.case.body68

unreachable:                                      ; No predecessors!
  br label %switch.done

switch.case.body68:                               ; preds = %or_return.continue55, %or_return.continue67
  %219 = load %..string, ptr %s, align 8
  store %"io::Stream" %50, ptr %43, align 8
  %220 = load { i64, i64 }, ptr %43, align 8
  store i64 0, ptr %44, align 8
  %221 = call i32 @"io::write_string"({ i64, i64 } %220, %..string %219, ptr %n, ptr %44, ptr %__.context_ptr)
  %222 = load i64, ptr %44, align 8
  %223 = load { i64, i32 }, ptr %45, align 8
  %224 = icmp eq i32 %221, 0
  br i1 %224, label %or_return.continue73, label %or_return.return69

or_return.return69:                               ; preds = %switch.case.body68
  store i32 %221, ptr %err, align 4
  %225 = load i64, ptr %n, align 8
  %226 = load i32, ptr %err, align 4
  store i64 %225, ptr %n, align 8
  store i32 %226, ptr %err, align 4
  store i64 %225, ptr %4, align 8
  br label %defer70

defer70:                                          ; preds = %or_return.return69
  %227 = icmp ne ptr %3, null
  %228 = zext i1 %227 to i8
  %229 = icmp ne i8 %228, 0
  br i1 %229, label %if.then71, label %if.done72

if.then71:                                        ; preds = %defer70
  %230 = load i64, ptr %n, align 8
  %231 = load i64, ptr %3, align 8
  %232 = add i64 %231, %230
  store i64 %232, ptr %3, align 8
  br label %if.done72

if.done72:                                        ; preds = %if.then71, %defer70
  ret i32 %226

or_return.continue73:                             ; preds = %switch.case.body68
  br label %switch.done

switch.done:                                      ; preds = %or_return.continue73, %unreachable, %or_return.continue61, %or_return.continue55
  br label %if.done79

if.else:                                          ; preds = %switch.default.body
  store %"io::Stream" %50, ptr %46, align 8
  %233 = load { i64, i64 }, ptr %46, align 8
  store i64 0, ptr %47, align 8
  %234 = call i32 @"io::write_rune"({ i64, i64 } %233, i32 %1, ptr %n, ptr %47, ptr %__.context_ptr)
  %235 = load i64, ptr %47, align 8
  %236 = load { i64, i32 }, ptr %48, align 8
  %237 = icmp eq i32 %234, 0
  br i1 %237, label %or_return.continue78, label %or_return.return74

or_return.return74:                               ; preds = %if.else
  store i32 %234, ptr %err, align 4
  %238 = load i64, ptr %n, align 8
  %239 = load i32, ptr %err, align 4
  store i64 %238, ptr %n, align 8
  store i32 %239, ptr %err, align 4
  store i64 %238, ptr %4, align 8
  br label %defer75

defer75:                                          ; preds = %or_return.return74
  %240 = icmp ne ptr %3, null
  %241 = zext i1 %240 to i8
  %242 = icmp ne i8 %241, 0
  br i1 %242, label %if.then76, label %if.done77

if.then76:                                        ; preds = %defer75
  %243 = load i64, ptr %n, align 8
  %244 = load i64, ptr %3, align 8
  %245 = add i64 %244, %243
  store i64 %245, ptr %3, align 8
  br label %if.done77

if.done77:                                        ; preds = %if.then76, %defer75
  ret i32 %239

or_return.continue78:                             ; preds = %if.else
  br label %if.done79

if.done79:                                        ; preds = %or_return.continue78, %switch.done
  br label %switch.done80

switch.done80:                                    ; preds = %if.done79, %or_return.continue49, %or_return.continue43, %or_return.continue37, %or_return.continue31, %or_return.continue25, %or_return.continue19, %or_return.continue13, %or_return.continue7
  %246 = icmp ne i8 %2, 0
  br i1 %246, label %if.then81, label %if.done87

if.then81:                                        ; preds = %switch.done80
  store %"io::Stream" %50, ptr %49, align 8
  %247 = load { i64, i64 }, ptr %49, align 8
  %248 = call i32 @"io::write_byte"({ i64, i64 } %247, i8 39, ptr %n, ptr %__.context_ptr)
  %249 = icmp eq i32 %248, 0
  br i1 %249, label %or_return.continue86, label %or_return.return82

or_return.return82:                               ; preds = %if.then81
  store i32 %248, ptr %err, align 4
  %250 = load i64, ptr %n, align 8
  %251 = load i32, ptr %err, align 4
  store i64 %250, ptr %n, align 8
  store i32 %251, ptr %err, align 4
  store i64 %250, ptr %4, align 8
  br label %defer83

defer83:                                          ; preds = %or_return.return82
  %252 = icmp ne ptr %3, null
  %253 = zext i1 %252 to i8
  %254 = icmp ne i8 %253, 0
  br i1 %254, label %if.then84, label %if.done85

if.then84:                                        ; preds = %defer83
  %255 = load i64, ptr %n, align 8
  %256 = load i64, ptr %3, align 8
  %257 = add i64 %256, %255
  store i64 %257, ptr %3, align 8
  br label %if.done85

if.done85:                                        ; preds = %if.then84, %defer83
  ret i32 %251

or_return.continue86:                             ; preds = %if.then81
  br label %if.done87

if.done87:                                        ; preds = %or_return.continue86, %switch.done80
  %258 = load i64, ptr %n, align 8
  %259 = load i32, ptr %err, align 4
  store i64 %258, ptr %n, align 8
  store i32 %259, ptr %err, align 4
  store i64 %258, ptr %4, align 8
  br label %defer88

defer88:                                          ; preds = %if.done87
  %260 = icmp ne ptr %3, null
  %261 = zext i1 %260 to i8
  %262 = icmp ne i8 %261, 0
  br i1 %262, label %if.then89, label %if.done90

if.then89:                                        ; preds = %defer88
  %263 = load i64, ptr %n, align 8
  %264 = load i64, ptr %3, align 8
  %265 = add i64 %264, %263
  store i64 %265, ptr %3, align 8
  br label %if.done90

if.done90:                                        ; preds = %if.then89, %defer88
  ret i32 %259
}

; Function Attrs: noinline
define internal i8 @"runtime::mem_alloc"(i64 %0, i64 %1, { i64, i64 } %2, ptr %3, ptr noalias nonnull %4, ptr noalias nonnull "captures"="none" %__.context_ptr) #4 {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca %"runtime::Allocator", align 16
  %8 = alloca { ptr, i64 }, align 8
  %9 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %5, align 8
  store i64 %1, ptr %6, align 8
  store { i64, i64 } %2, ptr %7, align 8
  %10 = load %"runtime::Allocator", ptr %7, align 8
  %11 = call i8 @"runtime::is_power_of_two_int"(i64 %1)
  %12 = load %"runtime::Source_Code_Location", ptr %3, align 8
  call void @"runtime::assert"(i8 %11, %..string { ptr @"csbs$byte_world$1fb", i64 32 }, ptr %3, ptr %__.context_ptr)
  %13 = icmp eq i64 %0, 0
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %entry
  %16 = getelementptr inbounds nuw %"runtime::Allocator", ptr %7, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = icmp eq ptr %17, null
  %19 = zext i1 %18 to i8
  %20 = icmp ne i8 %19, 0
  br i1 %20, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %entry
  store { ptr, i64 } zeroinitializer, ptr %4, align 8
  ret i8 0

if.done:                                          ; preds = %cmp.or
  %21 = getelementptr inbounds nuw %"runtime::Allocator", ptr %7, i32 0, i32 0
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr inbounds nuw %"runtime::Allocator", ptr %7, i32 0, i32 1
  %24 = load ptr, ptr %23, align 8
  %25 = load %"runtime::Source_Code_Location", ptr %3, align 8
  call void @llvm.memset.inline.p0.i64(ptr %8, i8 0, i64 16, i1 false)
  %26 = call i8 %22(ptr %24, i8 0, i64 %0, i64 %1, ptr null, i64 0, ptr %3, ptr %8, ptr %__.context_ptr)
  %27 = load { ptr, i64 }, ptr %8, align 8
  %28 = load { { ptr, i64 }, i8 }, ptr %9, align 8
  store { ptr, i64 } %27, ptr %4, align 8
  ret i8 %26
}

define internal void @"strconv_decimal::trim"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.body, %entry
  %2 = load ptr, ptr %1, align 8
  %3 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %2, i32 0, i32 1
  %4 = load i64, ptr %3, align 8
  %5 = icmp sgt i64 %4, 0
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %cmp.and, label %for.done

cmp.and:                                          ; preds = %for.loop
  %8 = load ptr, ptr %1, align 8
  %9 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %8, i32 0, i32 0
  %10 = load ptr, ptr %1, align 8
  %11 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %10, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  %13 = sub i64 %12, 1
  %14 = getelementptr [384 x i8], ptr %9, i64 0, i64 %13
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20a", i64 47 }, i32 158, i32 30, i64 %13, i64 384)
  %15 = load i8, ptr %14, align 1
  %16 = icmp eq i8 %15, 48
  %17 = zext i1 %16 to i8
  %18 = icmp ne i8 %17, 0
  br i1 %18, label %for.body, label %for.done

for.body:                                         ; preds = %cmp.and
  %19 = load ptr, ptr %1, align 8
  %20 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %19, i32 0, i32 1
  %21 = load i64, ptr %20, align 8
  %22 = sub i64 %21, 1
  store i64 %22, ptr %20, align 8
  br label %for.loop

for.done:                                         ; preds = %cmp.and, %for.loop
  %23 = load ptr, ptr %1, align 8
  %24 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %23, i32 0, i32 1
  %25 = load i64, ptr %24, align 8
  %26 = icmp eq i64 %25, 0
  %27 = zext i1 %26 to i8
  %28 = icmp ne i8 %27, 0
  br i1 %28, label %if.then, label %if.done

if.then:                                          ; preds = %for.done
  %29 = load ptr, ptr %1, align 8
  %30 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %29, i32 0, i32 2
  store i64 0, ptr %30, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %for.done
  ret void
}

define internal void @"sys_valgrind::helgrind_sem_wait_post"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = ptrtoint ptr %0 to i64
  call void @"sys_valgrind::helgrind_client_request_stmt"(i64 2420572438, i64 %2, i64 0, i64 0, i64 0, i64 0)
  ret void
}

define internal ptr @"runtime::heap_resize"(ptr %0, i64 %1) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %4 = call ptr @"runtime::[heap_allocator_unix.odin]::_heap_resize"(ptr %0, i64 %1)
  ret ptr %4
}

; Function Attrs: alwaysinline
define internal i32 @"linux::errno_unwrap2:proc\22contextless\22(ret:int,T:$int)->(:int,:linux::Errno)"(i64 %0, ptr noalias nonnull %1) #3 {
decls:
  %2 = alloca i64, align 8
  %default_value = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %2, align 8
  %3 = icmp slt i64 %0, 0
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i64 0, ptr %default_value, align 8
  %6 = load i64, ptr %default_value, align 8
  %7 = sub i64 0, %0
  %8 = trunc i64 %7 to i32
  store i64 %6, ptr %1, align 8
  ret i32 %8

if.else:                                          ; preds = %entry
  store i64 %0, ptr %1, align 8
  ret i32 0

if.done:                                          ; No predecessors!
  unreachable
}

define internal void @"thread::destroy"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  call void @"thread::[thread_unix.odin]::_destroy"(ptr %0, ptr %__.context_ptr)
  ret void
}

define internal void @"runtime::heap_free"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  call void @"runtime::[heap_allocator_unix.odin]::_heap_free"(ptr %0)
  ret void
}

define internal void @"sys_valgrind::helgrind_sem_post_pre"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = ptrtoint ptr %0 to i64
  call void @"sys_valgrind::helgrind_client_request_stmt"(i64 2420572437, i64 %2, i64 0, i64 0, i64 0, i64 0)
  ret void
}

define internal void @"thread::start"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  call void @"thread::[thread_unix.odin]::_start"(ptr %0, ptr %__.context_ptr)
  ret void
}

define internal i64 @"os::read_entire_file_from_handle_or_err"(i32 %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca i32, align 4
  %5 = alloca %"runtime::Allocator", align 16
  %data = alloca { ptr, i64 }, align 8
  %err = alloca %"os::Error", align 8
  %6 = alloca %"runtime::Context", align 8
  %7 = alloca i64, align 8
  %8 = alloca %"os::Error", align 16
  %9 = alloca { i64, %"os::Error" }, align 8
  %10 = alloca i64, align 16
  %length = alloca i64, align 8
  %11 = alloca i64, align 16
  %12 = alloca { i64, i64 }, align 16
  %13 = alloca { ptr, i64 }, align 8
  %14 = alloca { { ptr, i64 }, i8 }, align 8
  %15 = alloca %"os::Error", align 4
  %16 = alloca i64, align 16
  %17 = alloca i64, align 16
  %18 = alloca i64, align 8
  %19 = alloca %"os::Error", align 16
  %20 = alloca { i64, %"os::Error" }, align 8
  %21 = alloca i64, align 16
  %22 = alloca { i64, i64 }, align 16
  %bytes_read = alloca i64, align 8
  %23 = alloca { ptr, i64 }, align 8
  %24 = alloca i64, align 16
  %25 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %4, align 4
  store { i64, i64 } %1, ptr %5, align 8
  %26 = load %"runtime::Allocator", ptr %5, align 8
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  call void @llvm.memset.inline.p0.i64(ptr %err, i8 0, i64 8, i1 false)
  %27 = load %"runtime::Context", ptr %__.context_ptr, align 8
  call void @llvm.memset.p0.i64(ptr %6, i8 0, i64 112, i1 false)
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %6, ptr align 1 %__.context_ptr, i64 112, i1 false)
  %28 = getelementptr inbounds nuw %"runtime::Context", ptr %6, i32 0, i32 0
  store %"runtime::Allocator" %26, ptr %28, align 8
  store i64 0, ptr %7, align 8
  %29 = call i64 @"os::file_size"(i32 %0, ptr %7, ptr %6)
  store i64 %29, ptr %8, align 8
  %30 = load %"os::Error", ptr %8, align 4
  %31 = load i64, ptr %7, align 8
  %32 = load { i64, %"os::Error" }, ptr %9, align 8
  %33 = getelementptr inbounds nuw %"os::Error", ptr %8, i32 0, i32 1
  %34 = load i32, ptr %33, align 4
  %35 = icmp eq i32 %34, 0
  br i1 %35, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %entry
  store %"os::Error" %30, ptr %err, align 4
  %36 = load { ptr, i64 }, ptr %data, align 8
  %37 = load %"os::Error", ptr %err, align 4
  store { ptr, i64 } %36, ptr %data, align 8
  store %"os::Error" %37, ptr %err, align 4
  store { ptr, i64 } %36, ptr %3, align 8
  store %"os::Error" %37, ptr %10, align 4
  %38 = load i64, ptr %10, align 8
  ret i64 %38

or_return.continue:                               ; preds = %entry
  store i64 %31, ptr %length, align 8
  %39 = load i64, ptr %length, align 8
  %40 = icmp sle i64 %39, 0
  %41 = zext i1 %40 to i8
  %42 = icmp ne i8 %41, 0
  br i1 %42, label %if.then, label %if.done

if.then:                                          ; preds = %or_return.continue
  store { ptr, i64 } zeroinitializer, ptr %data, align 8
  store %"os::Error" zeroinitializer, ptr %err, align 4
  store { ptr, i64 } zeroinitializer, ptr %3, align 8
  store %"os::Error" zeroinitializer, ptr %11, align 4
  %43 = load i64, ptr %11, align 8
  ret i64 %43

if.done:                                          ; preds = %or_return.continue
  %44 = load i64, ptr %length, align 8
  %45 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %26, ptr %12, align 8
  %46 = load { i64, i64 }, ptr %12, align 8
  call void @llvm.memset.inline.p0.i64(ptr %13, i8 0, i64 16, i1 false)
  %47 = call i8 @"runtime::make_slice:proc(T:$[]u8,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]u8,err:runtime::Allocator_Error)"(i64 %44, { i64, i64 } %46, ptr %2, ptr %13, ptr %6)
  %48 = load { ptr, i64 }, ptr %13, align 8
  %49 = load { { ptr, i64 }, i8 }, ptr %14, align 8
  %50 = icmp eq i8 %47, 0
  br i1 %50, label %or_return.continue2, label %or_return.return1

or_return.return1:                                ; preds = %if.done
  call void @llvm.memset.inline.p0.i64(ptr %15, i8 0, i64 8, i1 false)
  %51 = icmp eq i8 %47, 0
  br i1 %51, label %shared_nil.if_nil, label %shared_nil.if_not_nil

shared_nil.if_nil:                                ; preds = %or_return.return1
  store %"os::Error" zeroinitializer, ptr %15, align 4
  br label %shared_nil.done

shared_nil.if_not_nil:                            ; preds = %or_return.return1
  store i8 %47, ptr %15, align 1
  %52 = getelementptr inbounds nuw %"os::Error", ptr %15, i32 0, i32 1
  store i32 3, ptr %52, align 4
  br label %shared_nil.done

shared_nil.done:                                  ; preds = %shared_nil.if_not_nil, %shared_nil.if_nil
  %53 = load %"os::Error", ptr %15, align 4
  store %"os::Error" %53, ptr %err, align 4
  %54 = load { ptr, i64 }, ptr %data, align 8
  %55 = load %"os::Error", ptr %err, align 4
  store { ptr, i64 } %54, ptr %data, align 8
  store %"os::Error" %55, ptr %err, align 4
  store { ptr, i64 } %54, ptr %3, align 8
  store %"os::Error" %55, ptr %16, align 4
  %56 = load i64, ptr %16, align 8
  ret i64 %56

or_return.continue2:                              ; preds = %if.done
  store { ptr, i64 } %48, ptr %data, align 8
  %57 = load { ptr, i64 }, ptr %data, align 8
  %58 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %59 = load ptr, ptr %58, align 8
  %60 = icmp eq ptr %59, null
  %61 = zext i1 %60 to i8
  %62 = icmp ne i8 %61, 0
  br i1 %62, label %if.then3, label %if.done4

if.then3:                                         ; preds = %or_return.continue2
  store { ptr, i64 } zeroinitializer, ptr %data, align 8
  store %"os::Error" zeroinitializer, ptr %err, align 4
  store { ptr, i64 } zeroinitializer, ptr %3, align 8
  store %"os::Error" zeroinitializer, ptr %17, align 4
  %63 = load i64, ptr %17, align 8
  ret i64 %63

if.done4:                                         ; preds = %or_return.continue2
  %64 = load { ptr, i64 }, ptr %data, align 8
  store i64 0, ptr %18, align 8
  %65 = call i64 @"os::read_full"(i32 %0, { ptr, i64 } %64, ptr %18, ptr %6)
  store i64 %65, ptr %19, align 8
  %66 = load %"os::Error", ptr %19, align 4
  %67 = load i64, ptr %18, align 8
  %68 = load { i64, %"os::Error" }, ptr %20, align 8
  %69 = getelementptr inbounds nuw %"os::Error", ptr %19, i32 0, i32 1
  %70 = load i32, ptr %69, align 4
  %71 = icmp eq i32 %70, 0
  br i1 %71, label %or_return.continue8, label %or_return.return5

or_return.return5:                                ; preds = %if.done4
  store %"os::Error" %66, ptr %err, align 4
  %72 = load { ptr, i64 }, ptr %data, align 8
  %73 = load %"os::Error", ptr %err, align 4
  store { ptr, i64 } %72, ptr %data, align 8
  store %"os::Error" %73, ptr %err, align 4
  store { ptr, i64 } %72, ptr %3, align 8
  store %"os::Error" %73, ptr %21, align 4
  %74 = load i64, ptr %21, align 8
  br label %defer

defer:                                            ; preds = %or_return.return5
  %75 = load %"os::Error", ptr %err, align 4
  %76 = getelementptr inbounds nuw %"os::Error", ptr %err, i32 0, i32 1
  %77 = load i32, ptr %76, align 4
  %78 = icmp ne i32 %77, 0
  %79 = zext i1 %78 to i8
  %80 = icmp ne i8 %79, 0
  br i1 %80, label %if.then6, label %if.done7

if.then6:                                         ; preds = %defer
  %81 = load { ptr, i64 }, ptr %data, align 8
  %82 = load %"runtime::Source_Code_Location", ptr @"scl$[read_entire_file_from_handle_or_err3993]", align 8
  store %"runtime::Allocator" %26, ptr %22, align 8
  %83 = load { i64, i64 }, ptr %22, align 8
  %84 = call i8 @"runtime::delete_slice:proc(array:[]u8,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"({ ptr, i64 } %81, { i64, i64 } %83, ptr @"scl$[read_entire_file_from_handle_or_err3993]", ptr %6)
  br label %if.done7

if.done7:                                         ; preds = %if.then6, %defer
  ret i64 %74

or_return.continue8:                              ; preds = %if.done4
  store i64 %67, ptr %bytes_read, align 8
  %85 = load { ptr, i64 }, ptr %data, align 8
  %86 = load i64, ptr %bytes_read, align 8
  %87 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 1
  %88 = load i64, ptr %87, align 8
  call void @"runtime::slice_expr_error_hi"(%..string { ptr @"csbs$byte_world$1f9", i64 29 }, i32 160, i32 13, i64 %86, i64 %88)
  %89 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %90 = load ptr, ptr %89, align 8
  %91 = getelementptr i8, ptr %90, i64 0
  %92 = sub i64 %86, 0
  %93 = getelementptr inbounds nuw { ptr, i64 }, ptr %23, i32 0, i32 0
  store ptr %91, ptr %93, align 8
  %94 = getelementptr inbounds nuw { ptr, i64 }, ptr %23, i32 0, i32 1
  store i64 %92, ptr %94, align 8
  %95 = load { ptr, i64 }, ptr %23, align 8
  store { ptr, i64 } %95, ptr %data, align 8
  %96 = load { ptr, i64 }, ptr %data, align 8
  %97 = load %"os::Error", ptr %err, align 4
  store { ptr, i64 } %96, ptr %data, align 8
  store %"os::Error" %97, ptr %err, align 4
  store { ptr, i64 } %96, ptr %3, align 8
  store %"os::Error" %97, ptr %24, align 4
  %98 = load i64, ptr %24, align 8
  br label %defer9

defer9:                                           ; preds = %or_return.continue8
  %99 = load %"os::Error", ptr %err, align 4
  %100 = getelementptr inbounds nuw %"os::Error", ptr %err, i32 0, i32 1
  %101 = load i32, ptr %100, align 4
  %102 = icmp ne i32 %101, 0
  %103 = zext i1 %102 to i8
  %104 = icmp ne i8 %103, 0
  br i1 %104, label %if.then10, label %if.done11

if.then10:                                        ; preds = %defer9
  %105 = load { ptr, i64 }, ptr %data, align 8
  %106 = load %"runtime::Source_Code_Location", ptr @"scl$[read_entire_file_from_handle_or_err3993].2", align 8
  store %"runtime::Allocator" %26, ptr %25, align 8
  %107 = load { i64, i64 }, ptr %25, align 8
  %108 = call i8 @"runtime::delete_slice:proc(array:[]u8,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"({ ptr, i64 } %105, { i64, i64 } %107, ptr @"scl$[read_entire_file_from_handle_or_err3993].2", ptr %6)
  br label %if.done11

if.done11:                                        ; preds = %if.then10, %defer9
  ret i64 %98
}

define internal i32 @"io::write"({ i64, i64 } %0, { ptr, i64 } %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca %"io::Stream", align 16
  %5 = alloca { ptr, i64 }, align 8
  %6 = alloca ptr, align 8
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  %n64 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca { i64, i32 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %4, align 8
  %9 = load %"io::Stream", ptr %4, align 8
  store { ptr, i64 } %1, ptr %5, align 8
  store ptr %2, ptr %6, align 8
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  %10 = getelementptr inbounds nuw %"io::Stream", ptr %4, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  %12 = icmp ne ptr %11, null
  %13 = zext i1 %12 to i8
  %14 = icmp ne i8 %13, 0
  br i1 %14, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i64 0, ptr %n64, align 8
  %15 = getelementptr inbounds nuw %"io::Stream", ptr %4, i32 0, i32 0
  %16 = load ptr, ptr %15, align 8
  %17 = getelementptr inbounds nuw %"io::Stream", ptr %4, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  store i64 0, ptr %7, align 8
  %19 = call i32 %16(ptr %18, i64 4, { ptr, i64 } %1, i64 0, i64 0, ptr %7, ptr %__.context_ptr)
  %20 = load i64, ptr %7, align 8
  %21 = load { i64, i32 }, ptr %8, align 8
  store i64 %20, ptr %n64, align 8
  store i32 %19, ptr %err, align 4
  %22 = load i64, ptr %n64, align 8
  store i64 %22, ptr %n, align 8
  %23 = icmp ne ptr %2, null
  %24 = zext i1 %23 to i8
  %25 = icmp ne i8 %24, 0
  br i1 %25, label %if.then1, label %if.done

if.then1:                                         ; preds = %if.then
  %26 = load i64, ptr %n, align 8
  %27 = load i64, ptr %2, align 8
  %28 = add i64 %27, %26
  store i64 %28, ptr %2, align 8
  br label %if.done

if.done:                                          ; preds = %if.then1, %if.then
  br label %if.done2

if.else:                                          ; preds = %entry
  store i32 -1, ptr %err, align 4
  br label %if.done2

if.done2:                                         ; preds = %if.else, %if.done
  %29 = load i64, ptr %n, align 8
  %30 = load i32, ptr %err, align 4
  store i64 %29, ptr %n, align 8
  store i32 %30, ptr %err, align 4
  store i64 %29, ptr %3, align 8
  ret i32 %30
}

; Function Attrs: noinline
define internal i8 @"runtime::mem_alloc_non_zeroed"(i64 %0, i64 %1, { i64, i64 } %2, ptr %3, ptr noalias nonnull %4, ptr noalias nonnull "captures"="none" %__.context_ptr) #4 {
decls:
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca %"runtime::Allocator", align 16
  %8 = alloca { ptr, i64 }, align 8
  %9 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %5, align 8
  store i64 %1, ptr %6, align 8
  store { i64, i64 } %2, ptr %7, align 8
  %10 = load %"runtime::Allocator", ptr %7, align 8
  %11 = call i8 @"runtime::is_power_of_two_int"(i64 %1)
  %12 = load %"runtime::Source_Code_Location", ptr %3, align 8
  call void @"runtime::assert"(i8 %11, %..string { ptr @"csbs$byte_world$1fb", i64 32 }, ptr %3, ptr %__.context_ptr)
  %13 = icmp eq i64 %0, 0
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %entry
  %16 = getelementptr inbounds nuw %"runtime::Allocator", ptr %7, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = icmp eq ptr %17, null
  %19 = zext i1 %18 to i8
  %20 = icmp ne i8 %19, 0
  br i1 %20, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %entry
  store { ptr, i64 } zeroinitializer, ptr %4, align 8
  ret i8 0

if.done:                                          ; preds = %cmp.or
  %21 = getelementptr inbounds nuw %"runtime::Allocator", ptr %7, i32 0, i32 0
  %22 = load ptr, ptr %21, align 8
  %23 = getelementptr inbounds nuw %"runtime::Allocator", ptr %7, i32 0, i32 1
  %24 = load ptr, ptr %23, align 8
  %25 = load %"runtime::Source_Code_Location", ptr %3, align 8
  call void @llvm.memset.inline.p0.i64(ptr %8, i8 0, i64 16, i1 false)
  %26 = call i8 %22(ptr %24, i8 6, i64 %0, i64 %1, ptr null, i64 0, ptr %3, ptr %8, ptr %__.context_ptr)
  %27 = load { ptr, i64 }, ptr %8, align 8
  %28 = load { { ptr, i64 }, i8 }, ptr %9, align 8
  store { ptr, i64 } %27, ptr %4, align 8
  ret i8 %26
}

declare i32 @pthread_attr_setinheritsched(ptr, i32)

define internal void @"thread::join"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  call void @"thread::[thread_unix.odin]::_join"(ptr %0, ptr %__.context_ptr)
  ret void
}

define internal void @"strconv_decimal::assign"(ptr %0, i64 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %buf = alloca [64 x i8], align 1
  %n = alloca i64, align 8
  %i = alloca i64, align 8
  %j = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  call void @llvm.memset.p0.i64(ptr %buf, i8 0, i64 64, i1 false)
  store i64 0, ptr %n, align 8
  br label %for.init

for.init:                                         ; preds = %entry
  store i64 %1, ptr %i, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.body, %for.init
  %4 = load i64, ptr %i, align 8
  %5 = icmp ugt i64 %4, 0
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %8 = load i64, ptr %i, align 8
  %9 = udiv i64 %8, 10
  store i64 %9, ptr %j, align 8
  %10 = load i64, ptr %j, align 8
  %11 = mul i64 10, %10
  %12 = load i64, ptr %i, align 8
  %13 = sub i64 %12, %11
  store i64 %13, ptr %i, align 8
  %14 = load i64, ptr %n, align 8
  %15 = getelementptr [64 x i8], ptr %buf, i64 0, i64 %14
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20a", i64 47 }, i32 180, i32 7, i64 %14, i64 64)
  %16 = load i64, ptr %i, align 8
  %17 = add i64 48, %16
  %18 = trunc i64 %17 to i8
  store i8 %18, ptr %15, align 1
  %19 = load i64, ptr %n, align 8
  %20 = add i64 %19, 1
  store i64 %20, ptr %n, align 8
  %21 = load i64, ptr %j, align 8
  store i64 %21, ptr %i, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %22 = load ptr, ptr %2, align 8
  %23 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %22, i32 0, i32 1
  store i64 0, ptr %23, align 8
  br label %for.init1

for.init1:                                        ; preds = %for.done
  %24 = load i64, ptr %n, align 8
  %25 = sub i64 %24, 1
  store i64 %25, ptr %n, align 8
  br label %for.loop2

for.loop2:                                        ; preds = %for.post, %for.init1
  %26 = load i64, ptr %n, align 8
  %27 = icmp sge i64 %26, 0
  %28 = zext i1 %27 to i8
  %29 = icmp ne i8 %28, 0
  br i1 %29, label %for.body3, label %for.done4

for.body3:                                        ; preds = %for.loop2
  %30 = load ptr, ptr %2, align 8
  %31 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %30, i32 0, i32 0
  %32 = load ptr, ptr %2, align 8
  %33 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %32, i32 0, i32 1
  %34 = load i64, ptr %33, align 8
  %35 = getelementptr [384 x i8], ptr %31, i64 0, i64 %34
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20a", i64 47 }, i32 187, i32 12, i64 %34, i64 384)
  %36 = load i64, ptr %n, align 8
  %37 = getelementptr [64 x i8], ptr %buf, i64 0, i64 %36
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20a", i64 47 }, i32 187, i32 27, i64 %36, i64 64)
  %38 = load i8, ptr %37, align 1
  store i8 %38, ptr %35, align 1
  %39 = load ptr, ptr %2, align 8
  %40 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %39, i32 0, i32 1
  %41 = load i64, ptr %40, align 8
  %42 = add i64 %41, 1
  store i64 %42, ptr %40, align 8
  br label %for.post

for.post:                                         ; preds = %for.body3
  %43 = load i64, ptr %n, align 8
  %44 = sub i64 %43, 1
  store i64 %44, ptr %n, align 8
  br label %for.loop2

for.done4:                                        ; preds = %for.loop2
  %45 = load ptr, ptr %2, align 8
  %46 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %45, i32 0, i32 2
  %47 = load ptr, ptr %2, align 8
  %48 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %47, i32 0, i32 1
  %49 = load i64, ptr %48, align 8
  store i64 %49, ptr %46, align 8
  call void @"strconv_decimal::trim"(ptr %0, ptr %__.context_ptr)
  ret void
}

; Function Attrs: alwaysinline
define internal i64 @"utf8::decode_last_rune_in_string"(%..string %0, ptr noalias nonnull %1) #3 {
decls:
  %2 = alloca %..string, align 8
  %3 = alloca %..string, align 8
  %4 = alloca i32, align 4
  %5 = alloca { i32, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %2, align 8
  store %..string %0, ptr %3, align 8
  %6 = load { ptr, i64 }, ptr %3, align 8
  store i32 0, ptr %4, align 4
  %7 = call i64 @"utf8::decode_last_rune_in_bytes"({ ptr, i64 } %6, ptr %4)
  %8 = load i32, ptr %4, align 4
  %9 = load { i32, i64 }, ptr %5, align 8
  store i32 %8, ptr %1, align 4
  ret i64 %7
}

; Function Attrs: noinline
define internal i64 @"runtime::print_rune"(i32 %0) #4 {
decls:
  %1 = alloca i32, align 4
  %2 = alloca [4 x i8], align 1
  %3 = alloca { [4 x i8], i64 }, align 8
  %b = alloca [4 x i8], align 1
  %n = alloca i64, align 8
  %4 = alloca { ptr, i64 }, align 8
  %5 = alloca i64, align 8
  %6 = alloca { i64, i64 }, align 8
  %m = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %1, align 4
  %7 = icmp slt i32 %0, 128
  %8 = zext i1 %7 to i8
  %9 = icmp ne i8 %8, 0
  br i1 %9, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %10 = trunc i32 %0 to i8
  %11 = call i64 @"runtime::print_byte"(i8 %10)
  ret i64 %11

if.done:                                          ; preds = %entry
  call void @llvm.memset.inline.p0.i64(ptr %2, i8 0, i64 4, i1 false)
  %12 = call i64 @"runtime::encode_rune"(i32 %0, ptr %2)
  %13 = load [4 x i8], ptr %2, align 1
  %14 = load { [4 x i8], i64 }, ptr %3, align 8
  store [4 x i8] %13, ptr %b, align 1
  store i64 %12, ptr %n, align 8
  %15 = load [4 x i8], ptr %b, align 1
  %16 = load i64, ptr %n, align 8
  %17 = getelementptr [4 x i8], ptr %b, i64 0, i64 0
  %18 = getelementptr i8, ptr %17, i64 0
  %19 = sub i64 %16, 0
  %20 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 0
  store ptr %18, ptr %20, align 8
  %21 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 1
  store i64 %19, ptr %21, align 8
  %22 = load { ptr, i64 }, ptr %4, align 8
  store i64 0, ptr %5, align 8
  %23 = call i64 @"runtime::stderr_write"({ ptr, i64 } %22, ptr %5)
  %24 = load i64, ptr %5, align 8
  %25 = load { i64, i64 }, ptr %6, align 8
  store i64 %24, ptr %m, align 8
  %26 = load i64, ptr %m, align 8
  ret i64 %26
}

declare i32 @pthread_attr_getschedparam(ptr, ptr)

define internal i64 @"utf8::decode_last_rune_in_bytes"({ ptr, i64 } %0, ptr noalias nonnull %1) {
decls:
  %2 = alloca { ptr, i64 }, align 8
  %r = alloca i32, align 4
  %size = alloca i64, align 8
  %start = alloca i64, align 8
  %end = alloca i64, align 8
  %limit = alloca i64, align 8
  %3 = alloca { ptr, i64 }, align 8
  %4 = alloca i32, align 4
  %5 = alloca { i32, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %2, align 8
  store i32 0, ptr %r, align 4
  store i64 0, ptr %size, align 8
  store i64 0, ptr %start, align 8
  store i64 0, ptr %end, align 8
  store i64 0, ptr %limit, align 8
  %6 = extractvalue { ptr, i64 } %0, 1
  store i64 %6, ptr %end, align 8
  %7 = load i64, ptr %end, align 8
  %8 = icmp eq i64 %7, 0
  %9 = zext i1 %8 to i8
  %10 = icmp ne i8 %9, 0
  br i1 %10, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store i32 65533, ptr %1, align 4
  ret i64 0

if.done:                                          ; preds = %entry
  %11 = load i64, ptr %end, align 8
  %12 = sub i64 %11, 1
  store i64 %12, ptr %start, align 8
  %13 = extractvalue { ptr, i64 } %0, 0
  %14 = load i64, ptr %start, align 8
  %15 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1fa", i64 41 }, i32 193, i32 13, i64 %14, i64 %15)
  %16 = getelementptr i8, ptr %13, i64 %14
  %17 = load i8, ptr %16, align 1
  %18 = zext i8 %17 to i32
  store i32 %18, ptr %r, align 4
  %19 = load i32, ptr %r, align 4
  %20 = icmp slt i32 %19, 128
  %21 = zext i1 %20 to i8
  %22 = icmp ne i8 %21, 0
  br i1 %22, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.done
  %23 = load i32, ptr %r, align 4
  store i32 %23, ptr %1, align 4
  ret i64 1

if.done2:                                         ; preds = %if.done
  %24 = load i64, ptr %end, align 8
  %25 = sub i64 %24, 4
  %26 = icmp sgt i64 %25, 0
  %27 = select i1 %26, i64 %25, i64 0
  store i64 %27, ptr %limit, align 8
  br label %for.init

for.init:                                         ; preds = %if.done2
  %28 = load i64, ptr %start, align 8
  %29 = sub i64 %28, 1
  store i64 %29, ptr %start, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %for.init
  %30 = load i64, ptr %start, align 8
  %31 = load i64, ptr %limit, align 8
  %32 = icmp sge i64 %30, %31
  %33 = zext i1 %32 to i8
  %34 = icmp ne i8 %33, 0
  br i1 %34, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %35 = extractvalue { ptr, i64 } %0, 0
  %36 = load i64, ptr %start, align 8
  %37 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1fa", i64 41 }, i32 202, i32 19, i64 %36, i64 %37)
  %38 = getelementptr i8, ptr %35, i64 %36
  %39 = load i8, ptr %38, align 1
  %40 = call i8 @"utf8::rune_start"(i8 %39)
  %41 = icmp ne i8 %40, 0
  br i1 %41, label %if.then3, label %if.done4

if.then3:                                         ; preds = %for.body
  br label %for.done

unreachable:                                      ; No predecessors!
  br label %if.done4

if.done4:                                         ; preds = %unreachable, %for.body
  br label %for.post

for.post:                                         ; preds = %if.done4
  %42 = load i64, ptr %start, align 8
  %43 = sub i64 %42, 1
  store i64 %43, ptr %start, align 8
  br label %for.loop

for.done:                                         ; preds = %if.then3, %for.loop
  %44 = load i64, ptr %start, align 8
  %45 = icmp sgt i64 %44, 0
  %46 = select i1 %45, i64 %44, i64 0
  store i64 %46, ptr %start, align 8
  %47 = load { ptr, i64 }, ptr %2, align 8
  %48 = load i64, ptr %start, align 8
  %49 = load i64, ptr %end, align 8
  %50 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  %51 = load i64, ptr %50, align 8
  call void @"runtime::slice_expr_error_lo_hi"(%..string { ptr @"csbs$byte_world$1fa", i64 41 }, i32 208, i32 25, i64 %48, i64 %49, i64 %51)
  %52 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  %53 = load ptr, ptr %52, align 8
  %54 = getelementptr i8, ptr %53, i64 %48
  %55 = sub i64 %49, %48
  %56 = getelementptr inbounds nuw { ptr, i64 }, ptr %3, i32 0, i32 0
  store ptr %54, ptr %56, align 8
  %57 = getelementptr inbounds nuw { ptr, i64 }, ptr %3, i32 0, i32 1
  store i64 %55, ptr %57, align 8
  %58 = load { ptr, i64 }, ptr %3, align 8
  store i32 0, ptr %4, align 4
  %59 = call i64 @"utf8::decode_rune_in_bytes"({ ptr, i64 } %58, ptr %4)
  %60 = load i32, ptr %4, align 4
  %61 = load { i32, i64 }, ptr %5, align 8
  store i32 %60, ptr %r, align 4
  store i64 %59, ptr %size, align 8
  %62 = load i64, ptr %start, align 8
  %63 = load i64, ptr %size, align 8
  %64 = add i64 %62, %63
  %65 = load i64, ptr %end, align 8
  %66 = icmp ne i64 %64, %65
  %67 = zext i1 %66 to i8
  %68 = icmp ne i8 %67, 0
  br i1 %68, label %if.then5, label %if.done6

if.then5:                                         ; preds = %for.done
  store i32 65533, ptr %1, align 4
  ret i64 1

if.done6:                                         ; preds = %for.done
  %69 = load i32, ptr %r, align 4
  %70 = load i64, ptr %size, align 8
  store i32 %69, ptr %1, align 4
  ret i64 %70
}

define internal void @"main::free_pattern"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr inbounds nuw %"main::Pattern", ptr %3, i32 0, i32 2
  %5 = load { ptr, i64 }, ptr %4, align 8
  %6 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 0
  %7 = load %"runtime::Allocator", ptr %6, align 8
  %8 = load %"runtime::Source_Code_Location", ptr @"scl$[free_pattern4044]", align 8
  store %"runtime::Allocator" %7, ptr %2, align 8
  %9 = load { i64, i64 }, ptr %2, align 8
  %10 = call i8 @"runtime::delete_slice:proc(array:[]u8,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"({ ptr, i64 } %5, { i64, i64 } %9, ptr @"scl$[free_pattern4044]", ptr %__.context_ptr)
  %11 = load ptr, ptr %1, align 8
  %12 = getelementptr inbounds nuw %"main::Pattern", ptr %11, i32 0, i32 3
  %13 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %12, align 8
  %14 = load %"runtime::Source_Code_Location", ptr @"scl$[free_pattern4061]", align 8
  %15 = call i8 @"runtime::delete_dynamic_array:proc(array:[dynamic]main::Relative_Spark,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"(ptr %12, ptr @"scl$[free_pattern4061]", ptr %__.context_ptr)
  ret void
}

; Function Attrs: noinline
define internal void @"runtime::print_u64"(i64 %0) #4 {
decls:
  %1 = alloca i64, align 8
  %a = alloca [129 x i8], align 1
  %i = alloca i64, align 8
  %b = alloca i64, align 8
  %u = alloca i64, align 8
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca i64, align 8
  %4 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  call void @llvm.memset.p0.i64(ptr %a, i8 0, i64 129, i1 false)
  store i64 129, ptr %i, align 8
  store i64 10, ptr %b, align 8
  store i64 %0, ptr %u, align 8
  br label %for.loop

for.loop:                                         ; preds = %div.done, %entry
  %5 = load i64, ptr %u, align 8
  %6 = load i64, ptr %b, align 8
  %7 = icmp uge i64 %5, %6
  %8 = zext i1 %7 to i8
  %9 = icmp ne i8 %8, 0
  br i1 %9, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %10 = load i64, ptr %i, align 8
  %11 = sub i64 %10, 1
  store i64 %11, ptr %i, align 8
  %12 = load i64, ptr %i, align 8
  %13 = getelementptr [129 x i8], ptr %a, i64 0, i64 %12
  %14 = load %..string, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %15 = load ptr, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %16 = load i64, ptr getelementptr (%..string, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", i64 0, i32 1), align 8
  %17 = load i64, ptr %u, align 8
  %18 = load i64, ptr %b, align 8
  %19 = icmp ne i64 %18, 0
  br i1 %19, label %mod.safe, label %mod.edge

mod.safe:                                         ; preds = %for.body
  %20 = urem i64 %17, %18
  br label %mod.done

mod.edge:                                         ; preds = %for.body
  call void @llvm.trap()
  unreachable

mod.done:                                         ; preds = %mod.safe
  %21 = getelementptr i8, ptr %15, i64 %20
  %22 = load i8, ptr %21, align 1
  store i8 %22, ptr %13, align 1
  %23 = load i64, ptr %b, align 8
  %24 = load i64, ptr %u, align 8
  %25 = icmp ne i64 %23, 0
  br i1 %25, label %div.safe, label %div.edge

div.safe:                                         ; preds = %mod.done
  %26 = udiv i64 %24, %23
  br label %div.done

div.edge:                                         ; preds = %mod.done
  call void @llvm.trap()
  unreachable

div.done:                                         ; preds = %div.safe
  store i64 %26, ptr %u, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %27 = load i64, ptr %i, align 8
  %28 = sub i64 %27, 1
  store i64 %28, ptr %i, align 8
  %29 = load i64, ptr %i, align 8
  %30 = getelementptr [129 x i8], ptr %a, i64 0, i64 %29
  %31 = load %..string, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %32 = load ptr, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %33 = load i64, ptr getelementptr (%..string, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", i64 0, i32 1), align 8
  %34 = load i64, ptr %u, align 8
  %35 = load i64, ptr %b, align 8
  %36 = icmp ne i64 %35, 0
  br i1 %36, label %mod.safe1, label %mod.edge2

mod.safe1:                                        ; preds = %for.done
  %37 = urem i64 %34, %35
  br label %mod.done3

mod.edge2:                                        ; preds = %for.done
  call void @llvm.trap()
  unreachable

mod.done3:                                        ; preds = %mod.safe1
  %38 = getelementptr i8, ptr %32, i64 %37
  %39 = load i8, ptr %38, align 1
  store i8 %39, ptr %30, align 1
  %40 = load [129 x i8], ptr %a, align 1
  %41 = load i64, ptr %i, align 8
  %42 = getelementptr [129 x i8], ptr %a, i64 0, i64 0
  %43 = getelementptr i8, ptr %42, i64 %41
  %44 = sub i64 129, %41
  %45 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  store ptr %43, ptr %45, align 8
  %46 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  store i64 %44, ptr %46, align 8
  %47 = load { ptr, i64 }, ptr %2, align 8
  store i64 0, ptr %3, align 8
  %48 = call i64 @"runtime::stderr_write"({ ptr, i64 } %47, ptr %3)
  %49 = load i64, ptr %3, align 8
  %50 = load { i64, i64 }, ptr %4, align 8
  ret void
}

; Function Attrs: noinline
define internal i8 @"runtime::mem_free"(ptr %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull "captures"="none" %__.context_ptr) #4 {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca %"runtime::Allocator", align 16
  %5 = alloca { ptr, i64 }, align 8
  %6 = alloca { { ptr, i64 }, i8 }, align 8
  %err = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store { i64, i64 } %1, ptr %4, align 8
  %7 = load %"runtime::Allocator", ptr %4, align 8
  %8 = icmp eq ptr %0, null
  %9 = zext i1 %8 to i8
  %10 = icmp ne i8 %9, 0
  br i1 %10, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %entry
  %11 = getelementptr inbounds nuw %"runtime::Allocator", ptr %4, i32 0, i32 0
  %12 = load ptr, ptr %11, align 8
  %13 = icmp eq ptr %12, null
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %entry
  ret i8 0

if.done:                                          ; preds = %cmp.or
  %16 = getelementptr inbounds nuw %"runtime::Allocator", ptr %4, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr inbounds nuw %"runtime::Allocator", ptr %4, i32 0, i32 1
  %19 = load ptr, ptr %18, align 8
  %20 = load %"runtime::Source_Code_Location", ptr %2, align 8
  call void @llvm.memset.inline.p0.i64(ptr %5, i8 0, i64 16, i1 false)
  %21 = call i8 %17(ptr %19, i8 1, i64 0, i64 0, ptr %0, i64 0, ptr %2, ptr %5, ptr %__.context_ptr)
  %22 = load { ptr, i64 }, ptr %5, align 8
  %23 = load { { ptr, i64 }, i8 }, ptr %6, align 8
  store i8 %21, ptr %err, align 1
  %24 = load i8, ptr %err, align 1
  ret i8 %24
}

define internal void @"thread::[thread_unix.odin]::_start"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = load ptr, ptr %1, align 8
  %3 = getelementptr inbounds nuw %"thread::Thread", ptr %2, i32 0, i32 1
  %4 = atomicrmw volatile or ptr %3, i8 1 seq_cst, align 1
  %5 = load ptr, ptr %1, align 8
  %6 = getelementptr inbounds nuw %"thread::Thread", ptr %5, i32 0, i32 0
  %7 = getelementptr inbounds nuw %"thread::[thread_unix.odin]::Thread_Os_Specific", ptr %6, i32 0, i32 1
  call void @"sync::sema_post"(ptr %7, i64 1)
  ret void
}

; Function Attrs: alwaysinline
define internal i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]u8,src:[]u8)->(:int)"({ ptr, i64 } %0, { ptr, i64 } %1) #3 {
decls:
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca { ptr, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %2, align 8
  store { ptr, i64 } %1, ptr %3, align 8
  %4 = extractvalue { ptr, i64 } %0, 0
  %5 = extractvalue { ptr, i64 } %1, 0
  %6 = extractvalue { ptr, i64 } %0, 1
  %7 = extractvalue { ptr, i64 } %1, 1
  %8 = call i64 @"runtime::copy_slice_raw"(ptr %4, ptr %5, i64 %6, i64 %7, i64 1)
  ret i64 %8
}

; Function Attrs: alwaysinline
define internal i64 @"runtime::copy_from_string:proc\22contextless\22(dst:[]u8,src:string)->(:int)"({ ptr, i64 } %0, %..string %1) #3 {
decls:
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca %..string, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %2, align 8
  store %..string %1, ptr %3, align 8
  %4 = extractvalue { ptr, i64 } %0, 0
  %5 = extractvalue %..string %1, 0
  %6 = extractvalue { ptr, i64 } %0, 1
  %7 = extractvalue %..string %1, 1
  %8 = call i64 @"runtime::copy_slice_raw"(ptr %4, ptr %5, i64 %6, i64 %7, i64 1)
  ret i64 %8
}

define internal i8 @"os::write_entire_file"(%..string %0, { ptr, i64 } %1, i8 %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca %..string, align 8
  %4 = alloca { ptr, i64 }, align 8
  %5 = alloca i8, align 1
  %success = alloca i8, align 1
  %6 = alloca %"os::Error", align 16
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %3, align 8
  store { ptr, i64 } %1, ptr %4, align 8
  store i8 %2, ptr %5, align 1
  store i8 0, ptr %success, align 1
  %7 = call i64 @"os::write_entire_file_or_err"(%..string %0, { ptr, i64 } %1, i8 %2, ptr %__.context_ptr)
  store i64 %7, ptr %6, align 8
  %8 = load %"os::Error", ptr %6, align 4
  %9 = getelementptr inbounds nuw %"os::Error", ptr %6, i32 0, i32 1
  %10 = load i32, ptr %9, align 4
  %11 = icmp eq i32 %10, 0
  %12 = zext i1 %11 to i8
  store i8 %12, ptr %success, align 1
  ret i8 %12
}

declare i32 @pthread_attr_setschedparam(ptr, ptr)

define internal void @"strconv_decimal::shift_right"(ptr %0, i64 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %r = alloca i64, align 8
  %w = alloca i64, align 8
  %n = alloca i64, align 8
  %c = alloca i64, align 8
  %mask = alloca i64, align 8
  %c8 = alloca i64, align 8
  %dig = alloca i64, align 8
  %dig13 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  store i64 0, ptr %r, align 8
  store i64 0, ptr %w, align 8
  store i64 0, ptr %n, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %entry
  %4 = load i64, ptr %n, align 8
  %5 = icmp ult i64 %1, 64
  %6 = lshr i64 %4, %1
  %7 = select i1 %5, i64 %6, i64 0
  %8 = icmp eq i64 %7, 0
  %9 = zext i1 %8 to i8
  %10 = icmp ne i8 %9, 0
  br i1 %10, label %for.body, label %for.done5

for.body:                                         ; preds = %for.loop
  %11 = load i64, ptr %r, align 8
  %12 = load ptr, ptr %2, align 8
  %13 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %12, i32 0, i32 1
  %14 = load i64, ptr %13, align 8
  %15 = icmp sge i64 %11, %14
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %if.then, label %if.done4

if.then:                                          ; preds = %for.body
  %18 = load i64, ptr %n, align 8
  %19 = icmp eq i64 %18, 0
  %20 = zext i1 %19 to i8
  %21 = icmp ne i8 %20, 0
  br i1 %21, label %if.then1, label %if.done

if.then1:                                         ; preds = %if.then
  %22 = load ptr, ptr %2, align 8
  %23 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %22, i32 0, i32 1
  store i64 0, ptr %23, align 8
  ret void

if.done:                                          ; preds = %if.then
  br label %for.loop2

for.loop2:                                        ; preds = %for.body3, %if.done
  %24 = load i64, ptr %n, align 8
  %25 = icmp ult i64 %1, 64
  %26 = lshr i64 %24, %1
  %27 = select i1 %25, i64 %26, i64 0
  %28 = icmp eq i64 %27, 0
  %29 = zext i1 %28 to i8
  %30 = icmp ne i8 %29, 0
  br i1 %30, label %for.body3, label %for.done

for.body3:                                        ; preds = %for.loop2
  %31 = load i64, ptr %n, align 8
  %32 = mul i64 %31, 10
  store i64 %32, ptr %n, align 8
  %33 = load i64, ptr %r, align 8
  %34 = add i64 %33, 1
  store i64 %34, ptr %r, align 8
  br label %for.loop2

for.done:                                         ; preds = %for.loop2
  br label %for.done5

unreachable:                                      ; No predecessors!
  br label %if.done4

if.done4:                                         ; preds = %unreachable, %for.body
  %35 = load ptr, ptr %2, align 8
  %36 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %35, i32 0, i32 0
  %37 = load i64, ptr %r, align 8
  %38 = getelementptr [384 x i8], ptr %36, i64 0, i64 %37
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20a", i64 47 }, i32 220, i32 22, i64 %37, i64 384)
  %39 = load i8, ptr %38, align 1
  %40 = zext i8 %39 to i64
  store i64 %40, ptr %c, align 8
  %41 = load i64, ptr %n, align 8
  %42 = mul i64 %41, 10
  %43 = load i64, ptr %c, align 8
  %44 = add i64 %42, %43
  %45 = sub i64 %44, 48
  store i64 %45, ptr %n, align 8
  br label %for.post

for.post:                                         ; preds = %if.done4
  %46 = load i64, ptr %r, align 8
  %47 = add i64 %46, 1
  store i64 %47, ptr %r, align 8
  br label %for.loop

for.done5:                                        ; preds = %for.done, %for.loop
  %48 = load ptr, ptr %2, align 8
  %49 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %48, i32 0, i32 2
  %50 = load i64, ptr %r, align 8
  %51 = sub i64 %50, 1
  %52 = load i64, ptr %49, align 8
  %53 = sub i64 %52, %51
  store i64 %53, ptr %49, align 8
  %54 = icmp ult i64 %1, 64
  %55 = shl i64 1, %1
  %56 = select i1 %54, i64 %55, i64 0
  %57 = sub i64 %56, 1
  store i64 %57, ptr %mask, align 8
  br label %for.loop6

for.loop6:                                        ; preds = %for.post9, %for.done5
  %58 = load i64, ptr %r, align 8
  %59 = load ptr, ptr %2, align 8
  %60 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %59, i32 0, i32 1
  %61 = load i64, ptr %60, align 8
  %62 = icmp slt i64 %58, %61
  %63 = zext i1 %62 to i8
  %64 = icmp ne i8 %63, 0
  br i1 %64, label %for.body7, label %for.done10

for.body7:                                        ; preds = %for.loop6
  %65 = load ptr, ptr %2, align 8
  %66 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %65, i32 0, i32 0
  %67 = load i64, ptr %r, align 8
  %68 = getelementptr [384 x i8], ptr %66, i64 0, i64 %67
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20a", i64 47 }, i32 228, i32 22, i64 %67, i64 384)
  %69 = load i8, ptr %68, align 1
  %70 = zext i8 %69 to i64
  store i64 %70, ptr %c8, align 8
  %71 = load i64, ptr %n, align 8
  %72 = icmp ult i64 %1, 64
  %73 = lshr i64 %71, %1
  %74 = select i1 %72, i64 %73, i64 0
  store i64 %74, ptr %dig, align 8
  %75 = load i64, ptr %mask, align 8
  %76 = load i64, ptr %n, align 8
  %77 = and i64 %76, %75
  store i64 %77, ptr %n, align 8
  %78 = load ptr, ptr %2, align 8
  %79 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %78, i32 0, i32 0
  %80 = load i64, ptr %w, align 8
  %81 = getelementptr [384 x i8], ptr %79, i64 0, i64 %80
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20a", i64 47 }, i32 231, i32 12, i64 %80, i64 384)
  %82 = load i64, ptr %dig, align 8
  %83 = add i64 48, %82
  %84 = trunc i64 %83 to i8
  store i8 %84, ptr %81, align 1
  %85 = load i64, ptr %w, align 8
  %86 = add i64 %85, 1
  store i64 %86, ptr %w, align 8
  %87 = load i64, ptr %n, align 8
  %88 = mul i64 %87, 10
  %89 = load i64, ptr %c8, align 8
  %90 = add i64 %88, %89
  %91 = sub i64 %90, 48
  store i64 %91, ptr %n, align 8
  br label %for.post9

for.post9:                                        ; preds = %for.body7
  %92 = load i64, ptr %r, align 8
  %93 = add i64 %92, 1
  store i64 %93, ptr %r, align 8
  br label %for.loop6

for.done10:                                       ; preds = %for.loop6
  br label %for.loop11

for.loop11:                                       ; preds = %if.done17, %for.done10
  %94 = load i64, ptr %n, align 8
  %95 = icmp ugt i64 %94, 0
  %96 = zext i1 %95 to i8
  %97 = icmp ne i8 %96, 0
  br i1 %97, label %for.body12, label %for.done18

for.body12:                                       ; preds = %for.loop11
  %98 = load i64, ptr %n, align 8
  %99 = icmp ult i64 %1, 64
  %100 = lshr i64 %98, %1
  %101 = select i1 %99, i64 %100, i64 0
  store i64 %101, ptr %dig13, align 8
  %102 = load i64, ptr %mask, align 8
  %103 = load i64, ptr %n, align 8
  %104 = and i64 %103, %102
  store i64 %104, ptr %n, align 8
  %105 = load i64, ptr %w, align 8
  %106 = icmp slt i64 %105, 384
  %107 = zext i1 %106 to i8
  %108 = icmp ne i8 %107, 0
  br i1 %108, label %if.then14, label %if.else

if.then14:                                        ; preds = %for.body12
  %109 = load ptr, ptr %2, align 8
  %110 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %109, i32 0, i32 0
  %111 = load i64, ptr %w, align 8
  %112 = getelementptr [384 x i8], ptr %110, i64 0, i64 %111
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20a", i64 47 }, i32 240, i32 13, i64 %111, i64 384)
  %113 = load i64, ptr %dig13, align 8
  %114 = add i64 48, %113
  %115 = trunc i64 %114 to i8
  store i8 %115, ptr %112, align 1
  %116 = load i64, ptr %w, align 8
  %117 = add i64 %116, 1
  store i64 %117, ptr %w, align 8
  br label %if.done17

if.else:                                          ; preds = %for.body12
  %118 = load i64, ptr %dig13, align 8
  %119 = icmp ugt i64 %118, 0
  %120 = zext i1 %119 to i8
  %121 = icmp ne i8 %120, 0
  br i1 %121, label %if.then15, label %if.done16

if.then15:                                        ; preds = %if.else
  %122 = load ptr, ptr %2, align 8
  %123 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %122, i32 0, i32 4
  store i8 1, ptr %123, align 1
  br label %if.done16

if.done16:                                        ; preds = %if.then15, %if.else
  br label %if.done17

if.done17:                                        ; preds = %if.done16, %if.then14
  %124 = load i64, ptr %n, align 8
  %125 = mul i64 %124, 10
  store i64 %125, ptr %n, align 8
  br label %for.loop11

for.done18:                                       ; preds = %for.loop11
  %126 = load ptr, ptr %2, align 8
  %127 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %126, i32 0, i32 1
  %128 = load i64, ptr %w, align 8
  store i64 %128, ptr %127, align 8
  call void @"strconv_decimal::trim"(ptr %0, ptr %__.context_ptr)
  ret void
}

define internal %..string @"strconv::write_bits_128"({ ptr, i64 } %0, i128 %1, i64 %2, i8 %3, i64 %4, ptr byval(%..string) align 8 %5, i8 %6, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %7 = alloca { ptr, i64 }, align 8
  %8 = alloca i128, align 16
  %9 = alloca i64, align 8
  %10 = alloca i8, align 1
  %11 = alloca i64, align 8
  %12 = alloca %..string, align 8
  %13 = alloca i8, align 1
  %a = alloca [140 x i8], align 1
  %i = alloca i64, align 8
  %14 = alloca i128, align 16
  %15 = alloca { i128, i8 }, align 16
  %u = alloca i128, align 16
  %neg = alloca i8, align 1
  %b = alloca i128, align 16
  %rem = alloca i128, align 16
  %idx = alloca i32, align 4
  %ok = alloca i8, align 1
  %16 = alloca { ptr, i64 }, align 8
  %out = alloca { ptr, i64 }, align 8
  %17 = alloca { ptr, i64 }, align 8
  %18 = alloca %..string, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %7, align 8
  store i128 %1, ptr %8, align 16
  store i64 %2, ptr %9, align 8
  store i8 %3, ptr %10, align 1
  store i64 %4, ptr %11, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %12, ptr %5, i64 16, i1 false)
  store i8 %6, ptr %13, align 1
  %19 = icmp slt i64 %2, 2
  %20 = zext i1 %19 to i8
  %21 = icmp ne i8 %20, 0
  br i1 %21, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %entry
  %22 = icmp sgt i64 %2, 32
  %23 = zext i1 %22 to i8
  %24 = icmp ne i8 %23, 0
  br i1 %24, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %entry
  %25 = load %"runtime::Source_Code_Location", ptr @"scl$[write_bits_1284502]", align 8
  call void @"runtime::panic"(%..string { ptr @"csbs$byte_world$1f7", i64 42 }, ptr @"scl$[write_bits_1284502]", ptr %__.context_ptr)
  unreachable

if.done:                                          ; preds = %cmp.or
  call void @llvm.memset.p0.i64(ptr %a, i8 0, i64 140, i1 false)
  store i64 140, ptr %i, align 8
  store i128 0, ptr %14, align 16
  %26 = call i8 @"strconv::is_integer_negative_128"(i128 %1, i8 %3, i64 %4, ptr %14, ptr %__.context_ptr)
  %27 = load i128, ptr %14, align 16
  %28 = load { i128, i8 }, ptr %15, align 16
  store i128 %27, ptr %u, align 16
  store i8 %26, ptr %neg, align 1
  %29 = sext i64 %2 to i128
  store i128 %29, ptr %b, align 16
  br label %for.loop

for.loop:                                         ; preds = %div.done, %if.done
  %30 = load i128, ptr %u, align 16
  %31 = load i128, ptr %b, align 16
  %32 = icmp uge i128 %30, %31
  %33 = zext i1 %32 to i8
  %34 = icmp ne i8 %33, 0
  br i1 %34, label %cmp.and, label %for.done

cmp.and:                                          ; preds = %for.loop
  %35 = load i64, ptr %i, align 8
  %36 = icmp sge i64 %35, 0
  %37 = zext i1 %36 to i8
  %38 = icmp ne i8 %37, 0
  br i1 %38, label %for.body, label %for.done

for.body:                                         ; preds = %cmp.and
  %39 = load i64, ptr %i, align 8
  %40 = sub i64 %39, 1
  store i64 %40, ptr %i, align 8
  %41 = load i128, ptr %u, align 16
  %42 = load i128, ptr %b, align 16
  %43 = icmp ne i128 %42, 0
  br i1 %43, label %mod.safe, label %mod.edge

mod.safe:                                         ; preds = %for.body
  %44 = urem i128 %41, %42
  br label %mod.done

mod.edge:                                         ; preds = %for.body
  call void @llvm.trap()
  unreachable

mod.done:                                         ; preds = %mod.safe
  store i128 %44, ptr %rem, align 16
  %45 = load i128, ptr %b, align 16
  %46 = load i128, ptr %u, align 16
  %47 = icmp ne i128 %45, 0
  br i1 %47, label %div.safe, label %div.edge

div.safe:                                         ; preds = %mod.done
  %48 = udiv i128 %46, %45
  br label %div.done

div.edge:                                         ; preds = %mod.done
  call void @llvm.trap()
  unreachable

div.done:                                         ; preds = %div.safe
  store i128 %48, ptr %u, align 16
  %49 = load i128, ptr %rem, align 16
  %50 = trunc i128 %49 to i32
  store i32 %50, ptr %idx, align 4
  %51 = load i64, ptr %i, align 8
  %52 = getelementptr [140 x i8], ptr %a, i64 0, i64 %51
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 181, i32 5, i64 %51, i64 140)
  %53 = load %..string, ptr %12, align 8
  %54 = getelementptr inbounds nuw %..string, ptr %12, i32 0, i32 0
  %55 = load ptr, ptr %54, align 8
  %56 = getelementptr inbounds nuw %..string, ptr %12, i32 0, i32 1
  %57 = load i64, ptr %56, align 8
  %58 = load i32, ptr %idx, align 4
  %59 = zext i32 %58 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 181, i32 17, i64 %59, i64 %57)
  %60 = getelementptr i8, ptr %55, i64 %59
  %61 = load i8, ptr %60, align 1
  store i8 %61, ptr %52, align 1
  br label %for.loop

for.done:                                         ; preds = %cmp.and, %for.loop
  %62 = load i64, ptr %i, align 8
  %63 = sub i64 %62, 1
  store i64 %63, ptr %i, align 8
  %64 = load i64, ptr %i, align 8
  %65 = getelementptr [140 x i8], ptr %a, i64 0, i64 %64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 183, i32 10, i64 %64, i64 140)
  %66 = load %..string, ptr %12, align 8
  %67 = getelementptr inbounds nuw %..string, ptr %12, i32 0, i32 0
  %68 = load ptr, ptr %67, align 8
  %69 = getelementptr inbounds nuw %..string, ptr %12, i32 0, i32 1
  %70 = load i64, ptr %69, align 8
  %71 = load i128, ptr %u, align 16
  %72 = load i128, ptr %b, align 16
  %73 = icmp ne i128 %72, 0
  br i1 %73, label %mod.safe1, label %mod.edge2

mod.safe1:                                        ; preds = %for.done
  %74 = urem i128 %71, %72
  br label %mod.done3

mod.edge2:                                        ; preds = %for.done
  call void @llvm.trap()
  unreachable

mod.done3:                                        ; preds = %mod.safe1
  %75 = trunc i128 %74 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 183, i32 22, i64 %75, i64 %70)
  %76 = getelementptr i8, ptr %68, i64 %75
  %77 = load i8, ptr %76, align 1
  store i8 %77, ptr %65, align 1
  %78 = and i8 %6, 1
  %79 = icmp ne i8 %78, 0
  %80 = zext i1 %79 to i8
  %81 = icmp ne i8 %80, 0
  br i1 %81, label %if.then4, label %if.done11

if.then4:                                         ; preds = %mod.done3
  store i8 1, ptr %ok, align 1
  switch i64 %2, label %switch.default.body [
    i64 2, label %switch.case.body
    i64 8, label %switch.case.body5
    i64 10, label %switch.case.body6
    i64 12, label %switch.case.body7
    i64 16, label %switch.case.body8
  ]

switch.case.body:                                 ; preds = %if.then4
  %82 = load i64, ptr %i, align 8
  %83 = sub i64 %82, 1
  store i64 %83, ptr %i, align 8
  %84 = load i64, ptr %i, align 8
  %85 = getelementptr [140 x i8], ptr %a, i64 0, i64 %84
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 188, i32 20, i64 %84, i64 140)
  store i8 98, ptr %85, align 1
  br label %switch.done

switch.case.body5:                                ; preds = %if.then4
  %86 = load i64, ptr %i, align 8
  %87 = sub i64 %86, 1
  store i64 %87, ptr %i, align 8
  %88 = load i64, ptr %i, align 8
  %89 = getelementptr [140 x i8], ptr %a, i64 0, i64 %88
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 189, i32 20, i64 %88, i64 140)
  store i8 111, ptr %89, align 1
  br label %switch.done

switch.case.body6:                                ; preds = %if.then4
  %90 = load i64, ptr %i, align 8
  %91 = sub i64 %90, 1
  store i64 %91, ptr %i, align 8
  %92 = load i64, ptr %i, align 8
  %93 = getelementptr [140 x i8], ptr %a, i64 0, i64 %92
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 190, i32 20, i64 %92, i64 140)
  store i8 100, ptr %93, align 1
  br label %switch.done

switch.case.body7:                                ; preds = %if.then4
  %94 = load i64, ptr %i, align 8
  %95 = sub i64 %94, 1
  store i64 %95, ptr %i, align 8
  %96 = load i64, ptr %i, align 8
  %97 = getelementptr [140 x i8], ptr %a, i64 0, i64 %96
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 191, i32 20, i64 %96, i64 140)
  store i8 122, ptr %97, align 1
  br label %switch.done

switch.case.body8:                                ; preds = %if.then4
  %98 = load i64, ptr %i, align 8
  %99 = sub i64 %98, 1
  store i64 %99, ptr %i, align 8
  %100 = load i64, ptr %i, align 8
  %101 = getelementptr [140 x i8], ptr %a, i64 0, i64 %100
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 192, i32 20, i64 %100, i64 140)
  store i8 120, ptr %101, align 1
  br label %switch.done

switch.default.body:                              ; preds = %if.then4
  store i8 0, ptr %ok, align 1
  br label %switch.done

switch.done:                                      ; preds = %switch.default.body, %switch.case.body8, %switch.case.body7, %switch.case.body6, %switch.case.body5, %switch.case.body
  %102 = load i8, ptr %ok, align 1
  %103 = icmp ne i8 %102, 0
  br i1 %103, label %if.then9, label %if.done10

if.then9:                                         ; preds = %switch.done
  %104 = load i64, ptr %i, align 8
  %105 = sub i64 %104, 1
  store i64 %105, ptr %i, align 8
  %106 = load i64, ptr %i, align 8
  %107 = getelementptr [140 x i8], ptr %a, i64 0, i64 %106
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 196, i32 12, i64 %106, i64 140)
  store i8 48, ptr %107, align 1
  br label %if.done10

if.done10:                                        ; preds = %if.then9, %switch.done
  br label %if.done11

if.done11:                                        ; preds = %if.done10, %mod.done3
  %108 = load i8, ptr %neg, align 1
  %109 = icmp eq i8 1, %108
  br i1 %109, label %switch.case.body12, label %switch.case.next

switch.case.next:                                 ; preds = %if.done11
  %110 = and i8 %6, 2
  %111 = icmp ne i8 %110, 0
  %112 = zext i1 %111 to i8
  %113 = icmp eq i8 1, %112
  br i1 %113, label %switch.case.body14, label %switch.case.next13

switch.case.body12:                               ; preds = %if.done11
  %114 = load i64, ptr %i, align 8
  %115 = sub i64 %114, 1
  store i64 %115, ptr %i, align 8
  %116 = load i64, ptr %i, align 8
  %117 = getelementptr [140 x i8], ptr %a, i64 0, i64 %116
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 202, i32 11, i64 %116, i64 140)
  store i8 45, ptr %117, align 1
  br label %switch.done15

switch.case.next13:                               ; preds = %switch.case.next
  br label %switch.done15

switch.case.body14:                               ; preds = %switch.case.next
  %118 = load i64, ptr %i, align 8
  %119 = sub i64 %118, 1
  store i64 %119, ptr %i, align 8
  %120 = load i64, ptr %i, align 8
  %121 = getelementptr [140 x i8], ptr %a, i64 0, i64 %120
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 204, i32 11, i64 %120, i64 140)
  store i8 43, ptr %121, align 1
  br label %switch.done15

switch.done15:                                    ; preds = %switch.case.next13, %switch.case.body14, %switch.case.body12
  %122 = load [140 x i8], ptr %a, align 1
  %123 = load i64, ptr %i, align 8
  call void @"runtime::slice_expr_error_lo_hi"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 207, i32 10, i64 %123, i64 140, i64 140)
  %124 = getelementptr [140 x i8], ptr %a, i64 0, i64 0
  %125 = getelementptr i8, ptr %124, i64 %123
  %126 = sub i64 140, %123
  %127 = getelementptr inbounds nuw { ptr, i64 }, ptr %16, i32 0, i32 0
  store ptr %125, ptr %127, align 8
  %128 = getelementptr inbounds nuw { ptr, i64 }, ptr %16, i32 0, i32 1
  store i64 %126, ptr %128, align 8
  %129 = load { ptr, i64 }, ptr %16, align 8
  store { ptr, i64 } %129, ptr %out, align 8
  %130 = load { ptr, i64 }, ptr %out, align 8
  %131 = call i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]u8,src:[]u8)->(:int)"({ ptr, i64 } %0, { ptr, i64 } %130)
  %132 = load { ptr, i64 }, ptr %7, align 8
  %133 = load { ptr, i64 }, ptr %out, align 8
  %134 = getelementptr inbounds nuw { ptr, i64 }, ptr %out, i32 0, i32 1
  %135 = load i64, ptr %134, align 8
  %136 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 1
  %137 = load i64, ptr %136, align 8
  call void @"runtime::slice_expr_error_lo_hi"(%..string { ptr @"csbs$byte_world$1dd", i64 40 }, i32 209, i32 19, i64 0, i64 %135, i64 %137)
  %138 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 0
  %139 = load ptr, ptr %138, align 8
  %140 = getelementptr i8, ptr %139, i64 0
  %141 = sub i64 %135, 0
  %142 = getelementptr inbounds nuw { ptr, i64 }, ptr %17, i32 0, i32 0
  store ptr %140, ptr %142, align 8
  %143 = getelementptr inbounds nuw { ptr, i64 }, ptr %17, i32 0, i32 1
  store i64 %141, ptr %143, align 8
  %144 = load { ptr, i64 }, ptr %17, align 8
  %145 = load %..string, ptr %17, align 8
  store %..string %145, ptr %18, align 8
  %146 = load %..string, ptr %18, align 8
  ret %..string %146
}

define internal void @"thread::[thread_unix.odin]::_join"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = call i64 @pthread_self()
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr inbounds nuw %"thread::Thread", ptr %3, i32 0, i32 0
  %5 = getelementptr inbounds nuw %"thread::[thread_unix.odin]::Thread_Os_Specific", ptr %4, i32 0, i32 0
  %6 = load i64, ptr %5, align 8
  %7 = call i32 @pthread_equal(i64 %2, i64 %6)
  %8 = icmp ne i32 %7, 0
  br i1 %8, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  %9 = load ptr, ptr %1, align 8
  %10 = getelementptr inbounds nuw %"thread::Thread", ptr %9, i32 0, i32 1
  %11 = atomicrmw volatile or ptr %10, i8 2 seq_cst, align 1
  %12 = and i8 %11, 2
  %13 = icmp ne i8 %12, 0
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.done
  ret void

if.done2:                                         ; preds = %if.done
  br label %for.loop

for.loop:                                         ; preds = %for.body, %if.done2
  %16 = load ptr, ptr %1, align 8
  %17 = getelementptr inbounds nuw %"thread::Thread", ptr %16, i32 0, i32 1
  %18 = load atomic volatile i8, ptr %17 seq_cst, align 1
  %19 = and i8 %18, 1
  %20 = icmp eq i8 %19, 0
  %21 = zext i1 %20 to i8
  %22 = icmp ne i8 %21, 0
  br i1 %22, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  call void @"thread::[thread_unix.odin]::_start"(ptr %0, ptr %__.context_ptr)
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %23 = load ptr, ptr %1, align 8
  %24 = getelementptr inbounds nuw %"thread::Thread", ptr %23, i32 0, i32 0
  %25 = getelementptr inbounds nuw %"thread::[thread_unix.odin]::Thread_Os_Specific", ptr %24, i32 0, i32 0
  %26 = load i64, ptr %25, align 8
  %27 = call i32 @pthread_join(i64 %26, ptr null)
  %28 = load ptr, ptr %1, align 8
  %29 = getelementptr inbounds nuw %"thread::Thread", ptr %28, i32 0, i32 1
  %30 = load i8, ptr %29, align 1
  %31 = or i8 %30, 2
  store i8 %31, ptr %29, align 1
  ret void
}

; Function Attrs: noinline
define internal void @"runtime::print_i64"(i64 %0) #4 {
decls:
  %1 = alloca i64, align 8
  %u = alloca i64, align 8
  %neg = alloca i8, align 1
  %a = alloca [129 x i8], align 1
  %i = alloca i64, align 8
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca i64, align 8
  %4 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  store i64 %0, ptr %u, align 8
  %5 = load i64, ptr %u, align 8
  %6 = icmp slt i64 %5, 0
  %7 = zext i1 %6 to i8
  store i8 %7, ptr %neg, align 1
  %8 = load i64, ptr %u, align 8
  %9 = icmp slt i64 %8, 0
  %10 = sub i64 0, %8
  %11 = select i1 %9, i64 %10, i64 %8
  store i64 %11, ptr %u, align 8
  call void @llvm.memset.p0.i64(ptr %a, i8 0, i64 129, i1 false)
  store i64 129, ptr %i, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.body, %entry
  %12 = load i64, ptr %u, align 8
  %13 = icmp sge i64 %12, 10
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %16 = load i64, ptr %i, align 8
  %17 = sub i64 %16, 1
  store i64 %17, ptr %i, align 8
  %18 = load i64, ptr %i, align 8
  %19 = getelementptr [129 x i8], ptr %a, i64 0, i64 %18
  %20 = load %..string, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %21 = load ptr, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %22 = load i64, ptr getelementptr (%..string, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", i64 0, i32 1), align 8
  %23 = load i64, ptr %u, align 8
  %24 = srem i64 %23, 10
  %25 = getelementptr i8, ptr %21, i64 %24
  %26 = load i8, ptr %25, align 1
  store i8 %26, ptr %19, align 1
  %27 = load i64, ptr %u, align 8
  %28 = sdiv i64 %27, 10
  store i64 %28, ptr %u, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %29 = load i64, ptr %i, align 8
  %30 = sub i64 %29, 1
  store i64 %30, ptr %i, align 8
  %31 = load i64, ptr %i, align 8
  %32 = getelementptr [129 x i8], ptr %a, i64 0, i64 %31
  %33 = load %..string, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %34 = load ptr, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", align 8
  %35 = load i64, ptr getelementptr (%..string, ptr @"runtime::[print.odin]::_INTEGER_DIGITS_VAR", i64 0, i32 1), align 8
  %36 = load i64, ptr %u, align 8
  %37 = srem i64 %36, 10
  %38 = getelementptr i8, ptr %34, i64 %37
  %39 = load i8, ptr %38, align 1
  store i8 %39, ptr %32, align 1
  %40 = load i8, ptr %neg, align 1
  %41 = icmp ne i8 %40, 0
  br i1 %41, label %if.then, label %if.done

if.then:                                          ; preds = %for.done
  %42 = load i64, ptr %i, align 8
  %43 = sub i64 %42, 1
  store i64 %43, ptr %i, align 8
  %44 = load i64, ptr %i, align 8
  %45 = getelementptr [129 x i8], ptr %a, i64 0, i64 %44
  store i8 45, ptr %45, align 1
  br label %if.done

if.done:                                          ; preds = %if.then, %for.done
  %46 = load [129 x i8], ptr %a, align 1
  %47 = load i64, ptr %i, align 8
  %48 = getelementptr [129 x i8], ptr %a, i64 0, i64 0
  %49 = getelementptr i8, ptr %48, i64 %47
  %50 = sub i64 129, %47
  %51 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  store ptr %49, ptr %51, align 8
  %52 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  store i64 %50, ptr %52, align 8
  %53 = load { ptr, i64 }, ptr %2, align 8
  store i64 0, ptr %3, align 8
  %54 = call i64 @"runtime::stderr_write"({ ptr, i64 } %53, ptr %3)
  %55 = load i64, ptr %3, align 8
  %56 = load { i64, i64 }, ptr %4, align 8
  ret void
}

define internal i32 @"io::write_escaped_rune"({ i64, i64 } %0, i32 %1, i8 %2, i8 %3, ptr %4, i8 %5, ptr noalias nonnull %6, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %7 = alloca %"io::Stream", align 16
  %8 = alloca i32, align 4
  %9 = alloca i8, align 1
  %10 = alloca i8, align 1
  %11 = alloca ptr, align 8
  %12 = alloca i8, align 1
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  %13 = alloca { i64, i64 }, align 16
  %14 = alloca { i64, i64 }, align 16
  %s = alloca i64, align 8
  %15 = alloca { i64, i64 }, align 16
  %16 = alloca { i64, i64 }, align 16
  %17 = alloca { i64, i64 }, align 16
  %18 = alloca { i64, i64 }, align 16
  %19 = alloca i64, align 8
  %20 = alloca { i64, i32 }, align 8
  %21 = alloca { i64, i64 }, align 16
  %22 = alloca i64, align 8
  %23 = alloca { i64, i32 }, align 8
  %24 = alloca { i64, i64 }, align 16
  %25 = alloca i64, align 8
  %26 = alloca { i64, i32 }, align 8
  %27 = alloca { i64, i64 }, align 16
  %28 = alloca i64, align 8
  %29 = alloca { i64, i32 }, align 8
  %30 = alloca { i64, i64 }, align 16
  %31 = alloca i64, align 8
  %32 = alloca { i64, i32 }, align 8
  %33 = alloca { i64, i64 }, align 16
  %34 = alloca i64, align 8
  %35 = alloca { i64, i32 }, align 8
  %36 = alloca { i64, i64 }, align 16
  %37 = alloca { i64, i64 }, align 16
  %38 = alloca { i64, i64 }, align 16
  %39 = alloca { i64, i64 }, align 16
  %40 = alloca { i64, i64 }, align 16
  %41 = alloca { i64, i64 }, align 16
  %42 = alloca { i64, i64 }, align 16
  %43 = alloca i64, align 8
  %44 = alloca { i64, i32 }, align 8
  %45 = alloca { i64, i64 }, align 16
  %46 = alloca i64, align 8
  %47 = alloca { i64, i32 }, align 8
  %48 = alloca { i64, i64 }, align 16
  %49 = alloca i64, align 8
  %50 = alloca { i64, i32 }, align 8
  %51 = alloca { i64, i64 }, align 16
  %52 = alloca i64, align 8
  %53 = alloca { i64, i32 }, align 8
  %54 = alloca { i64, i64 }, align 16
  %55 = alloca i64, align 8
  %56 = alloca { i64, i32 }, align 8
  %57 = alloca { i64, i64 }, align 16
  %58 = alloca i64, align 8
  %59 = alloca { i64, i32 }, align 8
  %60 = alloca { i64, i64 }, align 16
  %61 = alloca i64, align 8
  %62 = alloca { i64, i32 }, align 8
  %63 = alloca { i64, i64 }, align 16
  %64 = alloca i64, align 8
  %65 = alloca { i64, i32 }, align 8
  %c = alloca i32, align 4
  %66 = alloca { i64, i64 }, align 16
  %67 = alloca { i64, i64 }, align 16
  %68 = alloca { i64, i64 }, align 16
  %69 = alloca { i64, i64 }, align 16
  %70 = alloca { i64, i64 }, align 16
  %71 = alloca { i64, i64 }, align 16
  %s192 = alloca i64, align 8
  %72 = alloca { i64, i64 }, align 16
  %buf = alloca [2 x i16], align 2
  %73 = alloca { ptr, i64 }, align 8
  %74 = alloca { ptr, i64 }, align 8
  %75 = alloca [1 x i32], align 16
  %76 = alloca { ptr, i64 }, align 8
  %77 = alloca i64, align 8
  %78 = alloca i64, align 8
  %bc = alloca i16, align 2
  %79 = alloca { i64, i64 }, align 16
  %80 = alloca { i64, i64 }, align 16
  %s215 = alloca i64, align 8
  %81 = alloca { i64, i64 }, align 16
  %82 = alloca { i64, i64 }, align 16
  %83 = alloca { i64, i64 }, align 16
  %s237 = alloca i64, align 8
  %84 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %7, align 8
  %85 = load %"io::Stream", ptr %7, align 8
  store i32 %1, ptr %8, align 4
  store i8 %2, ptr %9, align 1
  store i8 %3, ptr %10, align 1
  store ptr %4, ptr %11, align 8
  store i8 %5, ptr %12, align 1
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  %86 = icmp ne i8 %3, 0
  br i1 %86, label %if.then, label %if.done15

if.then:                                          ; preds = %entry
  switch i32 %1, label %switch.done [
    i32 60, label %switch.case.body
    i32 62, label %switch.case.body
    i32 38, label %switch.case.body
  ]

switch.case.body:                                 ; preds = %if.then, %if.then, %if.then
  store %"io::Stream" %85, ptr %13, align 8
  %87 = load { i64, i64 }, ptr %13, align 8
  %88 = call i32 @"io::write_byte"({ i64, i64 } %87, i8 92, ptr %n, ptr %__.context_ptr)
  %89 = icmp eq i32 %88, 0
  br i1 %89, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %switch.case.body
  store i32 %88, ptr %err, align 4
  %90 = load i64, ptr %n, align 8
  %91 = load i32, ptr %err, align 4
  store i64 %90, ptr %n, align 8
  store i32 %91, ptr %err, align 4
  store i64 %90, ptr %6, align 8
  br label %defer

defer:                                            ; preds = %or_return.return
  %92 = icmp ne ptr %4, null
  %93 = zext i1 %92 to i8
  %94 = icmp ne i8 %93, 0
  br i1 %94, label %if.then1, label %if.done

if.then1:                                         ; preds = %defer
  %95 = load i64, ptr %n, align 8
  %96 = load i64, ptr %4, align 8
  %97 = add i64 %96, %95
  store i64 %97, ptr %4, align 8
  br label %if.done

if.done:                                          ; preds = %if.then1, %defer
  ret i32 %91

or_return.continue:                               ; preds = %switch.case.body
  store %"io::Stream" %85, ptr %14, align 8
  %98 = load { i64, i64 }, ptr %14, align 8
  %99 = call i32 @"io::write_byte"({ i64, i64 } %98, i8 117, ptr %n, ptr %__.context_ptr)
  %100 = icmp eq i32 %99, 0
  br i1 %100, label %or_return.continue6, label %or_return.return2

or_return.return2:                                ; preds = %or_return.continue
  store i32 %99, ptr %err, align 4
  %101 = load i64, ptr %n, align 8
  %102 = load i32, ptr %err, align 4
  store i64 %101, ptr %n, align 8
  store i32 %102, ptr %err, align 4
  store i64 %101, ptr %6, align 8
  br label %defer3

defer3:                                           ; preds = %or_return.return2
  %103 = icmp ne ptr %4, null
  %104 = zext i1 %103 to i8
  %105 = icmp ne i8 %104, 0
  br i1 %105, label %if.then4, label %if.done5

if.then4:                                         ; preds = %defer3
  %106 = load i64, ptr %n, align 8
  %107 = load i64, ptr %4, align 8
  %108 = add i64 %107, %106
  store i64 %108, ptr %4, align 8
  br label %if.done5

if.done5:                                         ; preds = %if.then4, %defer3
  ret i32 %102

or_return.continue6:                              ; preds = %or_return.continue
  br label %for.init

for.init:                                         ; preds = %or_return.continue6
  store i64 12, ptr %s, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %for.init
  %109 = load i64, ptr %s, align 8
  %110 = icmp sge i64 %109, 0
  %111 = zext i1 %110 to i8
  %112 = icmp ne i8 %111, 0
  br i1 %112, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %113 = load %..string, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %114 = load ptr, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %115 = load i64, ptr getelementptr (%..string, ptr @"io::[util.odin]::DIGITS_LOWER", i64 0, i32 1), align 8
  %116 = load i64, ptr %s, align 8
  %117 = trunc i64 %116 to i32
  %118 = icmp ult i32 %117, 32
  %119 = ashr i32 %1, %117
  %120 = select i1 %118, i32 %119, i32 0
  %121 = and i32 %120, 15
  %122 = sext i32 %121 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 178, i32 32, i64 %122, i64 %115)
  %123 = getelementptr i8, ptr %114, i64 %122
  %124 = load i8, ptr %123, align 1
  store %"io::Stream" %85, ptr %15, align 8
  %125 = load { i64, i64 }, ptr %15, align 8
  %126 = call i32 @"io::write_byte"({ i64, i64 } %125, i8 %124, ptr %n, ptr %__.context_ptr)
  %127 = icmp eq i32 %126, 0
  br i1 %127, label %or_return.continue11, label %or_return.return7

or_return.return7:                                ; preds = %for.body
  store i32 %126, ptr %err, align 4
  %128 = load i64, ptr %n, align 8
  %129 = load i32, ptr %err, align 4
  store i64 %128, ptr %n, align 8
  store i32 %129, ptr %err, align 4
  store i64 %128, ptr %6, align 8
  br label %defer8

defer8:                                           ; preds = %or_return.return7
  %130 = icmp ne ptr %4, null
  %131 = zext i1 %130 to i8
  %132 = icmp ne i8 %131, 0
  br i1 %132, label %if.then9, label %if.done10

if.then9:                                         ; preds = %defer8
  %133 = load i64, ptr %n, align 8
  %134 = load i64, ptr %4, align 8
  %135 = add i64 %134, %133
  store i64 %135, ptr %4, align 8
  br label %if.done10

if.done10:                                        ; preds = %if.then9, %defer8
  ret i32 %129

or_return.continue11:                             ; preds = %for.body
  br label %for.post

for.post:                                         ; preds = %or_return.continue11
  %136 = load i64, ptr %s, align 8
  %137 = sub i64 %136, 4
  store i64 %137, ptr %s, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %138 = load i64, ptr %n, align 8
  %139 = load i32, ptr %err, align 4
  store i64 %138, ptr %n, align 8
  store i32 %139, ptr %err, align 4
  store i64 %138, ptr %6, align 8
  br label %defer12

defer12:                                          ; preds = %for.done
  %140 = icmp ne ptr %4, null
  %141 = zext i1 %140 to i8
  %142 = icmp ne i8 %141, 0
  br i1 %142, label %if.then13, label %if.done14

if.then13:                                        ; preds = %defer12
  %143 = load i64, ptr %n, align 8
  %144 = load i64, ptr %4, align 8
  %145 = add i64 %144, %143
  store i64 %145, ptr %4, align 8
  br label %if.done14

if.done14:                                        ; preds = %if.then13, %defer12
  ret i32 %139

switch.done:                                      ; preds = %if.then
  br label %if.done15

if.done15:                                        ; preds = %switch.done, %entry
  %146 = zext i8 %2 to i32
  %147 = icmp eq i32 %1, %146
  %148 = zext i1 %147 to i8
  %149 = icmp ne i8 %148, 0
  br i1 %149, label %if.then16, label %cmp.or

cmp.or:                                           ; preds = %if.done15
  %150 = icmp eq i32 %1, 92
  %151 = zext i1 %150 to i8
  %152 = icmp ne i8 %151, 0
  br i1 %152, label %if.then16, label %if.else

if.then16:                                        ; preds = %cmp.or, %if.done15
  store %"io::Stream" %85, ptr %16, align 8
  %153 = load { i64, i64 }, ptr %16, align 8
  %154 = call i32 @"io::write_byte"({ i64, i64 } %153, i8 92, ptr %n, ptr %__.context_ptr)
  %155 = icmp eq i32 %154, 0
  br i1 %155, label %or_return.continue21, label %or_return.return17

or_return.return17:                               ; preds = %if.then16
  store i32 %154, ptr %err, align 4
  %156 = load i64, ptr %n, align 8
  %157 = load i32, ptr %err, align 4
  store i64 %156, ptr %n, align 8
  store i32 %157, ptr %err, align 4
  store i64 %156, ptr %6, align 8
  br label %defer18

defer18:                                          ; preds = %or_return.return17
  %158 = icmp ne ptr %4, null
  %159 = zext i1 %158 to i8
  %160 = icmp ne i8 %159, 0
  br i1 %160, label %if.then19, label %if.done20

if.then19:                                        ; preds = %defer18
  %161 = load i64, ptr %n, align 8
  %162 = load i64, ptr %4, align 8
  %163 = add i64 %162, %161
  store i64 %163, ptr %4, align 8
  br label %if.done20

if.done20:                                        ; preds = %if.then19, %defer18
  ret i32 %157

or_return.continue21:                             ; preds = %if.then16
  %164 = trunc i32 %1 to i8
  store %"io::Stream" %85, ptr %17, align 8
  %165 = load { i64, i64 }, ptr %17, align 8
  %166 = call i32 @"io::write_byte"({ i64, i64 } %165, i8 %164, ptr %n, ptr %__.context_ptr)
  %167 = icmp eq i32 %166, 0
  br i1 %167, label %or_return.continue26, label %or_return.return22

or_return.return22:                               ; preds = %or_return.continue21
  store i32 %166, ptr %err, align 4
  %168 = load i64, ptr %n, align 8
  %169 = load i32, ptr %err, align 4
  store i64 %168, ptr %n, align 8
  store i32 %169, ptr %err, align 4
  store i64 %168, ptr %6, align 8
  br label %defer23

defer23:                                          ; preds = %or_return.return22
  %170 = icmp ne ptr %4, null
  %171 = zext i1 %170 to i8
  %172 = icmp ne i8 %171, 0
  br i1 %172, label %if.then24, label %if.done25

if.then24:                                        ; preds = %defer23
  %173 = load i64, ptr %n, align 8
  %174 = load i64, ptr %4, align 8
  %175 = add i64 %174, %173
  store i64 %175, ptr %4, align 8
  br label %if.done25

if.done25:                                        ; preds = %if.then24, %defer23
  ret i32 %169

or_return.continue26:                             ; preds = %or_return.continue21
  %176 = load i64, ptr %n, align 8
  %177 = load i32, ptr %err, align 4
  store i64 %176, ptr %n, align 8
  store i32 %177, ptr %err, align 4
  store i64 %176, ptr %6, align 8
  br label %defer27

defer27:                                          ; preds = %or_return.continue26
  %178 = icmp ne ptr %4, null
  %179 = zext i1 %178 to i8
  %180 = icmp ne i8 %179, 0
  br i1 %180, label %if.then28, label %if.done29

if.then28:                                        ; preds = %defer27
  %181 = load i64, ptr %n, align 8
  %182 = load i64, ptr %4, align 8
  %183 = add i64 %182, %181
  store i64 %183, ptr %4, align 8
  br label %if.done29

if.done29:                                        ; preds = %if.then28, %defer27
  ret i32 %177

if.else:                                          ; preds = %cmp.or
  %184 = call i8 @"io::write_escaped_rune.is_printable-0"(i32 %1, ptr %__.context_ptr)
  %185 = icmp ne i8 %184, 0
  br i1 %185, label %if.then30, label %if.done39

if.then30:                                        ; preds = %if.else
  store %"io::Stream" %85, ptr %18, align 8
  %186 = load { i64, i64 }, ptr %18, align 8
  store i64 0, ptr %19, align 8
  %187 = call i32 @"io::write_encoded_rune"({ i64, i64 } %186, i32 %1, i8 0, ptr %n, ptr %19, ptr %__.context_ptr)
  %188 = load i64, ptr %19, align 8
  %189 = load { i64, i32 }, ptr %20, align 8
  %190 = icmp eq i32 %187, 0
  br i1 %190, label %or_return.continue35, label %or_return.return31

or_return.return31:                               ; preds = %if.then30
  store i32 %187, ptr %err, align 4
  %191 = load i64, ptr %n, align 8
  %192 = load i32, ptr %err, align 4
  store i64 %191, ptr %n, align 8
  store i32 %192, ptr %err, align 4
  store i64 %191, ptr %6, align 8
  br label %defer32

defer32:                                          ; preds = %or_return.return31
  %193 = icmp ne ptr %4, null
  %194 = zext i1 %193 to i8
  %195 = icmp ne i8 %194, 0
  br i1 %195, label %if.then33, label %if.done34

if.then33:                                        ; preds = %defer32
  %196 = load i64, ptr %n, align 8
  %197 = load i64, ptr %4, align 8
  %198 = add i64 %197, %196
  store i64 %198, ptr %4, align 8
  br label %if.done34

if.done34:                                        ; preds = %if.then33, %defer32
  ret i32 %192

or_return.continue35:                             ; preds = %if.then30
  %199 = load i64, ptr %n, align 8
  %200 = load i32, ptr %err, align 4
  store i64 %199, ptr %n, align 8
  store i32 %200, ptr %err, align 4
  store i64 %199, ptr %6, align 8
  br label %defer36

defer36:                                          ; preds = %or_return.continue35
  %201 = icmp ne ptr %4, null
  %202 = zext i1 %201 to i8
  %203 = icmp ne i8 %202, 0
  br i1 %203, label %if.then37, label %if.done38

if.then37:                                        ; preds = %defer36
  %204 = load i64, ptr %n, align 8
  %205 = load i64, ptr %4, align 8
  %206 = add i64 %205, %204
  store i64 %206, ptr %4, align 8
  br label %if.done38

if.done38:                                        ; preds = %if.then37, %defer36
  ret i32 %200

if.done39:                                        ; preds = %if.else
  br label %if.done40

if.done40:                                        ; preds = %if.done39
  %207 = icmp slt i32 %1, 32
  %208 = zext i1 %207 to i8
  %209 = icmp ne i8 %208, 0
  br i1 %209, label %cmp.and, label %if.done106

cmp.and:                                          ; preds = %if.done40
  %210 = icmp ne i8 %5, 0
  br i1 %210, label %if.then41, label %if.done106

if.then41:                                        ; preds = %cmp.and
  switch i32 %1, label %switch.default.body [
    i32 8, label %switch.case.body42
    i32 12, label %switch.case.body48
    i32 10, label %switch.case.body54
    i32 13, label %switch.case.body60
    i32 9, label %switch.case.body66
  ]

switch.case.body42:                               ; preds = %if.then41
  store %"io::Stream" %85, ptr %21, align 8
  %211 = load { i64, i64 }, ptr %21, align 8
  store i64 0, ptr %22, align 8
  %212 = call i32 @"io::write_string"({ i64, i64 } %211, %..string { ptr @"csbs$byte_world$1ff", i64 2 }, ptr %n, ptr %22, ptr %__.context_ptr)
  %213 = load i64, ptr %22, align 8
  %214 = load { i64, i32 }, ptr %23, align 8
  %215 = icmp eq i32 %212, 0
  br i1 %215, label %or_return.continue47, label %or_return.return43

or_return.return43:                               ; preds = %switch.case.body42
  store i32 %212, ptr %err, align 4
  %216 = load i64, ptr %n, align 8
  %217 = load i32, ptr %err, align 4
  store i64 %216, ptr %n, align 8
  store i32 %217, ptr %err, align 4
  store i64 %216, ptr %6, align 8
  br label %defer44

defer44:                                          ; preds = %or_return.return43
  %218 = icmp ne ptr %4, null
  %219 = zext i1 %218 to i8
  %220 = icmp ne i8 %219, 0
  br i1 %220, label %if.then45, label %if.done46

if.then45:                                        ; preds = %defer44
  %221 = load i64, ptr %n, align 8
  %222 = load i64, ptr %4, align 8
  %223 = add i64 %222, %221
  store i64 %223, ptr %4, align 8
  br label %if.done46

if.done46:                                        ; preds = %if.then45, %defer44
  ret i32 %217

or_return.continue47:                             ; preds = %switch.case.body42
  br label %switch.done102

switch.case.body48:                               ; preds = %if.then41
  store %"io::Stream" %85, ptr %24, align 8
  %224 = load { i64, i64 }, ptr %24, align 8
  store i64 0, ptr %25, align 8
  %225 = call i32 @"io::write_string"({ i64, i64 } %224, %..string { ptr @"csbs$byte_world$201", i64 2 }, ptr %n, ptr %25, ptr %__.context_ptr)
  %226 = load i64, ptr %25, align 8
  %227 = load { i64, i32 }, ptr %26, align 8
  %228 = icmp eq i32 %225, 0
  br i1 %228, label %or_return.continue53, label %or_return.return49

or_return.return49:                               ; preds = %switch.case.body48
  store i32 %225, ptr %err, align 4
  %229 = load i64, ptr %n, align 8
  %230 = load i32, ptr %err, align 4
  store i64 %229, ptr %n, align 8
  store i32 %230, ptr %err, align 4
  store i64 %229, ptr %6, align 8
  br label %defer50

defer50:                                          ; preds = %or_return.return49
  %231 = icmp ne ptr %4, null
  %232 = zext i1 %231 to i8
  %233 = icmp ne i8 %232, 0
  br i1 %233, label %if.then51, label %if.done52

if.then51:                                        ; preds = %defer50
  %234 = load i64, ptr %n, align 8
  %235 = load i64, ptr %4, align 8
  %236 = add i64 %235, %234
  store i64 %236, ptr %4, align 8
  br label %if.done52

if.done52:                                        ; preds = %if.then51, %defer50
  ret i32 %230

or_return.continue53:                             ; preds = %switch.case.body48
  br label %switch.done102

switch.case.body54:                               ; preds = %if.then41
  store %"io::Stream" %85, ptr %27, align 8
  %237 = load { i64, i64 }, ptr %27, align 8
  store i64 0, ptr %28, align 8
  %238 = call i32 @"io::write_string"({ i64, i64 } %237, %..string { ptr @"csbs$byte_world$202", i64 2 }, ptr %n, ptr %28, ptr %__.context_ptr)
  %239 = load i64, ptr %28, align 8
  %240 = load { i64, i32 }, ptr %29, align 8
  %241 = icmp eq i32 %238, 0
  br i1 %241, label %or_return.continue59, label %or_return.return55

or_return.return55:                               ; preds = %switch.case.body54
  store i32 %238, ptr %err, align 4
  %242 = load i64, ptr %n, align 8
  %243 = load i32, ptr %err, align 4
  store i64 %242, ptr %n, align 8
  store i32 %243, ptr %err, align 4
  store i64 %242, ptr %6, align 8
  br label %defer56

defer56:                                          ; preds = %or_return.return55
  %244 = icmp ne ptr %4, null
  %245 = zext i1 %244 to i8
  %246 = icmp ne i8 %245, 0
  br i1 %246, label %if.then57, label %if.done58

if.then57:                                        ; preds = %defer56
  %247 = load i64, ptr %n, align 8
  %248 = load i64, ptr %4, align 8
  %249 = add i64 %248, %247
  store i64 %249, ptr %4, align 8
  br label %if.done58

if.done58:                                        ; preds = %if.then57, %defer56
  ret i32 %243

or_return.continue59:                             ; preds = %switch.case.body54
  br label %switch.done102

switch.case.body60:                               ; preds = %if.then41
  store %"io::Stream" %85, ptr %30, align 8
  %250 = load { i64, i64 }, ptr %30, align 8
  store i64 0, ptr %31, align 8
  %251 = call i32 @"io::write_string"({ i64, i64 } %250, %..string { ptr @"csbs$byte_world$203", i64 2 }, ptr %n, ptr %31, ptr %__.context_ptr)
  %252 = load i64, ptr %31, align 8
  %253 = load { i64, i32 }, ptr %32, align 8
  %254 = icmp eq i32 %251, 0
  br i1 %254, label %or_return.continue65, label %or_return.return61

or_return.return61:                               ; preds = %switch.case.body60
  store i32 %251, ptr %err, align 4
  %255 = load i64, ptr %n, align 8
  %256 = load i32, ptr %err, align 4
  store i64 %255, ptr %n, align 8
  store i32 %256, ptr %err, align 4
  store i64 %255, ptr %6, align 8
  br label %defer62

defer62:                                          ; preds = %or_return.return61
  %257 = icmp ne ptr %4, null
  %258 = zext i1 %257 to i8
  %259 = icmp ne i8 %258, 0
  br i1 %259, label %if.then63, label %if.done64

if.then63:                                        ; preds = %defer62
  %260 = load i64, ptr %n, align 8
  %261 = load i64, ptr %4, align 8
  %262 = add i64 %261, %260
  store i64 %262, ptr %4, align 8
  br label %if.done64

if.done64:                                        ; preds = %if.then63, %defer62
  ret i32 %256

or_return.continue65:                             ; preds = %switch.case.body60
  br label %switch.done102

switch.case.body66:                               ; preds = %if.then41
  store %"io::Stream" %85, ptr %33, align 8
  %263 = load { i64, i64 }, ptr %33, align 8
  store i64 0, ptr %34, align 8
  %264 = call i32 @"io::write_string"({ i64, i64 } %263, %..string { ptr @"csbs$byte_world$204", i64 2 }, ptr %n, ptr %34, ptr %__.context_ptr)
  %265 = load i64, ptr %34, align 8
  %266 = load { i64, i32 }, ptr %35, align 8
  %267 = icmp eq i32 %264, 0
  br i1 %267, label %or_return.continue71, label %or_return.return67

or_return.return67:                               ; preds = %switch.case.body66
  store i32 %264, ptr %err, align 4
  %268 = load i64, ptr %n, align 8
  %269 = load i32, ptr %err, align 4
  store i64 %268, ptr %n, align 8
  store i32 %269, ptr %err, align 4
  store i64 %268, ptr %6, align 8
  br label %defer68

defer68:                                          ; preds = %or_return.return67
  %270 = icmp ne ptr %4, null
  %271 = zext i1 %270 to i8
  %272 = icmp ne i8 %271, 0
  br i1 %272, label %if.then69, label %if.done70

if.then69:                                        ; preds = %defer68
  %273 = load i64, ptr %n, align 8
  %274 = load i64, ptr %4, align 8
  %275 = add i64 %274, %273
  store i64 %275, ptr %4, align 8
  br label %if.done70

if.done70:                                        ; preds = %if.then69, %defer68
  ret i32 %269

or_return.continue71:                             ; preds = %switch.case.body66
  br label %switch.done102

switch.default.body:                              ; preds = %if.then41
  store %"io::Stream" %85, ptr %36, align 8
  %276 = load { i64, i64 }, ptr %36, align 8
  %277 = call i32 @"io::write_byte"({ i64, i64 } %276, i8 92, ptr %n, ptr %__.context_ptr)
  %278 = icmp eq i32 %277, 0
  br i1 %278, label %or_return.continue76, label %or_return.return72

or_return.return72:                               ; preds = %switch.default.body
  store i32 %277, ptr %err, align 4
  %279 = load i64, ptr %n, align 8
  %280 = load i32, ptr %err, align 4
  store i64 %279, ptr %n, align 8
  store i32 %280, ptr %err, align 4
  store i64 %279, ptr %6, align 8
  br label %defer73

defer73:                                          ; preds = %or_return.return72
  %281 = icmp ne ptr %4, null
  %282 = zext i1 %281 to i8
  %283 = icmp ne i8 %282, 0
  br i1 %283, label %if.then74, label %if.done75

if.then74:                                        ; preds = %defer73
  %284 = load i64, ptr %n, align 8
  %285 = load i64, ptr %4, align 8
  %286 = add i64 %285, %284
  store i64 %286, ptr %4, align 8
  br label %if.done75

if.done75:                                        ; preds = %if.then74, %defer73
  ret i32 %280

or_return.continue76:                             ; preds = %switch.default.body
  store %"io::Stream" %85, ptr %37, align 8
  %287 = load { i64, i64 }, ptr %37, align 8
  %288 = call i32 @"io::write_byte"({ i64, i64 } %287, i8 117, ptr %n, ptr %__.context_ptr)
  %289 = icmp eq i32 %288, 0
  br i1 %289, label %or_return.continue81, label %or_return.return77

or_return.return77:                               ; preds = %or_return.continue76
  store i32 %288, ptr %err, align 4
  %290 = load i64, ptr %n, align 8
  %291 = load i32, ptr %err, align 4
  store i64 %290, ptr %n, align 8
  store i32 %291, ptr %err, align 4
  store i64 %290, ptr %6, align 8
  br label %defer78

defer78:                                          ; preds = %or_return.return77
  %292 = icmp ne ptr %4, null
  %293 = zext i1 %292 to i8
  %294 = icmp ne i8 %293, 0
  br i1 %294, label %if.then79, label %if.done80

if.then79:                                        ; preds = %defer78
  %295 = load i64, ptr %n, align 8
  %296 = load i64, ptr %4, align 8
  %297 = add i64 %296, %295
  store i64 %297, ptr %4, align 8
  br label %if.done80

if.done80:                                        ; preds = %if.then79, %defer78
  ret i32 %291

or_return.continue81:                             ; preds = %or_return.continue76
  store %"io::Stream" %85, ptr %38, align 8
  %298 = load { i64, i64 }, ptr %38, align 8
  %299 = call i32 @"io::write_byte"({ i64, i64 } %298, i8 48, ptr %n, ptr %__.context_ptr)
  %300 = icmp eq i32 %299, 0
  br i1 %300, label %or_return.continue86, label %or_return.return82

or_return.return82:                               ; preds = %or_return.continue81
  store i32 %299, ptr %err, align 4
  %301 = load i64, ptr %n, align 8
  %302 = load i32, ptr %err, align 4
  store i64 %301, ptr %n, align 8
  store i32 %302, ptr %err, align 4
  store i64 %301, ptr %6, align 8
  br label %defer83

defer83:                                          ; preds = %or_return.return82
  %303 = icmp ne ptr %4, null
  %304 = zext i1 %303 to i8
  %305 = icmp ne i8 %304, 0
  br i1 %305, label %if.then84, label %if.done85

if.then84:                                        ; preds = %defer83
  %306 = load i64, ptr %n, align 8
  %307 = load i64, ptr %4, align 8
  %308 = add i64 %307, %306
  store i64 %308, ptr %4, align 8
  br label %if.done85

if.done85:                                        ; preds = %if.then84, %defer83
  ret i32 %302

or_return.continue86:                             ; preds = %or_return.continue81
  store %"io::Stream" %85, ptr %39, align 8
  %309 = load { i64, i64 }, ptr %39, align 8
  %310 = call i32 @"io::write_byte"({ i64, i64 } %309, i8 48, ptr %n, ptr %__.context_ptr)
  %311 = icmp eq i32 %310, 0
  br i1 %311, label %or_return.continue91, label %or_return.return87

or_return.return87:                               ; preds = %or_return.continue86
  store i32 %310, ptr %err, align 4
  %312 = load i64, ptr %n, align 8
  %313 = load i32, ptr %err, align 4
  store i64 %312, ptr %n, align 8
  store i32 %313, ptr %err, align 4
  store i64 %312, ptr %6, align 8
  br label %defer88

defer88:                                          ; preds = %or_return.return87
  %314 = icmp ne ptr %4, null
  %315 = zext i1 %314 to i8
  %316 = icmp ne i8 %315, 0
  br i1 %316, label %if.then89, label %if.done90

if.then89:                                        ; preds = %defer88
  %317 = load i64, ptr %n, align 8
  %318 = load i64, ptr %4, align 8
  %319 = add i64 %318, %317
  store i64 %319, ptr %4, align 8
  br label %if.done90

if.done90:                                        ; preds = %if.then89, %defer88
  ret i32 %313

or_return.continue91:                             ; preds = %or_return.continue86
  %320 = load %..string, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %321 = load ptr, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %322 = load i64, ptr getelementptr (%..string, ptr @"io::[util.odin]::DIGITS_LOWER", i64 0, i32 1), align 8
  %323 = ashr i32 %1, 4
  %324 = select i1 true, i32 %323, i32 0
  %325 = and i32 %324, 15
  %326 = sext i32 %325 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 204, i32 31, i64 %326, i64 %322)
  %327 = getelementptr i8, ptr %321, i64 %326
  %328 = load i8, ptr %327, align 1
  store %"io::Stream" %85, ptr %40, align 8
  %329 = load { i64, i64 }, ptr %40, align 8
  %330 = call i32 @"io::write_byte"({ i64, i64 } %329, i8 %328, ptr %n, ptr %__.context_ptr)
  %331 = icmp eq i32 %330, 0
  br i1 %331, label %or_return.continue96, label %or_return.return92

or_return.return92:                               ; preds = %or_return.continue91
  store i32 %330, ptr %err, align 4
  %332 = load i64, ptr %n, align 8
  %333 = load i32, ptr %err, align 4
  store i64 %332, ptr %n, align 8
  store i32 %333, ptr %err, align 4
  store i64 %332, ptr %6, align 8
  br label %defer93

defer93:                                          ; preds = %or_return.return92
  %334 = icmp ne ptr %4, null
  %335 = zext i1 %334 to i8
  %336 = icmp ne i8 %335, 0
  br i1 %336, label %if.then94, label %if.done95

if.then94:                                        ; preds = %defer93
  %337 = load i64, ptr %n, align 8
  %338 = load i64, ptr %4, align 8
  %339 = add i64 %338, %337
  store i64 %339, ptr %4, align 8
  br label %if.done95

if.done95:                                        ; preds = %if.then94, %defer93
  ret i32 %333

or_return.continue96:                             ; preds = %or_return.continue91
  %340 = load %..string, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %341 = load ptr, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %342 = load i64, ptr getelementptr (%..string, ptr @"io::[util.odin]::DIGITS_LOWER", i64 0, i32 1), align 8
  %343 = and i32 %1, 15
  %344 = sext i32 %343 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 205, i32 31, i64 %344, i64 %342)
  %345 = getelementptr i8, ptr %341, i64 %344
  %346 = load i8, ptr %345, align 1
  store %"io::Stream" %85, ptr %41, align 8
  %347 = load { i64, i64 }, ptr %41, align 8
  %348 = call i32 @"io::write_byte"({ i64, i64 } %347, i8 %346, ptr %n, ptr %__.context_ptr)
  %349 = icmp eq i32 %348, 0
  br i1 %349, label %or_return.continue101, label %or_return.return97

or_return.return97:                               ; preds = %or_return.continue96
  store i32 %348, ptr %err, align 4
  %350 = load i64, ptr %n, align 8
  %351 = load i32, ptr %err, align 4
  store i64 %350, ptr %n, align 8
  store i32 %351, ptr %err, align 4
  store i64 %350, ptr %6, align 8
  br label %defer98

defer98:                                          ; preds = %or_return.return97
  %352 = icmp ne ptr %4, null
  %353 = zext i1 %352 to i8
  %354 = icmp ne i8 %353, 0
  br i1 %354, label %if.then99, label %if.done100

if.then99:                                        ; preds = %defer98
  %355 = load i64, ptr %n, align 8
  %356 = load i64, ptr %4, align 8
  %357 = add i64 %356, %355
  store i64 %357, ptr %4, align 8
  br label %if.done100

if.done100:                                       ; preds = %if.then99, %defer98
  ret i32 %351

or_return.continue101:                            ; preds = %or_return.continue96
  br label %switch.done102

switch.done102:                                   ; preds = %or_return.continue101, %or_return.continue71, %or_return.continue65, %or_return.continue59, %or_return.continue53, %or_return.continue47
  %358 = load i64, ptr %n, align 8
  %359 = load i32, ptr %err, align 4
  store i64 %358, ptr %n, align 8
  store i32 %359, ptr %err, align 4
  store i64 %358, ptr %6, align 8
  br label %defer103

defer103:                                         ; preds = %switch.done102
  %360 = icmp ne ptr %4, null
  %361 = zext i1 %360 to i8
  %362 = icmp ne i8 %361, 0
  br i1 %362, label %if.then104, label %if.done105

if.then104:                                       ; preds = %defer103
  %363 = load i64, ptr %n, align 8
  %364 = load i64, ptr %4, align 8
  %365 = add i64 %364, %363
  store i64 %365, ptr %4, align 8
  br label %if.done105

if.done105:                                       ; preds = %if.then104, %defer103
  ret i32 %359

if.done106:                                       ; preds = %cmp.and, %if.done40
  switch i32 %1, label %switch.default.body155 [
    i32 7, label %switch.case.body107
    i32 8, label %switch.case.body113
    i32 27, label %switch.case.body119
    i32 12, label %switch.case.body125
    i32 10, label %switch.case.body131
    i32 13, label %switch.case.body137
    i32 9, label %switch.case.body143
    i32 11, label %switch.case.body149
  ]

switch.case.body107:                              ; preds = %if.done106
  store %"io::Stream" %85, ptr %42, align 8
  %366 = load { i64, i64 }, ptr %42, align 8
  store i64 0, ptr %43, align 8
  %367 = call i32 @"io::write_string"({ i64, i64 } %366, %..string { ptr @"csbs$byte_world$1fe", i64 2 }, ptr %n, ptr %43, ptr %__.context_ptr)
  %368 = load i64, ptr %43, align 8
  %369 = load { i64, i32 }, ptr %44, align 8
  %370 = icmp eq i32 %367, 0
  br i1 %370, label %or_return.continue112, label %or_return.return108

or_return.return108:                              ; preds = %switch.case.body107
  store i32 %367, ptr %err, align 4
  %371 = load i64, ptr %n, align 8
  %372 = load i32, ptr %err, align 4
  store i64 %371, ptr %n, align 8
  store i32 %372, ptr %err, align 4
  store i64 %371, ptr %6, align 8
  br label %defer109

defer109:                                         ; preds = %or_return.return108
  %373 = icmp ne ptr %4, null
  %374 = zext i1 %373 to i8
  %375 = icmp ne i8 %374, 0
  br i1 %375, label %if.then110, label %if.done111

if.then110:                                       ; preds = %defer109
  %376 = load i64, ptr %n, align 8
  %377 = load i64, ptr %4, align 8
  %378 = add i64 %377, %376
  store i64 %378, ptr %4, align 8
  br label %if.done111

if.done111:                                       ; preds = %if.then110, %defer109
  ret i32 %372

or_return.continue112:                            ; preds = %switch.case.body107
  br label %switch.done249

switch.case.body113:                              ; preds = %if.done106
  store %"io::Stream" %85, ptr %45, align 8
  %379 = load { i64, i64 }, ptr %45, align 8
  store i64 0, ptr %46, align 8
  %380 = call i32 @"io::write_string"({ i64, i64 } %379, %..string { ptr @"csbs$byte_world$1ff", i64 2 }, ptr %n, ptr %46, ptr %__.context_ptr)
  %381 = load i64, ptr %46, align 8
  %382 = load { i64, i32 }, ptr %47, align 8
  %383 = icmp eq i32 %380, 0
  br i1 %383, label %or_return.continue118, label %or_return.return114

or_return.return114:                              ; preds = %switch.case.body113
  store i32 %380, ptr %err, align 4
  %384 = load i64, ptr %n, align 8
  %385 = load i32, ptr %err, align 4
  store i64 %384, ptr %n, align 8
  store i32 %385, ptr %err, align 4
  store i64 %384, ptr %6, align 8
  br label %defer115

defer115:                                         ; preds = %or_return.return114
  %386 = icmp ne ptr %4, null
  %387 = zext i1 %386 to i8
  %388 = icmp ne i8 %387, 0
  br i1 %388, label %if.then116, label %if.done117

if.then116:                                       ; preds = %defer115
  %389 = load i64, ptr %n, align 8
  %390 = load i64, ptr %4, align 8
  %391 = add i64 %390, %389
  store i64 %391, ptr %4, align 8
  br label %if.done117

if.done117:                                       ; preds = %if.then116, %defer115
  ret i32 %385

or_return.continue118:                            ; preds = %switch.case.body113
  br label %switch.done249

switch.case.body119:                              ; preds = %if.done106
  store %"io::Stream" %85, ptr %48, align 8
  %392 = load { i64, i64 }, ptr %48, align 8
  store i64 0, ptr %49, align 8
  %393 = call i32 @"io::write_string"({ i64, i64 } %392, %..string { ptr @"csbs$byte_world$200", i64 2 }, ptr %n, ptr %49, ptr %__.context_ptr)
  %394 = load i64, ptr %49, align 8
  %395 = load { i64, i32 }, ptr %50, align 8
  %396 = icmp eq i32 %393, 0
  br i1 %396, label %or_return.continue124, label %or_return.return120

or_return.return120:                              ; preds = %switch.case.body119
  store i32 %393, ptr %err, align 4
  %397 = load i64, ptr %n, align 8
  %398 = load i32, ptr %err, align 4
  store i64 %397, ptr %n, align 8
  store i32 %398, ptr %err, align 4
  store i64 %397, ptr %6, align 8
  br label %defer121

defer121:                                         ; preds = %or_return.return120
  %399 = icmp ne ptr %4, null
  %400 = zext i1 %399 to i8
  %401 = icmp ne i8 %400, 0
  br i1 %401, label %if.then122, label %if.done123

if.then122:                                       ; preds = %defer121
  %402 = load i64, ptr %n, align 8
  %403 = load i64, ptr %4, align 8
  %404 = add i64 %403, %402
  store i64 %404, ptr %4, align 8
  br label %if.done123

if.done123:                                       ; preds = %if.then122, %defer121
  ret i32 %398

or_return.continue124:                            ; preds = %switch.case.body119
  br label %switch.done249

switch.case.body125:                              ; preds = %if.done106
  store %"io::Stream" %85, ptr %51, align 8
  %405 = load { i64, i64 }, ptr %51, align 8
  store i64 0, ptr %52, align 8
  %406 = call i32 @"io::write_string"({ i64, i64 } %405, %..string { ptr @"csbs$byte_world$201", i64 2 }, ptr %n, ptr %52, ptr %__.context_ptr)
  %407 = load i64, ptr %52, align 8
  %408 = load { i64, i32 }, ptr %53, align 8
  %409 = icmp eq i32 %406, 0
  br i1 %409, label %or_return.continue130, label %or_return.return126

or_return.return126:                              ; preds = %switch.case.body125
  store i32 %406, ptr %err, align 4
  %410 = load i64, ptr %n, align 8
  %411 = load i32, ptr %err, align 4
  store i64 %410, ptr %n, align 8
  store i32 %411, ptr %err, align 4
  store i64 %410, ptr %6, align 8
  br label %defer127

defer127:                                         ; preds = %or_return.return126
  %412 = icmp ne ptr %4, null
  %413 = zext i1 %412 to i8
  %414 = icmp ne i8 %413, 0
  br i1 %414, label %if.then128, label %if.done129

if.then128:                                       ; preds = %defer127
  %415 = load i64, ptr %n, align 8
  %416 = load i64, ptr %4, align 8
  %417 = add i64 %416, %415
  store i64 %417, ptr %4, align 8
  br label %if.done129

if.done129:                                       ; preds = %if.then128, %defer127
  ret i32 %411

or_return.continue130:                            ; preds = %switch.case.body125
  br label %switch.done249

switch.case.body131:                              ; preds = %if.done106
  store %"io::Stream" %85, ptr %54, align 8
  %418 = load { i64, i64 }, ptr %54, align 8
  store i64 0, ptr %55, align 8
  %419 = call i32 @"io::write_string"({ i64, i64 } %418, %..string { ptr @"csbs$byte_world$202", i64 2 }, ptr %n, ptr %55, ptr %__.context_ptr)
  %420 = load i64, ptr %55, align 8
  %421 = load { i64, i32 }, ptr %56, align 8
  %422 = icmp eq i32 %419, 0
  br i1 %422, label %or_return.continue136, label %or_return.return132

or_return.return132:                              ; preds = %switch.case.body131
  store i32 %419, ptr %err, align 4
  %423 = load i64, ptr %n, align 8
  %424 = load i32, ptr %err, align 4
  store i64 %423, ptr %n, align 8
  store i32 %424, ptr %err, align 4
  store i64 %423, ptr %6, align 8
  br label %defer133

defer133:                                         ; preds = %or_return.return132
  %425 = icmp ne ptr %4, null
  %426 = zext i1 %425 to i8
  %427 = icmp ne i8 %426, 0
  br i1 %427, label %if.then134, label %if.done135

if.then134:                                       ; preds = %defer133
  %428 = load i64, ptr %n, align 8
  %429 = load i64, ptr %4, align 8
  %430 = add i64 %429, %428
  store i64 %430, ptr %4, align 8
  br label %if.done135

if.done135:                                       ; preds = %if.then134, %defer133
  ret i32 %424

or_return.continue136:                            ; preds = %switch.case.body131
  br label %switch.done249

switch.case.body137:                              ; preds = %if.done106
  store %"io::Stream" %85, ptr %57, align 8
  %431 = load { i64, i64 }, ptr %57, align 8
  store i64 0, ptr %58, align 8
  %432 = call i32 @"io::write_string"({ i64, i64 } %431, %..string { ptr @"csbs$byte_world$203", i64 2 }, ptr %n, ptr %58, ptr %__.context_ptr)
  %433 = load i64, ptr %58, align 8
  %434 = load { i64, i32 }, ptr %59, align 8
  %435 = icmp eq i32 %432, 0
  br i1 %435, label %or_return.continue142, label %or_return.return138

or_return.return138:                              ; preds = %switch.case.body137
  store i32 %432, ptr %err, align 4
  %436 = load i64, ptr %n, align 8
  %437 = load i32, ptr %err, align 4
  store i64 %436, ptr %n, align 8
  store i32 %437, ptr %err, align 4
  store i64 %436, ptr %6, align 8
  br label %defer139

defer139:                                         ; preds = %or_return.return138
  %438 = icmp ne ptr %4, null
  %439 = zext i1 %438 to i8
  %440 = icmp ne i8 %439, 0
  br i1 %440, label %if.then140, label %if.done141

if.then140:                                       ; preds = %defer139
  %441 = load i64, ptr %n, align 8
  %442 = load i64, ptr %4, align 8
  %443 = add i64 %442, %441
  store i64 %443, ptr %4, align 8
  br label %if.done141

if.done141:                                       ; preds = %if.then140, %defer139
  ret i32 %437

or_return.continue142:                            ; preds = %switch.case.body137
  br label %switch.done249

switch.case.body143:                              ; preds = %if.done106
  store %"io::Stream" %85, ptr %60, align 8
  %444 = load { i64, i64 }, ptr %60, align 8
  store i64 0, ptr %61, align 8
  %445 = call i32 @"io::write_string"({ i64, i64 } %444, %..string { ptr @"csbs$byte_world$204", i64 2 }, ptr %n, ptr %61, ptr %__.context_ptr)
  %446 = load i64, ptr %61, align 8
  %447 = load { i64, i32 }, ptr %62, align 8
  %448 = icmp eq i32 %445, 0
  br i1 %448, label %or_return.continue148, label %or_return.return144

or_return.return144:                              ; preds = %switch.case.body143
  store i32 %445, ptr %err, align 4
  %449 = load i64, ptr %n, align 8
  %450 = load i32, ptr %err, align 4
  store i64 %449, ptr %n, align 8
  store i32 %450, ptr %err, align 4
  store i64 %449, ptr %6, align 8
  br label %defer145

defer145:                                         ; preds = %or_return.return144
  %451 = icmp ne ptr %4, null
  %452 = zext i1 %451 to i8
  %453 = icmp ne i8 %452, 0
  br i1 %453, label %if.then146, label %if.done147

if.then146:                                       ; preds = %defer145
  %454 = load i64, ptr %n, align 8
  %455 = load i64, ptr %4, align 8
  %456 = add i64 %455, %454
  store i64 %456, ptr %4, align 8
  br label %if.done147

if.done147:                                       ; preds = %if.then146, %defer145
  ret i32 %450

or_return.continue148:                            ; preds = %switch.case.body143
  br label %switch.done249

switch.case.body149:                              ; preds = %if.done106
  store %"io::Stream" %85, ptr %63, align 8
  %457 = load { i64, i64 }, ptr %63, align 8
  store i64 0, ptr %64, align 8
  %458 = call i32 @"io::write_string"({ i64, i64 } %457, %..string { ptr @"csbs$byte_world$205", i64 2 }, ptr %n, ptr %64, ptr %__.context_ptr)
  %459 = load i64, ptr %64, align 8
  %460 = load { i64, i32 }, ptr %65, align 8
  %461 = icmp eq i32 %458, 0
  br i1 %461, label %or_return.continue154, label %or_return.return150

or_return.return150:                              ; preds = %switch.case.body149
  store i32 %458, ptr %err, align 4
  %462 = load i64, ptr %n, align 8
  %463 = load i32, ptr %err, align 4
  store i64 %462, ptr %n, align 8
  store i32 %463, ptr %err, align 4
  store i64 %462, ptr %6, align 8
  br label %defer151

defer151:                                         ; preds = %or_return.return150
  %464 = icmp ne ptr %4, null
  %465 = zext i1 %464 to i8
  %466 = icmp ne i8 %465, 0
  br i1 %466, label %if.then152, label %if.done153

if.then152:                                       ; preds = %defer151
  %467 = load i64, ptr %n, align 8
  %468 = load i64, ptr %4, align 8
  %469 = add i64 %468, %467
  store i64 %469, ptr %4, align 8
  br label %if.done153

if.done153:                                       ; preds = %if.then152, %defer151
  ret i32 %463

or_return.continue154:                            ; preds = %switch.case.body149
  br label %switch.done249

switch.default.body155:                           ; preds = %if.done106
  store i32 %1, ptr %c, align 4
  %470 = load i32, ptr %c, align 4
  %471 = icmp slt i32 %470, 32
  %472 = zext i1 %471 to i8
  %473 = icmp eq i8 1, %472
  br i1 %473, label %switch.case.body156, label %switch.case.next

switch.case.next:                                 ; preds = %switch.default.body155
  %474 = load i32, ptr %c, align 4
  %475 = icmp sgt i32 %474, 1114111
  %476 = zext i1 %475 to i8
  %477 = icmp eq i8 1, %476
  br i1 %477, label %switch.case.body178, label %switch.case.next177

switch.case.body156:                              ; preds = %switch.default.body155
  store %"io::Stream" %85, ptr %66, align 8
  %478 = load { i64, i64 }, ptr %66, align 8
  %479 = call i32 @"io::write_byte"({ i64, i64 } %478, i8 92, ptr %n, ptr %__.context_ptr)
  %480 = icmp eq i32 %479, 0
  br i1 %480, label %or_return.continue161, label %or_return.return157

or_return.return157:                              ; preds = %switch.case.body156
  store i32 %479, ptr %err, align 4
  %481 = load i64, ptr %n, align 8
  %482 = load i32, ptr %err, align 4
  store i64 %481, ptr %n, align 8
  store i32 %482, ptr %err, align 4
  store i64 %481, ptr %6, align 8
  br label %defer158

defer158:                                         ; preds = %or_return.return157
  %483 = icmp ne ptr %4, null
  %484 = zext i1 %483 to i8
  %485 = icmp ne i8 %484, 0
  br i1 %485, label %if.then159, label %if.done160

if.then159:                                       ; preds = %defer158
  %486 = load i64, ptr %n, align 8
  %487 = load i64, ptr %4, align 8
  %488 = add i64 %487, %486
  store i64 %488, ptr %4, align 8
  br label %if.done160

if.done160:                                       ; preds = %if.then159, %defer158
  ret i32 %482

or_return.continue161:                            ; preds = %switch.case.body156
  store %"io::Stream" %85, ptr %67, align 8
  %489 = load { i64, i64 }, ptr %67, align 8
  %490 = call i32 @"io::write_byte"({ i64, i64 } %489, i8 120, ptr %n, ptr %__.context_ptr)
  %491 = icmp eq i32 %490, 0
  br i1 %491, label %or_return.continue166, label %or_return.return162

or_return.return162:                              ; preds = %or_return.continue161
  store i32 %490, ptr %err, align 4
  %492 = load i64, ptr %n, align 8
  %493 = load i32, ptr %err, align 4
  store i64 %492, ptr %n, align 8
  store i32 %493, ptr %err, align 4
  store i64 %492, ptr %6, align 8
  br label %defer163

defer163:                                         ; preds = %or_return.return162
  %494 = icmp ne ptr %4, null
  %495 = zext i1 %494 to i8
  %496 = icmp ne i8 %495, 0
  br i1 %496, label %if.then164, label %if.done165

if.then164:                                       ; preds = %defer163
  %497 = load i64, ptr %n, align 8
  %498 = load i64, ptr %4, align 8
  %499 = add i64 %498, %497
  store i64 %499, ptr %4, align 8
  br label %if.done165

if.done165:                                       ; preds = %if.then164, %defer163
  ret i32 %493

or_return.continue166:                            ; preds = %or_return.continue161
  %500 = load %..string, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %501 = load ptr, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %502 = load i64, ptr getelementptr (%..string, ptr @"io::[util.odin]::DIGITS_LOWER", i64 0, i32 1), align 8
  %503 = load i32, ptr %c, align 4
  %504 = trunc i32 %503 to i8
  %505 = lshr i8 %504, 4
  %506 = select i1 true, i8 %505, i8 0
  %507 = zext i8 %506 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 223, i32 31, i64 %507, i64 %502)
  %508 = getelementptr i8, ptr %501, i64 %507
  %509 = load i8, ptr %508, align 1
  store %"io::Stream" %85, ptr %68, align 8
  %510 = load { i64, i64 }, ptr %68, align 8
  %511 = call i32 @"io::write_byte"({ i64, i64 } %510, i8 %509, ptr %n, ptr %__.context_ptr)
  %512 = icmp eq i32 %511, 0
  br i1 %512, label %or_return.continue171, label %or_return.return167

or_return.return167:                              ; preds = %or_return.continue166
  store i32 %511, ptr %err, align 4
  %513 = load i64, ptr %n, align 8
  %514 = load i32, ptr %err, align 4
  store i64 %513, ptr %n, align 8
  store i32 %514, ptr %err, align 4
  store i64 %513, ptr %6, align 8
  br label %defer168

defer168:                                         ; preds = %or_return.return167
  %515 = icmp ne ptr %4, null
  %516 = zext i1 %515 to i8
  %517 = icmp ne i8 %516, 0
  br i1 %517, label %if.then169, label %if.done170

if.then169:                                       ; preds = %defer168
  %518 = load i64, ptr %n, align 8
  %519 = load i64, ptr %4, align 8
  %520 = add i64 %519, %518
  store i64 %520, ptr %4, align 8
  br label %if.done170

if.done170:                                       ; preds = %if.then169, %defer168
  ret i32 %514

or_return.continue171:                            ; preds = %or_return.continue166
  %521 = load %..string, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %522 = load ptr, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %523 = load i64, ptr getelementptr (%..string, ptr @"io::[util.odin]::DIGITS_LOWER", i64 0, i32 1), align 8
  %524 = load i32, ptr %c, align 4
  %525 = trunc i32 %524 to i8
  %526 = and i8 %525, 15
  %527 = zext i8 %526 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 224, i32 31, i64 %527, i64 %523)
  %528 = getelementptr i8, ptr %522, i64 %527
  %529 = load i8, ptr %528, align 1
  store %"io::Stream" %85, ptr %69, align 8
  %530 = load { i64, i64 }, ptr %69, align 8
  %531 = call i32 @"io::write_byte"({ i64, i64 } %530, i8 %529, ptr %n, ptr %__.context_ptr)
  %532 = icmp eq i32 %531, 0
  br i1 %532, label %or_return.continue176, label %or_return.return172

or_return.return172:                              ; preds = %or_return.continue171
  store i32 %531, ptr %err, align 4
  %533 = load i64, ptr %n, align 8
  %534 = load i32, ptr %err, align 4
  store i64 %533, ptr %n, align 8
  store i32 %534, ptr %err, align 4
  store i64 %533, ptr %6, align 8
  br label %defer173

defer173:                                         ; preds = %or_return.return172
  %535 = icmp ne ptr %4, null
  %536 = zext i1 %535 to i8
  %537 = icmp ne i8 %536, 0
  br i1 %537, label %if.then174, label %if.done175

if.then174:                                       ; preds = %defer173
  %538 = load i64, ptr %n, align 8
  %539 = load i64, ptr %4, align 8
  %540 = add i64 %539, %538
  store i64 %540, ptr %4, align 8
  br label %if.done175

if.done175:                                       ; preds = %if.then174, %defer173
  ret i32 %534

or_return.continue176:                            ; preds = %or_return.continue171
  br label %switch.done248

switch.case.next177:                              ; preds = %switch.case.next
  %541 = load i32, ptr %c, align 4
  %542 = icmp slt i32 %541, 65536
  %543 = zext i1 %542 to i8
  %544 = icmp eq i8 1, %543
  br i1 %544, label %switch.case.body180, label %switch.case.next179

switch.case.body178:                              ; preds = %switch.case.next
  store i32 65533, ptr %c, align 4
  br label %switch.case.body180

unreachable:                                      ; No predecessors!
  br label %switch.done248

switch.case.next179:                              ; preds = %switch.case.next177
  br label %switch.default.body202

switch.case.body180:                              ; preds = %switch.case.next177, %switch.case.body178
  store %"io::Stream" %85, ptr %70, align 8
  %545 = load { i64, i64 }, ptr %70, align 8
  %546 = call i32 @"io::write_byte"({ i64, i64 } %545, i8 92, ptr %n, ptr %__.context_ptr)
  %547 = icmp eq i32 %546, 0
  br i1 %547, label %or_return.continue185, label %or_return.return181

or_return.return181:                              ; preds = %switch.case.body180
  store i32 %546, ptr %err, align 4
  %548 = load i64, ptr %n, align 8
  %549 = load i32, ptr %err, align 4
  store i64 %548, ptr %n, align 8
  store i32 %549, ptr %err, align 4
  store i64 %548, ptr %6, align 8
  br label %defer182

defer182:                                         ; preds = %or_return.return181
  %550 = icmp ne ptr %4, null
  %551 = zext i1 %550 to i8
  %552 = icmp ne i8 %551, 0
  br i1 %552, label %if.then183, label %if.done184

if.then183:                                       ; preds = %defer182
  %553 = load i64, ptr %n, align 8
  %554 = load i64, ptr %4, align 8
  %555 = add i64 %554, %553
  store i64 %555, ptr %4, align 8
  br label %if.done184

if.done184:                                       ; preds = %if.then183, %defer182
  ret i32 %549

or_return.continue185:                            ; preds = %switch.case.body180
  store %"io::Stream" %85, ptr %71, align 8
  %556 = load { i64, i64 }, ptr %71, align 8
  %557 = call i32 @"io::write_byte"({ i64, i64 } %556, i8 117, ptr %n, ptr %__.context_ptr)
  %558 = icmp eq i32 %557, 0
  br i1 %558, label %or_return.continue190, label %or_return.return186

or_return.return186:                              ; preds = %or_return.continue185
  store i32 %557, ptr %err, align 4
  %559 = load i64, ptr %n, align 8
  %560 = load i32, ptr %err, align 4
  store i64 %559, ptr %n, align 8
  store i32 %560, ptr %err, align 4
  store i64 %559, ptr %6, align 8
  br label %defer187

defer187:                                         ; preds = %or_return.return186
  %561 = icmp ne ptr %4, null
  %562 = zext i1 %561 to i8
  %563 = icmp ne i8 %562, 0
  br i1 %563, label %if.then188, label %if.done189

if.then188:                                       ; preds = %defer187
  %564 = load i64, ptr %n, align 8
  %565 = load i64, ptr %4, align 8
  %566 = add i64 %565, %564
  store i64 %566, ptr %4, align 8
  br label %if.done189

if.done189:                                       ; preds = %if.then188, %defer187
  ret i32 %560

or_return.continue190:                            ; preds = %or_return.continue185
  br label %for.init191

for.init191:                                      ; preds = %or_return.continue190
  store i64 12, ptr %s192, align 8
  br label %for.loop193

for.loop193:                                      ; preds = %for.post200, %for.init191
  %567 = load i64, ptr %s192, align 8
  %568 = icmp sge i64 %567, 0
  %569 = zext i1 %568 to i8
  %570 = icmp ne i8 %569, 0
  br i1 %570, label %for.body194, label %for.done201

for.body194:                                      ; preds = %for.loop193
  %571 = load %..string, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %572 = load ptr, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %573 = load i64, ptr getelementptr (%..string, ptr @"io::[util.odin]::DIGITS_LOWER", i64 0, i32 1), align 8
  %574 = load i32, ptr %c, align 4
  %575 = load i64, ptr %s192, align 8
  %576 = trunc i64 %575 to i32
  %577 = icmp ult i32 %576, 32
  %578 = ashr i32 %574, %576
  %579 = select i1 %577, i32 %578, i32 0
  %580 = and i32 %579, 15
  %581 = sext i32 %580 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 233, i32 32, i64 %581, i64 %573)
  %582 = getelementptr i8, ptr %572, i64 %581
  %583 = load i8, ptr %582, align 1
  store %"io::Stream" %85, ptr %72, align 8
  %584 = load { i64, i64 }, ptr %72, align 8
  %585 = call i32 @"io::write_byte"({ i64, i64 } %584, i8 %583, ptr %n, ptr %__.context_ptr)
  %586 = icmp eq i32 %585, 0
  br i1 %586, label %or_return.continue199, label %or_return.return195

or_return.return195:                              ; preds = %for.body194
  store i32 %585, ptr %err, align 4
  %587 = load i64, ptr %n, align 8
  %588 = load i32, ptr %err, align 4
  store i64 %587, ptr %n, align 8
  store i32 %588, ptr %err, align 4
  store i64 %587, ptr %6, align 8
  br label %defer196

defer196:                                         ; preds = %or_return.return195
  %589 = icmp ne ptr %4, null
  %590 = zext i1 %589 to i8
  %591 = icmp ne i8 %590, 0
  br i1 %591, label %if.then197, label %if.done198

if.then197:                                       ; preds = %defer196
  %592 = load i64, ptr %n, align 8
  %593 = load i64, ptr %4, align 8
  %594 = add i64 %593, %592
  store i64 %594, ptr %4, align 8
  br label %if.done198

if.done198:                                       ; preds = %if.then197, %defer196
  ret i32 %588

or_return.continue199:                            ; preds = %for.body194
  br label %for.post200

for.post200:                                      ; preds = %or_return.continue199
  %595 = load i64, ptr %s192, align 8
  %596 = sub i64 %595, 4
  store i64 %596, ptr %s192, align 8
  br label %for.loop193

for.done201:                                      ; preds = %for.loop193
  br label %switch.done248

switch.default.body202:                           ; preds = %switch.case.next179
  %597 = icmp ne i8 %5, 0
  br i1 %597, label %if.then203, label %if.else225

if.then203:                                       ; preds = %switch.default.body202
  call void @llvm.memset.inline.p0.i64(ptr %buf, i8 0, i64 4, i1 false)
  %598 = load [2 x i16], ptr %buf, align 2
  %599 = getelementptr [2 x i16], ptr %buf, i64 0, i64 0
  %600 = getelementptr i16, ptr %599, i64 0
  %601 = getelementptr inbounds nuw { ptr, i64 }, ptr %73, i32 0, i32 0
  store ptr %600, ptr %601, align 8
  %602 = getelementptr inbounds nuw { ptr, i64 }, ptr %73, i32 0, i32 1
  store i64 2, ptr %602, align 8
  %603 = load { ptr, i64 }, ptr %73, align 8
  call void @llvm.memset.inline.p0.i64(ptr %74, i8 0, i64 16, i1 false)
  store [1 x i32] zeroinitializer, ptr %75, align 4
  %604 = getelementptr inbounds [1 x i32], ptr %75, i64 0, i64 0
  %605 = getelementptr inbounds nuw { ptr, i64 }, ptr %76, i32 0, i32 0
  store ptr %604, ptr %605, align 8
  %606 = getelementptr inbounds nuw { ptr, i64 }, ptr %76, i32 0, i32 1
  store i64 1, ptr %606, align 8
  %607 = load { ptr, i64 }, ptr %76, align 8
  %608 = getelementptr inbounds nuw { ptr, i64 }, ptr %76, i32 0, i32 0
  %609 = load ptr, ptr %608, align 8
  %610 = load i32, ptr %c, align 4
  %611 = getelementptr i32, ptr %609, i64 0
  store i32 %610, ptr %611, align 4
  %612 = extractvalue { ptr, i64 } %607, 1
  %613 = getelementptr inbounds nuw { ptr, i64 }, ptr %74, i32 0, i32 0
  store ptr %609, ptr %613, align 8
  %614 = getelementptr inbounds nuw { ptr, i64 }, ptr %74, i32 0, i32 1
  store i64 %612, ptr %614, align 8
  %615 = load { ptr, i64 }, ptr %74, align 8
  %616 = call i64 @"utf16::encode"({ ptr, i64 } %603, { ptr, i64 } %615, ptr %__.context_ptr)
  store i64 2, ptr %77, align 8
  store i64 -1, ptr %78, align 8
  br label %for.index.loop

for.index.loop:                                   ; preds = %for.done224, %if.then203
  %617 = load i64, ptr %78, align 8
  %618 = add i64 %617, 1
  store i64 %618, ptr %78, align 8
  %619 = icmp slt i64 %618, 2
  br i1 %619, label %for.index.body, label %for.index.done

for.index.body:                                   ; preds = %for.index.loop
  %620 = load i64, ptr %78, align 8
  %621 = getelementptr [2 x i16], ptr %buf, i64 0, i64 %620
  %622 = load i16, ptr %621, align 2
  store i16 %622, ptr %bc, align 2
  store %"io::Stream" %85, ptr %79, align 8
  %623 = load { i64, i64 }, ptr %79, align 8
  %624 = call i32 @"io::write_byte"({ i64, i64 } %623, i8 92, ptr %n, ptr %__.context_ptr)
  %625 = icmp eq i32 %624, 0
  br i1 %625, label %or_return.continue208, label %or_return.return204

or_return.return204:                              ; preds = %for.index.body
  store i32 %624, ptr %err, align 4
  %626 = load i64, ptr %n, align 8
  %627 = load i32, ptr %err, align 4
  store i64 %626, ptr %n, align 8
  store i32 %627, ptr %err, align 4
  store i64 %626, ptr %6, align 8
  br label %defer205

defer205:                                         ; preds = %or_return.return204
  %628 = icmp ne ptr %4, null
  %629 = zext i1 %628 to i8
  %630 = icmp ne i8 %629, 0
  br i1 %630, label %if.then206, label %if.done207

if.then206:                                       ; preds = %defer205
  %631 = load i64, ptr %n, align 8
  %632 = load i64, ptr %4, align 8
  %633 = add i64 %632, %631
  store i64 %633, ptr %4, align 8
  br label %if.done207

if.done207:                                       ; preds = %if.then206, %defer205
  ret i32 %627

or_return.continue208:                            ; preds = %for.index.body
  store %"io::Stream" %85, ptr %80, align 8
  %634 = load { i64, i64 }, ptr %80, align 8
  %635 = call i32 @"io::write_byte"({ i64, i64 } %634, i8 117, ptr %n, ptr %__.context_ptr)
  %636 = icmp eq i32 %635, 0
  br i1 %636, label %or_return.continue213, label %or_return.return209

or_return.return209:                              ; preds = %or_return.continue208
  store i32 %635, ptr %err, align 4
  %637 = load i64, ptr %n, align 8
  %638 = load i32, ptr %err, align 4
  store i64 %637, ptr %n, align 8
  store i32 %638, ptr %err, align 4
  store i64 %637, ptr %6, align 8
  br label %defer210

defer210:                                         ; preds = %or_return.return209
  %639 = icmp ne ptr %4, null
  %640 = zext i1 %639 to i8
  %641 = icmp ne i8 %640, 0
  br i1 %641, label %if.then211, label %if.done212

if.then211:                                       ; preds = %defer210
  %642 = load i64, ptr %n, align 8
  %643 = load i64, ptr %4, align 8
  %644 = add i64 %643, %642
  store i64 %644, ptr %4, align 8
  br label %if.done212

if.done212:                                       ; preds = %if.then211, %defer210
  ret i32 %638

or_return.continue213:                            ; preds = %or_return.continue208
  br label %for.init214

for.init214:                                      ; preds = %or_return.continue213
  store i64 12, ptr %s215, align 8
  br label %for.loop216

for.loop216:                                      ; preds = %for.post223, %for.init214
  %645 = load i64, ptr %s215, align 8
  %646 = icmp sge i64 %645, 0
  %647 = zext i1 %646 to i8
  %648 = icmp ne i8 %647, 0
  br i1 %648, label %for.body217, label %for.done224

for.body217:                                      ; preds = %for.loop216
  %649 = load %..string, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %650 = load ptr, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %651 = load i64, ptr getelementptr (%..string, ptr @"io::[util.odin]::DIGITS_LOWER", i64 0, i32 1), align 8
  %652 = load i16, ptr %bc, align 2
  %653 = load i64, ptr %s215, align 8
  %654 = trunc i64 %653 to i16
  %655 = icmp ult i16 %654, 16
  %656 = lshr i16 %652, %654
  %657 = select i1 %655, i16 %656, i16 0
  %658 = and i16 %657, 15
  %659 = zext i16 %658 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 243, i32 34, i64 %659, i64 %651)
  %660 = getelementptr i8, ptr %650, i64 %659
  %661 = load i8, ptr %660, align 1
  store %"io::Stream" %85, ptr %81, align 8
  %662 = load { i64, i64 }, ptr %81, align 8
  %663 = call i32 @"io::write_byte"({ i64, i64 } %662, i8 %661, ptr %n, ptr %__.context_ptr)
  %664 = icmp eq i32 %663, 0
  br i1 %664, label %or_return.continue222, label %or_return.return218

or_return.return218:                              ; preds = %for.body217
  store i32 %663, ptr %err, align 4
  %665 = load i64, ptr %n, align 8
  %666 = load i32, ptr %err, align 4
  store i64 %665, ptr %n, align 8
  store i32 %666, ptr %err, align 4
  store i64 %665, ptr %6, align 8
  br label %defer219

defer219:                                         ; preds = %or_return.return218
  %667 = icmp ne ptr %4, null
  %668 = zext i1 %667 to i8
  %669 = icmp ne i8 %668, 0
  br i1 %669, label %if.then220, label %if.done221

if.then220:                                       ; preds = %defer219
  %670 = load i64, ptr %n, align 8
  %671 = load i64, ptr %4, align 8
  %672 = add i64 %671, %670
  store i64 %672, ptr %4, align 8
  br label %if.done221

if.done221:                                       ; preds = %if.then220, %defer219
  ret i32 %666

or_return.continue222:                            ; preds = %for.body217
  br label %for.post223

for.post223:                                      ; preds = %or_return.continue222
  %673 = load i64, ptr %s215, align 8
  %674 = sub i64 %673, 4
  store i64 %674, ptr %s215, align 8
  br label %for.loop216

for.done224:                                      ; preds = %for.loop216
  br label %for.index.loop

for.index.done:                                   ; preds = %for.index.loop
  br label %if.done247

if.else225:                                       ; preds = %switch.default.body202
  store %"io::Stream" %85, ptr %82, align 8
  %675 = load { i64, i64 }, ptr %82, align 8
  %676 = call i32 @"io::write_byte"({ i64, i64 } %675, i8 92, ptr %n, ptr %__.context_ptr)
  %677 = icmp eq i32 %676, 0
  br i1 %677, label %or_return.continue230, label %or_return.return226

or_return.return226:                              ; preds = %if.else225
  store i32 %676, ptr %err, align 4
  %678 = load i64, ptr %n, align 8
  %679 = load i32, ptr %err, align 4
  store i64 %678, ptr %n, align 8
  store i32 %679, ptr %err, align 4
  store i64 %678, ptr %6, align 8
  br label %defer227

defer227:                                         ; preds = %or_return.return226
  %680 = icmp ne ptr %4, null
  %681 = zext i1 %680 to i8
  %682 = icmp ne i8 %681, 0
  br i1 %682, label %if.then228, label %if.done229

if.then228:                                       ; preds = %defer227
  %683 = load i64, ptr %n, align 8
  %684 = load i64, ptr %4, align 8
  %685 = add i64 %684, %683
  store i64 %685, ptr %4, align 8
  br label %if.done229

if.done229:                                       ; preds = %if.then228, %defer227
  ret i32 %679

or_return.continue230:                            ; preds = %if.else225
  store %"io::Stream" %85, ptr %83, align 8
  %686 = load { i64, i64 }, ptr %83, align 8
  %687 = call i32 @"io::write_byte"({ i64, i64 } %686, i8 85, ptr %n, ptr %__.context_ptr)
  %688 = icmp eq i32 %687, 0
  br i1 %688, label %or_return.continue235, label %or_return.return231

or_return.return231:                              ; preds = %or_return.continue230
  store i32 %687, ptr %err, align 4
  %689 = load i64, ptr %n, align 8
  %690 = load i32, ptr %err, align 4
  store i64 %689, ptr %n, align 8
  store i32 %690, ptr %err, align 4
  store i64 %689, ptr %6, align 8
  br label %defer232

defer232:                                         ; preds = %or_return.return231
  %691 = icmp ne ptr %4, null
  %692 = zext i1 %691 to i8
  %693 = icmp ne i8 %692, 0
  br i1 %693, label %if.then233, label %if.done234

if.then233:                                       ; preds = %defer232
  %694 = load i64, ptr %n, align 8
  %695 = load i64, ptr %4, align 8
  %696 = add i64 %695, %694
  store i64 %696, ptr %4, align 8
  br label %if.done234

if.done234:                                       ; preds = %if.then233, %defer232
  ret i32 %690

or_return.continue235:                            ; preds = %or_return.continue230
  br label %for.init236

for.init236:                                      ; preds = %or_return.continue235
  store i64 28, ptr %s237, align 8
  br label %for.loop238

for.loop238:                                      ; preds = %for.post245, %for.init236
  %697 = load i64, ptr %s237, align 8
  %698 = icmp sge i64 %697, 0
  %699 = zext i1 %698 to i8
  %700 = icmp ne i8 %699, 0
  br i1 %700, label %for.body239, label %for.done246

for.body239:                                      ; preds = %for.loop238
  %701 = load %..string, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %702 = load ptr, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %703 = load i64, ptr getelementptr (%..string, ptr @"io::[util.odin]::DIGITS_LOWER", i64 0, i32 1), align 8
  %704 = load i32, ptr %c, align 4
  %705 = load i64, ptr %s237, align 8
  %706 = trunc i64 %705 to i32
  %707 = icmp ult i32 %706, 32
  %708 = ashr i32 %704, %706
  %709 = select i1 %707, i32 %708, i32 0
  %710 = and i32 %709, 15
  %711 = sext i32 %710 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 250, i32 33, i64 %711, i64 %703)
  %712 = getelementptr i8, ptr %702, i64 %711
  %713 = load i8, ptr %712, align 1
  store %"io::Stream" %85, ptr %84, align 8
  %714 = load { i64, i64 }, ptr %84, align 8
  %715 = call i32 @"io::write_byte"({ i64, i64 } %714, i8 %713, ptr %n, ptr %__.context_ptr)
  %716 = icmp eq i32 %715, 0
  br i1 %716, label %or_return.continue244, label %or_return.return240

or_return.return240:                              ; preds = %for.body239
  store i32 %715, ptr %err, align 4
  %717 = load i64, ptr %n, align 8
  %718 = load i32, ptr %err, align 4
  store i64 %717, ptr %n, align 8
  store i32 %718, ptr %err, align 4
  store i64 %717, ptr %6, align 8
  br label %defer241

defer241:                                         ; preds = %or_return.return240
  %719 = icmp ne ptr %4, null
  %720 = zext i1 %719 to i8
  %721 = icmp ne i8 %720, 0
  br i1 %721, label %if.then242, label %if.done243

if.then242:                                       ; preds = %defer241
  %722 = load i64, ptr %n, align 8
  %723 = load i64, ptr %4, align 8
  %724 = add i64 %723, %722
  store i64 %724, ptr %4, align 8
  br label %if.done243

if.done243:                                       ; preds = %if.then242, %defer241
  ret i32 %718

or_return.continue244:                            ; preds = %for.body239
  br label %for.post245

for.post245:                                      ; preds = %or_return.continue244
  %725 = load i64, ptr %s237, align 8
  %726 = sub i64 %725, 4
  store i64 %726, ptr %s237, align 8
  br label %for.loop238

for.done246:                                      ; preds = %for.loop238
  br label %if.done247

if.done247:                                       ; preds = %for.done246, %for.index.done
  br label %switch.done248

switch.done248:                                   ; preds = %if.done247, %for.done201, %unreachable, %or_return.continue176
  br label %switch.done249

switch.done249:                                   ; preds = %switch.done248, %or_return.continue154, %or_return.continue148, %or_return.continue142, %or_return.continue136, %or_return.continue130, %or_return.continue124, %or_return.continue118, %or_return.continue112
  %727 = load i64, ptr %n, align 8
  %728 = load i32, ptr %err, align 4
  store i64 %727, ptr %n, align 8
  store i32 %728, ptr %err, align 4
  store i64 %727, ptr %6, align 8
  br label %defer250

defer250:                                         ; preds = %switch.done249
  %729 = icmp ne ptr %4, null
  %730 = zext i1 %729 to i8
  %731 = icmp ne i8 %730, 0
  br i1 %731, label %if.then251, label %if.done252

if.then251:                                       ; preds = %defer250
  %732 = load i64, ptr %n, align 8
  %733 = load i64, ptr %4, align 8
  %734 = add i64 %733, %732
  store i64 %734, ptr %4, align 8
  br label %if.done252

if.done252:                                       ; preds = %if.then251, %defer250
  ret i32 %728
}

define internal i64 @"os::write_entire_file_or_err"(%..string %0, { ptr, i64 } %1, i8 %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca %..string, align 8
  %4 = alloca { ptr, i64 }, align 8
  %5 = alloca i8, align 1
  %flags = alloca i64, align 8
  %mode = alloca i64, align 8
  %6 = alloca i32, align 4
  %7 = alloca %"os::Error", align 16
  %8 = alloca { i32, %"os::Error" }, align 4
  %9 = alloca i64, align 16
  %fd = alloca i32, align 4
  %n = alloca i64, align 8
  %10 = alloca { ptr, i64 }, align 8
  %11 = alloca i64, align 8
  %12 = alloca %"os::Error", align 16
  %13 = alloca { i64, %"os::Error" }, align 8
  %14 = alloca i64, align 16
  %15 = alloca %"os::Error", align 16
  %16 = alloca i64, align 16
  %17 = alloca %"os::Error", align 16
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %3, align 8
  store { ptr, i64 } %1, ptr %4, align 8
  store i8 %2, ptr %5, align 1
  store i64 65, ptr %flags, align 8
  %18 = icmp ne i8 %2, 0
  br i1 %18, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %19 = load i64, ptr %flags, align 8
  %20 = or i64 %19, 512
  store i64 %20, ptr %flags, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  store i64 0, ptr %mode, align 8
  store i64 420, ptr %mode, align 8
  %21 = load i64, ptr %flags, align 8
  %22 = load i64, ptr %mode, align 8
  store i32 0, ptr %6, align 4
  %23 = call i64 @"os::open"(%..string %0, i64 %21, i64 %22, ptr %6, ptr %__.context_ptr)
  store i64 %23, ptr %7, align 8
  %24 = load %"os::Error", ptr %7, align 4
  %25 = load i32, ptr %6, align 4
  %26 = load { i32, %"os::Error" }, ptr %8, align 4
  %27 = getelementptr inbounds nuw %"os::Error", ptr %7, i32 0, i32 1
  %28 = load i32, ptr %27, align 4
  %29 = icmp eq i32 %28, 0
  br i1 %29, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %if.done
  store %"os::Error" %24, ptr %9, align 4
  %30 = load i64, ptr %9, align 8
  ret i64 %30

or_return.continue:                               ; preds = %if.done
  store i32 %25, ptr %fd, align 4
  br label %for.init

for.init:                                         ; preds = %or_return.continue
  store i64 0, ptr %n, align 8
  br label %for.loop

for.loop:                                         ; preds = %or_return.continue2, %for.init
  %31 = load i64, ptr %n, align 8
  %32 = extractvalue { ptr, i64 } %1, 1
  %33 = icmp slt i64 %31, %32
  %34 = zext i1 %33 to i8
  %35 = icmp ne i8 %34, 0
  br i1 %35, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %36 = load i32, ptr %fd, align 4
  %37 = load { ptr, i64 }, ptr %4, align 8
  %38 = load i64, ptr %n, align 8
  %39 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 1
  %40 = load i64, ptr %39, align 8
  call void @"runtime::slice_expr_error_lo_hi"(%..string { ptr @"csbs$byte_world$1f9", i64 29 }, i32 191, i32 22, i64 %38, i64 %40, i64 %40)
  %41 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 0
  %42 = load ptr, ptr %41, align 8
  %43 = getelementptr i8, ptr %42, i64 %38
  %44 = sub i64 %40, %38
  %45 = getelementptr inbounds nuw { ptr, i64 }, ptr %10, i32 0, i32 0
  store ptr %43, ptr %45, align 8
  %46 = getelementptr inbounds nuw { ptr, i64 }, ptr %10, i32 0, i32 1
  store i64 %44, ptr %46, align 8
  %47 = load { ptr, i64 }, ptr %10, align 8
  store i64 0, ptr %11, align 8
  %48 = call i64 @"os::write"(i32 %36, { ptr, i64 } %47, ptr %11, ptr %__.context_ptr)
  store i64 %48, ptr %12, align 8
  %49 = load %"os::Error", ptr %12, align 4
  %50 = load i64, ptr %11, align 8
  %51 = load { i64, %"os::Error" }, ptr %13, align 8
  %52 = getelementptr inbounds nuw %"os::Error", ptr %12, i32 0, i32 1
  %53 = load i32, ptr %52, align 4
  %54 = icmp eq i32 %53, 0
  br i1 %54, label %or_return.continue2, label %or_return.return1

or_return.return1:                                ; preds = %for.body
  store %"os::Error" %49, ptr %14, align 4
  %55 = load i64, ptr %14, align 8
  br label %defer

defer:                                            ; preds = %or_return.return1
  %56 = load i32, ptr %fd, align 4
  %57 = call i64 @"os::close"(i32 %56, ptr %__.context_ptr)
  store i64 %57, ptr %15, align 8
  %58 = load %"os::Error", ptr %15, align 4
  ret i64 %55

or_return.continue2:                              ; preds = %for.body
  %59 = load i64, ptr %n, align 8
  %60 = add i64 %59, %50
  store i64 %60, ptr %n, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  store %"os::Error" zeroinitializer, ptr %16, align 4
  %61 = load i64, ptr %16, align 8
  br label %defer3

defer3:                                           ; preds = %for.done
  %62 = load i32, ptr %fd, align 4
  %63 = call i64 @"os::close"(i32 %62, ptr %__.context_ptr)
  store i64 %63, ptr %17, align 8
  %64 = load %"os::Error", ptr %17, align 4
  ret i64 %61
}

; Function Attrs: noinline
define internal i8 @"runtime::mem_free_with_size"(ptr %0, i64 %1, { i64, i64 } %2, ptr %3, ptr noalias nonnull "captures"="none" %__.context_ptr) #4 {
decls:
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  %6 = alloca %"runtime::Allocator", align 16
  %7 = alloca { ptr, i64 }, align 8
  %8 = alloca { { ptr, i64 }, i8 }, align 8
  %err = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %4, align 8
  store i64 %1, ptr %5, align 8
  store { i64, i64 } %2, ptr %6, align 8
  %9 = load %"runtime::Allocator", ptr %6, align 8
  %10 = icmp eq ptr %0, null
  %11 = zext i1 %10 to i8
  %12 = icmp ne i8 %11, 0
  br i1 %12, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %entry
  %13 = getelementptr inbounds nuw %"runtime::Allocator", ptr %6, i32 0, i32 0
  %14 = load ptr, ptr %13, align 8
  %15 = icmp eq ptr %14, null
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %entry
  ret i8 0

if.done:                                          ; preds = %cmp.or
  %18 = getelementptr inbounds nuw %"runtime::Allocator", ptr %6, i32 0, i32 0
  %19 = load ptr, ptr %18, align 8
  %20 = getelementptr inbounds nuw %"runtime::Allocator", ptr %6, i32 0, i32 1
  %21 = load ptr, ptr %20, align 8
  %22 = load %"runtime::Source_Code_Location", ptr %3, align 8
  call void @llvm.memset.inline.p0.i64(ptr %7, i8 0, i64 16, i1 false)
  %23 = call i8 %19(ptr %21, i8 1, i64 0, i64 0, ptr %0, i64 %1, ptr %3, ptr %7, ptr %__.context_ptr)
  %24 = load { ptr, i64 }, ptr %7, align 8
  %25 = load { { ptr, i64 }, i8 }, ptr %8, align 8
  store i8 %23, ptr %err, align 1
  %26 = load i8, ptr %err, align 1
  ret i8 %26
}

declare i32 @pthread_attr_getschedpolicy(ptr, ptr)

define internal i32 @"io::flush"({ i64, i64 } %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca %"io::Stream", align 16
  %err = alloca i32, align 4
  %2 = alloca i64, align 8
  %3 = alloca { i64, i32 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %1, align 8
  %4 = load %"io::Stream", ptr %1, align 8
  store i32 0, ptr %err, align 4
  %5 = getelementptr inbounds nuw %"io::Stream", ptr %1, i32 0, i32 0
  %6 = load ptr, ptr %5, align 8
  %7 = icmp ne ptr %6, null
  %8 = zext i1 %7 to i8
  %9 = icmp ne i8 %8, 0
  br i1 %9, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %10 = getelementptr inbounds nuw %"io::Stream", ptr %1, i32 0, i32 0
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr inbounds nuw %"io::Stream", ptr %1, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  store i64 0, ptr %2, align 8
  %14 = call i32 %11(ptr %13, i64 1, { ptr, i64 } zeroinitializer, i64 0, i64 0, ptr %2, ptr %__.context_ptr)
  %15 = load i64, ptr %2, align 8
  %16 = load { i64, i32 }, ptr %3, align 8
  store i32 %14, ptr %err, align 4
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %17 = load i32, ptr %err, align 4
  store i32 %17, ptr %err, align 4
  ret i32 %17
}

define internal void @"main::detect_active_regions"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca { i64, i64 }, align 16
  %3 = alloca { ptr, i64 }, align 8
  %4 = alloca { { ptr, i64 }, i8 }, align 8
  %visited = alloca { ptr, i64 }, align 8
  %5 = alloca { i64, i64 }, align 16
  %6 = alloca { ptr, i64, i64, %"runtime::Allocator" }, align 8
  %7 = alloca { { ptr, i64, i64, %"runtime::Allocator" }, i8 }, align 8
  %stack = alloca { ptr, i64, i64, %"runtime::Allocator" }, align 8
  %y = alloca i64, align 8
  %x = alloca i64, align 8
  %idx = alloca i64, align 8
  %8 = alloca i64, align 8
  %9 = alloca { i64, i8 }, align 8
  %min_x = alloca i64, align 8
  %max_x = alloca i64, align 8
  %min_y = alloca i64, align 8
  %max_y = alloca i64, align 8
  %total_alpha = alloca float, align 4
  %count = alloca i64, align 8
  %curr_idx = alloca i64, align 8
  %curr_val = alloca float, align 4
  %cx = alloca i64, align 8
  %cy = alloca i64, align 8
  %n_idx = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca { i64, i8 }, align 8
  %n_idx19 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca { i64, i8 }, align 8
  %n_idx25 = alloca i64, align 8
  %14 = alloca i64, align 8
  %15 = alloca { i64, i8 }, align 8
  %n_idx31 = alloca i64, align 8
  %16 = alloca i64, align 8
  %17 = alloca { i64, i8 }, align 8
  %width = alloca i64, align 8
  %height = alloca i64, align 8
  %final_x = alloca i64, align 8
  %final_y = alloca i64, align 8
  %final_w = alloca i64, align 8
  %final_h = alloca i64, align 8
  %18 = alloca %"main::Detected_Blob", align 8
  %19 = alloca %"raylib::Rectangle", align 4
  %20 = alloca i64, align 8
  %21 = alloca { i64, i8 }, align 8
  %22 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  call void @"runtime::clear_dynamic_array:proc\22contextless\22(array:^[dynamic]main::Detected_Blob)"(ptr @"main::detected_blobs")
  %23 = load ptr, ptr %1, align 8
  %24 = getelementptr inbounds nuw %"main::Byte_World", ptr %23, i32 0, i32 0
  %25 = load i64, ptr %24, align 8
  %26 = load ptr, ptr %1, align 8
  %27 = getelementptr inbounds nuw %"main::Byte_World", ptr %26, i32 0, i32 0
  %28 = load i64, ptr %27, align 8
  %29 = mul i64 %25, %28
  %30 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 0
  %31 = load %"runtime::Allocator", ptr %30, align 8
  %32 = load %"runtime::Source_Code_Location", ptr @"scl$[detect_active_regions4975]", align 8
  store %"runtime::Allocator" %31, ptr %2, align 8
  %33 = load { i64, i64 }, ptr %2, align 8
  call void @llvm.memset.inline.p0.i64(ptr %3, i8 0, i64 16, i1 false)
  %34 = call i8 @"runtime::make_slice:proc(T:$[]bool,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]bool,err:runtime::Allocator_Error)"(i64 %29, { i64, i64 } %33, ptr @"scl$[detect_active_regions4975]", ptr %3, ptr %__.context_ptr)
  %35 = load { ptr, i64 }, ptr %3, align 8
  %36 = load { { ptr, i64 }, i8 }, ptr %4, align 8
  store { ptr, i64 } %35, ptr %visited, align 8
  %37 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 0
  %38 = load %"runtime::Allocator", ptr %37, align 8
  %39 = load %"runtime::Source_Code_Location", ptr @"scl$[detect_active_regions5064]", align 8
  store %"runtime::Allocator" %38, ptr %5, align 8
  %40 = load { i64, i64 }, ptr %5, align 8
  call void @llvm.memset.p0.i64(ptr %6, i8 0, i64 40, i1 false)
  %41 = call i8 @"runtime::make_dynamic_array_len_cap:proc(T:$[dynamic]int,len:int,cap:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]int,err:runtime::Allocator_Error)"(i64 0, i64 1000, { i64, i64 } %40, ptr @"scl$[detect_active_regions5064]", ptr %6, ptr %__.context_ptr)
  %42 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %6, align 8
  %43 = load { { ptr, i64, i64, %"runtime::Allocator" }, i8 }, ptr %7, align 8
  store { ptr, i64, i64, %"runtime::Allocator" } %42, ptr %stack, align 8
  br label %for.init

for.init:                                         ; preds = %entry
  store i64 0, ptr %y, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post44, %for.init
  %44 = load i64, ptr %y, align 8
  %45 = load ptr, ptr %1, align 8
  %46 = getelementptr inbounds nuw %"main::Byte_World", ptr %45, i32 0, i32 0
  %47 = load i64, ptr %46, align 8
  %48 = icmp slt i64 %44, %47
  %49 = zext i1 %48 to i8
  %50 = icmp ne i8 %49, 0
  br i1 %50, label %for.body, label %for.done45

for.body:                                         ; preds = %for.loop
  br label %for.init1

for.init1:                                        ; preds = %for.body
  store i64 0, ptr %x, align 8
  br label %for.loop2

for.loop2:                                        ; preds = %for.post, %for.init1
  %51 = load i64, ptr %x, align 8
  %52 = load ptr, ptr %1, align 8
  %53 = getelementptr inbounds nuw %"main::Byte_World", ptr %52, i32 0, i32 0
  %54 = load i64, ptr %53, align 8
  %55 = icmp slt i64 %51, %54
  %56 = zext i1 %55 to i8
  %57 = icmp ne i8 %56, 0
  br i1 %57, label %for.body3, label %for.done43

for.body3:                                        ; preds = %for.loop2
  %58 = load ptr, ptr %1, align 8
  %59 = getelementptr inbounds nuw %"main::Byte_World", ptr %58, i32 0, i32 0
  %60 = load i64, ptr %59, align 8
  %61 = load i64, ptr %x, align 8
  %62 = load i64, ptr %y, align 8
  %63 = call i64 @"main::idx_of"(i64 %60, i64 %61, i64 %62, ptr %__.context_ptr)
  store i64 %63, ptr %idx, align 8
  %64 = load ptr, ptr %1, align 8
  %65 = getelementptr inbounds nuw %"main::Byte_World", ptr %64, i32 0, i32 3
  %66 = load { ptr, i64 }, ptr %65, align 8
  %67 = getelementptr inbounds nuw { ptr, i64 }, ptr %65, i32 0, i32 0
  %68 = load ptr, ptr %67, align 8
  %69 = load i64, ptr %idx, align 8
  %70 = getelementptr inbounds nuw { ptr, i64 }, ptr %65, i32 0, i32 1
  %71 = load i64, ptr %70, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 183, i32 15, i64 %69, i64 %71)
  %72 = getelementptr float, ptr %68, i64 %69
  %73 = load float, ptr %72, align 4
  %74 = load float, ptr @"main::detect_alpha_threshold", align 4
  %75 = fcmp ogt float %73, %74
  %76 = zext i1 %75 to i8
  %77 = icmp ne i8 %76, 0
  br i1 %77, label %cmp.and, label %if.done42

cmp.and:                                          ; preds = %for.body3
  %78 = load { ptr, i64 }, ptr %visited, align 8
  %79 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 0
  %80 = load ptr, ptr %79, align 8
  %81 = load i64, ptr %idx, align 8
  %82 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 1
  %83 = load i64, ptr %82, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 183, i32 57, i64 %81, i64 %83)
  %84 = getelementptr i8, ptr %80, i64 %81
  %85 = load i8, ptr %84, align 1
  %86 = icmp ne i8 %85, 0
  br i1 %86, label %if.done42, label %if.then

if.then:                                          ; preds = %cmp.and
  %87 = load i64, ptr %idx, align 8
  %88 = load %"runtime::Source_Code_Location", ptr @"scl$[detect_active_regions5379]", align 8
  store i64 0, ptr %8, align 8
  %89 = call i8 @"runtime::append_elem:proc(array:^[dynamic]int,arg:int,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr %stack, i64 %87, ptr @"scl$[detect_active_regions5379]", ptr %8, ptr %__.context_ptr)
  %90 = load i64, ptr %8, align 8
  %91 = load { i64, i8 }, ptr %9, align 8
  %92 = load { ptr, i64 }, ptr %visited, align 8
  %93 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 0
  %94 = load ptr, ptr %93, align 8
  %95 = load i64, ptr %idx, align 8
  %96 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 1
  %97 = load i64, ptr %96, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 187, i32 13, i64 %95, i64 %97)
  %98 = getelementptr i8, ptr %94, i64 %95
  store i8 1, ptr %98, align 1
  %99 = load i64, ptr %x, align 8
  %100 = load i64, ptr %x, align 8
  store i64 %99, ptr %min_x, align 8
  store i64 %100, ptr %max_x, align 8
  %101 = load i64, ptr %y, align 8
  %102 = load i64, ptr %y, align 8
  store i64 %101, ptr %min_y, align 8
  store i64 %102, ptr %max_y, align 8
  store float 0.000000e+00, ptr %total_alpha, align 4
  store i64 0, ptr %count, align 8
  br label %for.loop4

for.loop4:                                        ; preds = %if.done35, %if.then
  %103 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %stack, align 8
  %104 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %stack, i32 0, i32 1
  %105 = load i64, ptr %104, align 8
  %106 = icmp sgt i64 %105, 0
  %107 = zext i1 %106 to i8
  %108 = icmp ne i8 %107, 0
  br i1 %108, label %for.body5, label %for.done

for.body5:                                        ; preds = %for.loop4
  %109 = load %"runtime::Source_Code_Location", ptr @"scl$[detect_active_regions5563]", align 8
  %110 = call i64 @"runtime::pop:proc(array:^[dynamic]int,loc:runtime::Source_Code_Location)->(res:int)"(ptr %stack, ptr @"scl$[detect_active_regions5563]", ptr %__.context_ptr)
  store i64 %110, ptr %curr_idx, align 8
  %111 = load ptr, ptr %1, align 8
  %112 = getelementptr inbounds nuw %"main::Byte_World", ptr %111, i32 0, i32 3
  %113 = load { ptr, i64 }, ptr %112, align 8
  %114 = getelementptr inbounds nuw { ptr, i64 }, ptr %112, i32 0, i32 0
  %115 = load ptr, ptr %114, align 8
  %116 = load i64, ptr %curr_idx, align 8
  %117 = getelementptr inbounds nuw { ptr, i64 }, ptr %112, i32 0, i32 1
  %118 = load i64, ptr %117, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 196, i32 26, i64 %116, i64 %118)
  %119 = getelementptr float, ptr %115, i64 %116
  %120 = load float, ptr %119, align 4
  store float %120, ptr %curr_val, align 4
  %121 = load i64, ptr %curr_idx, align 8
  %122 = load ptr, ptr %1, align 8
  %123 = getelementptr inbounds nuw %"main::Byte_World", ptr %122, i32 0, i32 0
  %124 = load i64, ptr %123, align 8
  %125 = icmp ne i64 %124, 0
  br i1 %125, label %mod.safe, label %mod.edge

mod.safe:                                         ; preds = %for.body5
  %126 = srem i64 %121, %124
  br label %mod.done

mod.edge:                                         ; preds = %for.body5
  call void @llvm.trap()
  unreachable

mod.done:                                         ; preds = %mod.safe
  store i64 %126, ptr %cx, align 8
  %127 = load i64, ptr %curr_idx, align 8
  %128 = load ptr, ptr %1, align 8
  %129 = getelementptr inbounds nuw %"main::Byte_World", ptr %128, i32 0, i32 0
  %130 = load i64, ptr %129, align 8
  %131 = icmp ne i64 %130, 0
  br i1 %131, label %div.safe, label %div.edge

div.safe:                                         ; preds = %mod.done
  %132 = sdiv i64 %127, %130
  br label %div.done

div.edge:                                         ; preds = %mod.done
  call void @llvm.trap()
  unreachable

div.done:                                         ; preds = %div.safe
  store i64 %132, ptr %cy, align 8
  %133 = load i64, ptr %cx, align 8
  %134 = load i64, ptr %min_x, align 8
  %135 = icmp slt i64 %133, %134
  %136 = zext i1 %135 to i8
  %137 = icmp ne i8 %136, 0
  br i1 %137, label %if.then6, label %if.done

if.then6:                                         ; preds = %div.done
  %138 = load i64, ptr %cx, align 8
  store i64 %138, ptr %min_x, align 8
  br label %if.done

if.done:                                          ; preds = %if.then6, %div.done
  %139 = load i64, ptr %cx, align 8
  %140 = load i64, ptr %max_x, align 8
  %141 = icmp sgt i64 %139, %140
  %142 = zext i1 %141 to i8
  %143 = icmp ne i8 %142, 0
  br i1 %143, label %if.then7, label %if.done8

if.then7:                                         ; preds = %if.done
  %144 = load i64, ptr %cx, align 8
  store i64 %144, ptr %max_x, align 8
  br label %if.done8

if.done8:                                         ; preds = %if.then7, %if.done
  %145 = load i64, ptr %cy, align 8
  %146 = load i64, ptr %min_y, align 8
  %147 = icmp slt i64 %145, %146
  %148 = zext i1 %147 to i8
  %149 = icmp ne i8 %148, 0
  br i1 %149, label %if.then9, label %if.done10

if.then9:                                         ; preds = %if.done8
  %150 = load i64, ptr %cy, align 8
  store i64 %150, ptr %min_y, align 8
  br label %if.done10

if.done10:                                        ; preds = %if.then9, %if.done8
  %151 = load i64, ptr %cy, align 8
  %152 = load i64, ptr %max_y, align 8
  %153 = icmp sgt i64 %151, %152
  %154 = zext i1 %153 to i8
  %155 = icmp ne i8 %154, 0
  br i1 %155, label %if.then11, label %if.done12

if.then11:                                        ; preds = %if.done10
  %156 = load i64, ptr %cy, align 8
  store i64 %156, ptr %max_y, align 8
  br label %if.done12

if.done12:                                        ; preds = %if.then11, %if.done10
  %157 = load float, ptr %curr_val, align 4
  %158 = load float, ptr %total_alpha, align 4
  %159 = fadd float %158, %157
  store float %159, ptr %total_alpha, align 4
  %160 = load i64, ptr %count, align 8
  %161 = add i64 %160, 1
  store i64 %161, ptr %count, align 8
  %162 = load i64, ptr %cy, align 8
  %163 = icmp sgt i64 %162, 0
  %164 = zext i1 %163 to i8
  %165 = icmp ne i8 %164, 0
  br i1 %165, label %if.then13, label %if.done17

if.then13:                                        ; preds = %if.done12
  %166 = load i64, ptr %curr_idx, align 8
  %167 = load ptr, ptr %1, align 8
  %168 = getelementptr inbounds nuw %"main::Byte_World", ptr %167, i32 0, i32 0
  %169 = load i64, ptr %168, align 8
  %170 = sub i64 %166, %169
  store i64 %170, ptr %n_idx, align 8
  %171 = load { ptr, i64 }, ptr %visited, align 8
  %172 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 0
  %173 = load ptr, ptr %172, align 8
  %174 = load i64, ptr %n_idx, align 8
  %175 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 1
  %176 = load i64, ptr %175, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 218, i32 19, i64 %174, i64 %176)
  %177 = getelementptr i8, ptr %173, i64 %174
  %178 = load i8, ptr %177, align 1
  %179 = icmp ne i8 %178, 0
  br i1 %179, label %if.done16, label %cmp.and14

cmp.and14:                                        ; preds = %if.then13
  %180 = load ptr, ptr %1, align 8
  %181 = getelementptr inbounds nuw %"main::Byte_World", ptr %180, i32 0, i32 3
  %182 = load { ptr, i64 }, ptr %181, align 8
  %183 = getelementptr inbounds nuw { ptr, i64 }, ptr %181, i32 0, i32 0
  %184 = load ptr, ptr %183, align 8
  %185 = load i64, ptr %n_idx, align 8
  %186 = getelementptr inbounds nuw { ptr, i64 }, ptr %181, i32 0, i32 1
  %187 = load i64, ptr %186, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 218, i32 37, i64 %185, i64 %187)
  %188 = getelementptr float, ptr %184, i64 %185
  %189 = load float, ptr %188, align 4
  %190 = load float, ptr @"main::detect_alpha_threshold", align 4
  %191 = fcmp ogt float %189, %190
  %192 = zext i1 %191 to i8
  %193 = icmp ne i8 %192, 0
  br i1 %193, label %if.then15, label %if.done16

if.then15:                                        ; preds = %cmp.and14
  %194 = load { ptr, i64 }, ptr %visited, align 8
  %195 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 0
  %196 = load ptr, ptr %195, align 8
  %197 = load i64, ptr %n_idx, align 8
  %198 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 1
  %199 = load i64, ptr %198, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 219, i32 16, i64 %197, i64 %199)
  %200 = getelementptr i8, ptr %196, i64 %197
  store i8 1, ptr %200, align 1
  %201 = load i64, ptr %n_idx, align 8
  %202 = load %"runtime::Source_Code_Location", ptr @"scl$[detect_active_regions6251]", align 8
  store i64 0, ptr %10, align 8
  %203 = call i8 @"runtime::append_elem:proc(array:^[dynamic]int,arg:int,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr %stack, i64 %201, ptr @"scl$[detect_active_regions6251]", ptr %10, ptr %__.context_ptr)
  %204 = load i64, ptr %10, align 8
  %205 = load { i64, i8 }, ptr %11, align 8
  br label %if.done16

if.done16:                                        ; preds = %if.then15, %cmp.and14, %if.then13
  br label %if.done17

if.done17:                                        ; preds = %if.done16, %if.done12
  %206 = load i64, ptr %cy, align 8
  %207 = load ptr, ptr %1, align 8
  %208 = getelementptr inbounds nuw %"main::Byte_World", ptr %207, i32 0, i32 0
  %209 = load i64, ptr %208, align 8
  %210 = sub i64 %209, 1
  %211 = icmp slt i64 %206, %210
  %212 = zext i1 %211 to i8
  %213 = icmp ne i8 %212, 0
  br i1 %213, label %if.then18, label %if.done23

if.then18:                                        ; preds = %if.done17
  %214 = load i64, ptr %curr_idx, align 8
  %215 = load ptr, ptr %1, align 8
  %216 = getelementptr inbounds nuw %"main::Byte_World", ptr %215, i32 0, i32 0
  %217 = load i64, ptr %216, align 8
  %218 = add i64 %214, %217
  store i64 %218, ptr %n_idx19, align 8
  %219 = load { ptr, i64 }, ptr %visited, align 8
  %220 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 0
  %221 = load ptr, ptr %220, align 8
  %222 = load i64, ptr %n_idx19, align 8
  %223 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 1
  %224 = load i64, ptr %223, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 226, i32 19, i64 %222, i64 %224)
  %225 = getelementptr i8, ptr %221, i64 %222
  %226 = load i8, ptr %225, align 1
  %227 = icmp ne i8 %226, 0
  br i1 %227, label %if.done22, label %cmp.and20

cmp.and20:                                        ; preds = %if.then18
  %228 = load ptr, ptr %1, align 8
  %229 = getelementptr inbounds nuw %"main::Byte_World", ptr %228, i32 0, i32 3
  %230 = load { ptr, i64 }, ptr %229, align 8
  %231 = getelementptr inbounds nuw { ptr, i64 }, ptr %229, i32 0, i32 0
  %232 = load ptr, ptr %231, align 8
  %233 = load i64, ptr %n_idx19, align 8
  %234 = getelementptr inbounds nuw { ptr, i64 }, ptr %229, i32 0, i32 1
  %235 = load i64, ptr %234, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 226, i32 37, i64 %233, i64 %235)
  %236 = getelementptr float, ptr %232, i64 %233
  %237 = load float, ptr %236, align 4
  %238 = load float, ptr @"main::detect_alpha_threshold", align 4
  %239 = fcmp ogt float %237, %238
  %240 = zext i1 %239 to i8
  %241 = icmp ne i8 %240, 0
  br i1 %241, label %if.then21, label %if.done22

if.then21:                                        ; preds = %cmp.and20
  %242 = load { ptr, i64 }, ptr %visited, align 8
  %243 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 0
  %244 = load ptr, ptr %243, align 8
  %245 = load i64, ptr %n_idx19, align 8
  %246 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 1
  %247 = load i64, ptr %246, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 227, i32 16, i64 %245, i64 %247)
  %248 = getelementptr i8, ptr %244, i64 %245
  store i8 1, ptr %248, align 1
  %249 = load i64, ptr %n_idx19, align 8
  %250 = load %"runtime::Source_Code_Location", ptr @"scl$[detect_active_regions6464]", align 8
  store i64 0, ptr %12, align 8
  %251 = call i8 @"runtime::append_elem:proc(array:^[dynamic]int,arg:int,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr %stack, i64 %249, ptr @"scl$[detect_active_regions6464]", ptr %12, ptr %__.context_ptr)
  %252 = load i64, ptr %12, align 8
  %253 = load { i64, i8 }, ptr %13, align 8
  br label %if.done22

if.done22:                                        ; preds = %if.then21, %cmp.and20, %if.then18
  br label %if.done23

if.done23:                                        ; preds = %if.done22, %if.done17
  %254 = load i64, ptr %cx, align 8
  %255 = icmp sgt i64 %254, 0
  %256 = zext i1 %255 to i8
  %257 = icmp ne i8 %256, 0
  br i1 %257, label %if.then24, label %if.done29

if.then24:                                        ; preds = %if.done23
  %258 = load i64, ptr %curr_idx, align 8
  %259 = sub i64 %258, 1
  store i64 %259, ptr %n_idx25, align 8
  %260 = load { ptr, i64 }, ptr %visited, align 8
  %261 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 0
  %262 = load ptr, ptr %261, align 8
  %263 = load i64, ptr %n_idx25, align 8
  %264 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 1
  %265 = load i64, ptr %264, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 234, i32 19, i64 %263, i64 %265)
  %266 = getelementptr i8, ptr %262, i64 %263
  %267 = load i8, ptr %266, align 1
  %268 = icmp ne i8 %267, 0
  br i1 %268, label %if.done28, label %cmp.and26

cmp.and26:                                        ; preds = %if.then24
  %269 = load ptr, ptr %1, align 8
  %270 = getelementptr inbounds nuw %"main::Byte_World", ptr %269, i32 0, i32 3
  %271 = load { ptr, i64 }, ptr %270, align 8
  %272 = getelementptr inbounds nuw { ptr, i64 }, ptr %270, i32 0, i32 0
  %273 = load ptr, ptr %272, align 8
  %274 = load i64, ptr %n_idx25, align 8
  %275 = getelementptr inbounds nuw { ptr, i64 }, ptr %270, i32 0, i32 1
  %276 = load i64, ptr %275, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 234, i32 37, i64 %274, i64 %276)
  %277 = getelementptr float, ptr %273, i64 %274
  %278 = load float, ptr %277, align 4
  %279 = load float, ptr @"main::detect_alpha_threshold", align 4
  %280 = fcmp ogt float %278, %279
  %281 = zext i1 %280 to i8
  %282 = icmp ne i8 %281, 0
  br i1 %282, label %if.then27, label %if.done28

if.then27:                                        ; preds = %cmp.and26
  %283 = load { ptr, i64 }, ptr %visited, align 8
  %284 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 0
  %285 = load ptr, ptr %284, align 8
  %286 = load i64, ptr %n_idx25, align 8
  %287 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 1
  %288 = load i64, ptr %287, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 235, i32 16, i64 %286, i64 %288)
  %289 = getelementptr i8, ptr %285, i64 %286
  store i8 1, ptr %289, align 1
  %290 = load i64, ptr %n_idx25, align 8
  %291 = load %"runtime::Source_Code_Location", ptr @"scl$[detect_active_regions6665]", align 8
  store i64 0, ptr %14, align 8
  %292 = call i8 @"runtime::append_elem:proc(array:^[dynamic]int,arg:int,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr %stack, i64 %290, ptr @"scl$[detect_active_regions6665]", ptr %14, ptr %__.context_ptr)
  %293 = load i64, ptr %14, align 8
  %294 = load { i64, i8 }, ptr %15, align 8
  br label %if.done28

if.done28:                                        ; preds = %if.then27, %cmp.and26, %if.then24
  br label %if.done29

if.done29:                                        ; preds = %if.done28, %if.done23
  %295 = load i64, ptr %cx, align 8
  %296 = load ptr, ptr %1, align 8
  %297 = getelementptr inbounds nuw %"main::Byte_World", ptr %296, i32 0, i32 0
  %298 = load i64, ptr %297, align 8
  %299 = sub i64 %298, 1
  %300 = icmp slt i64 %295, %299
  %301 = zext i1 %300 to i8
  %302 = icmp ne i8 %301, 0
  br i1 %302, label %if.then30, label %if.done35

if.then30:                                        ; preds = %if.done29
  %303 = load i64, ptr %curr_idx, align 8
  %304 = add i64 %303, 1
  store i64 %304, ptr %n_idx31, align 8
  %305 = load { ptr, i64 }, ptr %visited, align 8
  %306 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 0
  %307 = load ptr, ptr %306, align 8
  %308 = load i64, ptr %n_idx31, align 8
  %309 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 1
  %310 = load i64, ptr %309, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 242, i32 19, i64 %308, i64 %310)
  %311 = getelementptr i8, ptr %307, i64 %308
  %312 = load i8, ptr %311, align 1
  %313 = icmp ne i8 %312, 0
  br i1 %313, label %if.done34, label %cmp.and32

cmp.and32:                                        ; preds = %if.then30
  %314 = load ptr, ptr %1, align 8
  %315 = getelementptr inbounds nuw %"main::Byte_World", ptr %314, i32 0, i32 3
  %316 = load { ptr, i64 }, ptr %315, align 8
  %317 = getelementptr inbounds nuw { ptr, i64 }, ptr %315, i32 0, i32 0
  %318 = load ptr, ptr %317, align 8
  %319 = load i64, ptr %n_idx31, align 8
  %320 = getelementptr inbounds nuw { ptr, i64 }, ptr %315, i32 0, i32 1
  %321 = load i64, ptr %320, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 242, i32 37, i64 %319, i64 %321)
  %322 = getelementptr float, ptr %318, i64 %319
  %323 = load float, ptr %322, align 4
  %324 = load float, ptr @"main::detect_alpha_threshold", align 4
  %325 = fcmp ogt float %323, %324
  %326 = zext i1 %325 to i8
  %327 = icmp ne i8 %326, 0
  br i1 %327, label %if.then33, label %if.done34

if.then33:                                        ; preds = %cmp.and32
  %328 = load { ptr, i64 }, ptr %visited, align 8
  %329 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 0
  %330 = load ptr, ptr %329, align 8
  %331 = load i64, ptr %n_idx31, align 8
  %332 = getelementptr inbounds nuw { ptr, i64 }, ptr %visited, i32 0, i32 1
  %333 = load i64, ptr %332, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 243, i32 16, i64 %331, i64 %333)
  %334 = getelementptr i8, ptr %330, i64 %331
  store i8 1, ptr %334, align 1
  %335 = load i64, ptr %n_idx31, align 8
  %336 = load %"runtime::Source_Code_Location", ptr @"scl$[detect_active_regions6874]", align 8
  store i64 0, ptr %16, align 8
  %337 = call i8 @"runtime::append_elem:proc(array:^[dynamic]int,arg:int,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr %stack, i64 %335, ptr @"scl$[detect_active_regions6874]", ptr %16, ptr %__.context_ptr)
  %338 = load i64, ptr %16, align 8
  %339 = load { i64, i8 }, ptr %17, align 8
  br label %if.done34

if.done34:                                        ; preds = %if.then33, %cmp.and32, %if.then30
  br label %if.done35

if.done35:                                        ; preds = %if.done34, %if.done29
  br label %for.loop4

for.done:                                         ; preds = %for.loop4
  %340 = load i64, ptr %max_x, align 8
  %341 = load i64, ptr %min_x, align 8
  %342 = sub i64 %340, %341
  %343 = add i64 %342, 1
  store i64 %343, ptr %width, align 8
  %344 = load i64, ptr %max_y, align 8
  %345 = load i64, ptr %min_y, align 8
  %346 = sub i64 %344, %345
  %347 = add i64 %346, 1
  store i64 %347, ptr %height, align 8
  %348 = load i64, ptr %width, align 8
  %349 = load i64, ptr @"main::min_blob_size", align 8
  %350 = icmp sge i64 %348, %349
  %351 = zext i1 %350 to i8
  %352 = icmp ne i8 %351, 0
  br i1 %352, label %cmp.and36, label %if.done41

cmp.and36:                                        ; preds = %for.done
  %353 = load i64, ptr %height, align 8
  %354 = load i64, ptr @"main::min_blob_size", align 8
  %355 = icmp sge i64 %353, %354
  %356 = zext i1 %355 to i8
  %357 = icmp ne i8 %356, 0
  br i1 %357, label %cmp.and37, label %if.done41

cmp.and37:                                        ; preds = %cmp.and36
  %358 = load i64, ptr %width, align 8
  %359 = load i64, ptr @"main::max_blob_size", align 8
  %360 = icmp sle i64 %358, %359
  %361 = zext i1 %360 to i8
  %362 = icmp ne i8 %361, 0
  br i1 %362, label %cmp.and38, label %if.done41

cmp.and38:                                        ; preds = %cmp.and37
  %363 = load i64, ptr %height, align 8
  %364 = load i64, ptr @"main::max_blob_size", align 8
  %365 = icmp sle i64 %363, %364
  %366 = zext i1 %365 to i8
  %367 = icmp ne i8 %366, 0
  br i1 %367, label %cmp.and39, label %if.done41

cmp.and39:                                        ; preds = %cmp.and38
  %368 = load i64, ptr %count, align 8
  %369 = load i64, ptr @"main::min_pixel_count", align 8
  %370 = icmp sge i64 %368, %369
  %371 = zext i1 %370 to i8
  %372 = icmp ne i8 %371, 0
  br i1 %372, label %if.then40, label %if.done41

if.then40:                                        ; preds = %cmp.and39
  %373 = load i64, ptr %min_x, align 8
  %374 = sub i64 %373, 2
  %375 = icmp sgt i64 0, %374
  %376 = select i1 %375, i64 0, i64 %374
  store i64 %376, ptr %final_x, align 8
  %377 = load i64, ptr %min_y, align 8
  %378 = sub i64 %377, 2
  %379 = icmp sgt i64 0, %378
  %380 = select i1 %379, i64 0, i64 %378
  store i64 %380, ptr %final_y, align 8
  %381 = load ptr, ptr %1, align 8
  %382 = getelementptr inbounds nuw %"main::Byte_World", ptr %381, i32 0, i32 0
  %383 = load i64, ptr %382, align 8
  %384 = load i64, ptr %final_x, align 8
  %385 = sub i64 %383, %384
  %386 = load i64, ptr %width, align 8
  %387 = add i64 %386, 4
  %388 = icmp slt i64 %385, %387
  %389 = select i1 %388, i64 %385, i64 %387
  store i64 %389, ptr %final_w, align 8
  %390 = load ptr, ptr %1, align 8
  %391 = getelementptr inbounds nuw %"main::Byte_World", ptr %390, i32 0, i32 0
  %392 = load i64, ptr %391, align 8
  %393 = load i64, ptr %final_y, align 8
  %394 = sub i64 %392, %393
  %395 = load i64, ptr %height, align 8
  %396 = add i64 %395, 4
  %397 = icmp slt i64 %394, %396
  %398 = select i1 %397, i64 %394, i64 %396
  store i64 %398, ptr %final_h, align 8
  call void @llvm.memset.inline.p0.i64(ptr %18, i8 0, i64 32, i1 false)
  store %"main::Detected_Blob" zeroinitializer, ptr %18, align 8
  call void @llvm.memset.inline.p0.i64(ptr %19, i8 0, i64 16, i1 false)
  store %"raylib::Rectangle" zeroinitializer, ptr %19, align 4
  %399 = load i64, ptr %final_x, align 8
  %400 = sitofp i64 %399 to float
  %401 = getelementptr inbounds nuw %"raylib::Rectangle", ptr %19, i32 0, i32 0
  store float %400, ptr %401, align 4
  %402 = load i64, ptr %final_y, align 8
  %403 = sitofp i64 %402 to float
  %404 = getelementptr inbounds nuw %"raylib::Rectangle", ptr %19, i32 0, i32 1
  store float %403, ptr %404, align 4
  %405 = load i64, ptr %final_w, align 8
  %406 = sitofp i64 %405 to float
  %407 = getelementptr inbounds nuw %"raylib::Rectangle", ptr %19, i32 0, i32 2
  store float %406, ptr %407, align 4
  %408 = load i64, ptr %final_h, align 8
  %409 = sitofp i64 %408 to float
  %410 = getelementptr inbounds nuw %"raylib::Rectangle", ptr %19, i32 0, i32 3
  store float %409, ptr %410, align 4
  %411 = load %"raylib::Rectangle", ptr %19, align 4
  %412 = getelementptr inbounds nuw %"main::Detected_Blob", ptr %18, i32 0, i32 0
  store %"raylib::Rectangle" %411, ptr %412, align 4
  %413 = load float, ptr %total_alpha, align 4
  %414 = load i64, ptr %count, align 8
  %415 = sitofp i64 %414 to float
  %416 = fdiv float %413, %415
  %417 = getelementptr inbounds nuw %"main::Detected_Blob", ptr %18, i32 0, i32 1
  store float %416, ptr %417, align 4
  %418 = load i64, ptr %count, align 8
  %419 = getelementptr inbounds nuw %"main::Detected_Blob", ptr %18, i32 0, i32 3
  store i64 %418, ptr %419, align 8
  %420 = load %"main::Detected_Blob", ptr %18, align 8
  %421 = load %"runtime::Source_Code_Location", ptr @"scl$[detect_active_regions7475]", align 8
  store i64 0, ptr %20, align 8
  %422 = call i8 @"runtime::append_elem:proc(array:^[dynamic]main::Detected_Blob,arg:main::Detected_Blob,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr @"main::detected_blobs", ptr %18, ptr @"scl$[detect_active_regions7475]", ptr %20, ptr %__.context_ptr)
  %423 = load i64, ptr %20, align 8
  %424 = load { i64, i8 }, ptr %21, align 8
  br label %if.done41

if.done41:                                        ; preds = %if.then40, %cmp.and39, %cmp.and38, %cmp.and37, %cmp.and36, %for.done
  br label %if.done42

if.done42:                                        ; preds = %if.done41, %cmp.and, %for.body3
  br label %for.post

for.post:                                         ; preds = %if.done42
  %425 = load i64, ptr %x, align 8
  %426 = add i64 %425, 1
  store i64 %426, ptr %x, align 8
  br label %for.loop2

for.done43:                                       ; preds = %for.loop2
  br label %for.post44

for.post44:                                       ; preds = %for.done43
  %427 = load i64, ptr %y, align 8
  %428 = add i64 %427, 1
  store i64 %428, ptr %y, align 8
  br label %for.loop

for.done45:                                       ; preds = %for.loop
  br label %defer

defer:                                            ; preds = %for.done45
  %429 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %stack, align 8
  %430 = load %"runtime::Source_Code_Location", ptr @"scl$[detect_active_regions5099]", align 8
  %431 = call i8 @"runtime::delete_dynamic_array:proc(array:[dynamic]int,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"(ptr %stack, ptr @"scl$[detect_active_regions5099]", ptr %__.context_ptr)
  br label %defer46

defer46:                                          ; preds = %defer
  %432 = load { ptr, i64 }, ptr %visited, align 8
  %433 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 0
  %434 = load %"runtime::Allocator", ptr %433, align 8
  %435 = load %"runtime::Source_Code_Location", ptr @"scl$[detect_active_regions5012]", align 8
  store %"runtime::Allocator" %434, ptr %22, align 8
  %436 = load { i64, i64 }, ptr %22, align 8
  %437 = call i8 @"runtime::delete_slice:proc(array:[]bool,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"({ ptr, i64 } %432, { i64, i64 } %436, ptr @"scl$[detect_active_regions5012]", ptr %__.context_ptr)
  ret void
}

define internal { i64, i64 } @"bufio::writer_to_stream"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %s = alloca %"io::Stream", align 8
  %2 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  call void @llvm.memset.inline.p0.i64(ptr %s, i8 0, i64 16, i1 false)
  %3 = getelementptr inbounds nuw %"io::Stream", ptr %s, i32 0, i32 1
  store ptr %0, ptr %3, align 8
  %4 = getelementptr inbounds nuw %"io::Stream", ptr %s, i32 0, i32 0
  store ptr @"bufio::_writer_proc", ptr %4, align 8
  %5 = load %"io::Stream", ptr %s, align 8
  store %"io::Stream" %5, ptr %s, align 8
  store %"io::Stream" %5, ptr %2, align 8
  %6 = load { i64, i64 }, ptr %2, align 8
  ret { i64, i64 } %6
}

define internal void @"runtime::type_assertion_check"(i8 %0, %..string %1, i32 %2, i32 %3, i64 %4, i64 %5) {
decls:
  %6 = alloca i8, align 1
  %7 = alloca %..string, align 8
  %8 = alloca i32, align 4
  %9 = alloca i32, align 4
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i8 %0, ptr %6, align 1
  store %..string %1, ptr %7, align 8
  store i32 %2, ptr %8, align 4
  store i32 %3, ptr %9, align 4
  store i64 %4, ptr %10, align 8
  store i64 %5, ptr %11, align 8
  %12 = icmp ne i8 %0, 0
  br i1 %12, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  call void @"runtime::type_assertion_check.handle_error-0"(%..string %1, i32 %2, i32 %3, i64 %4, i64 %5)
  unreachable
}

define internal void @"thread::[thread_unix.odin]::_destroy"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  call void @"thread::[thread_unix.odin]::_join"(ptr %0, ptr %__.context_ptr)
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr inbounds nuw %"thread::Thread", ptr %3, i32 0, i32 0
  %5 = getelementptr inbounds nuw %"thread::[thread_unix.odin]::Thread_Os_Specific", ptr %4, i32 0, i32 0
  store i64 0, ptr %5, align 8
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr inbounds nuw %"thread::Thread", ptr %6, i32 0, i32 9
  %8 = load %"runtime::Allocator", ptr %7, align 8
  %9 = load %"runtime::Source_Code_Location", ptr @"scl$[_destroy4942]", align 8
  store %"runtime::Allocator" %8, ptr %2, align 8
  %10 = load { i64, i64 }, ptr %2, align 8
  %11 = call i8 @"runtime::mem_free"(ptr %0, { i64, i64 } %10, ptr @"scl$[_destroy4942]", ptr %__.context_ptr)
  ret void
}

define internal void @"runtime::arena_free_last_memory_block"(ptr %0, ptr %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %free_block = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  br label %if.init

if.init:                                          ; preds = %entry
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr inbounds nuw %"runtime::Arena", ptr %3, i32 0, i32 1
  %5 = load ptr, ptr %4, align 8
  store ptr %5, ptr %free_block, align 8
  %6 = load ptr, ptr %free_block, align 8
  %7 = icmp ne ptr %6, null
  %8 = zext i1 %7 to i8
  %9 = icmp ne i8 %8, 0
  br i1 %9, label %if.then, label %if.done

if.then:                                          ; preds = %if.init
  %10 = load ptr, ptr %2, align 8
  %11 = getelementptr inbounds nuw %"runtime::Arena", ptr %10, i32 0, i32 1
  %12 = load ptr, ptr %free_block, align 8
  %13 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %12, i32 0, i32 0
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %11, align 8
  %15 = load ptr, ptr %2, align 8
  %16 = getelementptr inbounds nuw %"runtime::Arena", ptr %15, i32 0, i32 3
  %17 = load ptr, ptr %free_block, align 8
  %18 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %17, i32 0, i32 4
  %19 = load i64, ptr %18, align 8
  %20 = load i64, ptr %16, align 8
  %21 = sub i64 %20, %19
  store i64 %21, ptr %16, align 8
  %22 = load ptr, ptr %free_block, align 8
  %23 = load %"runtime::Source_Code_Location", ptr %1, align 8
  call void @"runtime::memory_block_dealloc"(ptr %22, ptr %1)
  br label %if.done

if.done:                                          ; preds = %if.then, %if.init
  ret void
}

; Function Attrs: noinline
define internal void @"runtime::print_caller_location"(ptr %0) #4 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %1 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %0, i32 0, i32 0
  %2 = load %..string, ptr %1, align 8
  %3 = call i64 @"runtime::print_string"(%..string %2)
  %4 = call i64 @"runtime::print_byte"(i8 40)
  %5 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %0, i32 0, i32 1
  %6 = load i32, ptr %5, align 4
  %7 = sext i32 %6 to i64
  call void @"runtime::print_u64"(i64 %7)
  %8 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %0, i32 0, i32 2
  %9 = load i32, ptr %8, align 4
  %10 = icmp ne i32 %9, 0
  %11 = zext i1 %10 to i8
  %12 = icmp ne i8 %11, 0
  br i1 %12, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %13 = call i64 @"runtime::print_byte"(i8 58)
  %14 = getelementptr inbounds nuw %"runtime::Source_Code_Location", ptr %0, i32 0, i32 2
  %15 = load i32, ptr %14, align 4
  %16 = sext i32 %15 to i64
  call void @"runtime::print_u64"(i64 %16)
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %17 = call i64 @"runtime::print_byte"(i8 41)
  ret void
}

define internal i32 @"strings::[builder.odin]::_builder_stream_proc"(ptr %0, i64 %1, { ptr, i64 } %2, i64 %3, i64 %4, ptr noalias nonnull %5, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %6 = alloca ptr, align 8
  %7 = alloca i64, align 8
  %8 = alloca { ptr, i64 }, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  %b = alloca ptr, align 8
  %11 = alloca i64, align 8
  %12 = alloca { i64, i32 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %6, align 8
  store i64 %1, ptr %7, align 8
  store { ptr, i64 } %2, ptr %8, align 8
  store i64 %3, ptr %9, align 8
  store i64 %4, ptr %10, align 8
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  store ptr %0, ptr %b, align 8
  switch i64 %1, label %switch.done [
    i64 4, label %switch.case.body
    i64 7, label %switch.case.body1
    i64 8, label %switch.case.body2
    i64 9, label %switch.case.body3
  ]

switch.case.body:                                 ; preds = %entry
  %13 = load ptr, ptr %b, align 8
  %14 = load %"runtime::Source_Code_Location", ptr @"scl$[_builder_stream_proc5172]", align 8
  %15 = call i64 @"strings::write_bytes"(ptr %13, { ptr, i64 } %2, ptr @"scl$[_builder_stream_proc5172]", ptr %__.context_ptr)
  store i64 %15, ptr %n, align 8
  %16 = load i64, ptr %n, align 8
  %17 = extractvalue { ptr, i64 } %2, 1
  %18 = icmp slt i64 %16, %17
  %19 = zext i1 %18 to i8
  %20 = icmp ne i8 %19, 0
  br i1 %20, label %if.then, label %if.done

if.then:                                          ; preds = %switch.case.body
  store i32 1, ptr %err, align 4
  br label %if.done

if.done:                                          ; preds = %if.then, %switch.case.body
  %21 = load i64, ptr %n, align 8
  %22 = load i32, ptr %err, align 4
  store i64 %21, ptr %n, align 8
  store i32 %22, ptr %err, align 4
  store i64 %21, ptr %5, align 8
  ret i32 %22

switch.case.body1:                                ; preds = %entry
  %23 = load ptr, ptr %b, align 8
  %24 = getelementptr inbounds nuw %"strings::Builder", ptr %23, i32 0, i32 0
  %25 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %24, align 8
  %26 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %24, i32 0, i32 1
  %27 = load i64, ptr %26, align 8
  store i64 %27, ptr %n, align 8
  %28 = load i64, ptr %n, align 8
  %29 = load i32, ptr %err, align 4
  store i64 %28, ptr %n, align 8
  store i32 %29, ptr %err, align 4
  store i64 %28, ptr %5, align 8
  ret i32 %29

switch.case.body2:                                ; preds = %entry
  %30 = load ptr, ptr %b, align 8
  call void @"strings::builder_destroy"(ptr %30, ptr %__.context_ptr)
  %31 = load i64, ptr %n, align 8
  %32 = load i32, ptr %err, align 4
  store i64 %31, ptr %n, align 8
  store i32 %32, ptr %err, align 4
  store i64 %31, ptr %5, align 8
  ret i32 %32

switch.case.body3:                                ; preds = %entry
  store i64 0, ptr %11, align 8
  %33 = call i32 @"io::query_utility"(i64 912, ptr %11)
  %34 = load i64, ptr %11, align 8
  %35 = load { i64, i32 }, ptr %12, align 8
  store i64 %34, ptr %n, align 8
  store i32 %33, ptr %err, align 4
  store i64 %34, ptr %5, align 8
  ret i32 %33

switch.done:                                      ; preds = %entry
  store i64 0, ptr %n, align 8
  store i32 -1, ptr %err, align 4
  store i64 0, ptr %5, align 8
  ret i32 -1
}

define internal { i64, i64 } @"bufio::writer_to_writer"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %s = alloca %"io::Stream", align 8
  %2 = alloca %"io::Stream", align 16
  %3 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  call void @llvm.memset.inline.p0.i64(ptr %s, i8 0, i64 16, i1 false)
  %4 = call { i64, i64 } @"bufio::writer_to_stream"(ptr %0, ptr %__.context_ptr)
  store { i64, i64 } %4, ptr %2, align 8
  %5 = load %"io::Stream", ptr %2, align 8
  store %"io::Stream" %5, ptr %s, align 8
  store %"io::Stream" %5, ptr %3, align 8
  %6 = load { i64, i64 }, ptr %3, align 8
  ret { i64, i64 } %6
}

define internal i32 @"bufio::_writer_proc"(ptr %0, i64 %1, { ptr, i64 } %2, i64 %3, i64 %4, ptr noalias nonnull %5, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %6 = alloca ptr, align 8
  %7 = alloca i64, align 8
  %8 = alloca { ptr, i64 }, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  %b = alloca ptr, align 8
  %n_int = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca { i64, i32 }, align 8
  %13 = alloca i64, align 8
  %14 = alloca { i64, i32 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %6, align 8
  store i64 %1, ptr %7, align 8
  store { ptr, i64 } %2, ptr %8, align 8
  store i64 %3, ptr %9, align 8
  store i64 %4, ptr %10, align 8
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  store ptr %0, ptr %b, align 8
  switch i64 %1, label %switch.done [
    i64 1, label %switch.case.body
    i64 4, label %switch.case.body1
    i64 8, label %switch.case.body2
    i64 9, label %switch.case.body3
  ]

switch.case.body:                                 ; preds = %entry
  %15 = load ptr, ptr %b, align 8
  %16 = call i32 @"bufio::writer_flush"(ptr %15, ptr %__.context_ptr)
  store i32 %16, ptr %err, align 4
  %17 = load i64, ptr %n, align 8
  %18 = load i32, ptr %err, align 4
  store i64 %17, ptr %n, align 8
  store i32 %18, ptr %err, align 4
  store i64 %17, ptr %5, align 8
  ret i32 %18

switch.case.body1:                                ; preds = %entry
  store i64 0, ptr %n_int, align 8
  %19 = load ptr, ptr %b, align 8
  store i64 0, ptr %11, align 8
  %20 = call i32 @"bufio::writer_write"(ptr %19, { ptr, i64 } %2, ptr %11, ptr %__.context_ptr)
  %21 = load i64, ptr %11, align 8
  %22 = load { i64, i32 }, ptr %12, align 8
  store i64 %21, ptr %n_int, align 8
  store i32 %20, ptr %err, align 4
  %23 = load i64, ptr %n_int, align 8
  store i64 %23, ptr %n, align 8
  %24 = load i64, ptr %n, align 8
  %25 = load i32, ptr %err, align 4
  store i64 %24, ptr %n, align 8
  store i32 %25, ptr %err, align 4
  store i64 %24, ptr %5, align 8
  ret i32 %25

switch.case.body2:                                ; preds = %entry
  %26 = load ptr, ptr %b, align 8
  call void @"bufio::writer_destroy"(ptr %26, ptr %__.context_ptr)
  %27 = load i64, ptr %n, align 8
  %28 = load i32, ptr %err, align 4
  store i64 %27, ptr %n, align 8
  store i32 %28, ptr %err, align 4
  store i64 %27, ptr %5, align 8
  ret i32 %28

switch.case.body3:                                ; preds = %entry
  store i64 0, ptr %13, align 8
  %29 = call i32 @"io::query_utility"(i64 786, ptr %13)
  %30 = load i64, ptr %13, align 8
  %31 = load { i64, i32 }, ptr %14, align 8
  store i64 %30, ptr %n, align 8
  store i32 %29, ptr %err, align 4
  store i64 %30, ptr %5, align 8
  ret i32 %29

switch.done:                                      ; preds = %entry
  store i64 0, ptr %n, align 8
  store i32 -1, ptr %err, align 4
  store i64 0, ptr %5, align 8
  ret i32 -1
}

; Function Attrs: alwaysinline
define internal i64 @"runtime::map_cell_index_dynamic"(i64 %0, ptr noalias %1, i64 %2) #3 {
decls:
  %3 = alloca i64, align 8
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  %elements_per_cell = alloca i64, align 8
  %size_of_cell = alloca i64, align 8
  %cell_index = alloca i64, align 8
  %data_index = alloca i64, align 8
  %size_of_type = alloca i64, align 8
  %cell_index2 = alloca i64, align 8
  %data_index3 = alloca i64, align 8
  %size_of_type4 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %3, align 8
  store ptr %1, ptr %4, align 8
  store i64 %2, ptr %5, align 8
  %6 = load ptr, ptr %4, align 8
  %7 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %6, i32 0, i32 3
  %8 = load i64, ptr %7, align 8
  store i64 %8, ptr %elements_per_cell, align 8
  %9 = load ptr, ptr %4, align 8
  %10 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %9, i32 0, i32 2
  %11 = load i64, ptr %10, align 8
  store i64 %11, ptr %size_of_cell, align 8
  %12 = load i64, ptr %elements_per_cell, align 8
  switch i64 %12, label %switch.default.body [
    i64 1, label %switch.case.body
    i64 2, label %switch.case.body1
  ]

switch.case.body:                                 ; preds = %entry
  %13 = load i64, ptr %size_of_cell, align 8
  %14 = mul i64 %2, %13
  %15 = add i64 %0, %14
  ret i64 %15

switch.case.body1:                                ; preds = %entry
  %16 = lshr i64 %2, 1
  %17 = select i1 true, i64 %16, i64 0
  store i64 %17, ptr %cell_index, align 8
  %18 = and i64 %2, 1
  store i64 %18, ptr %data_index, align 8
  %19 = load ptr, ptr %4, align 8
  %20 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %19, i32 0, i32 0
  %21 = load i64, ptr %20, align 8
  store i64 %21, ptr %size_of_type, align 8
  %22 = load i64, ptr %cell_index, align 8
  %23 = load i64, ptr %size_of_cell, align 8
  %24 = mul i64 %22, %23
  %25 = add i64 %0, %24
  %26 = load i64, ptr %data_index, align 8
  %27 = load i64, ptr %size_of_type, align 8
  %28 = mul i64 %26, %27
  %29 = add i64 %25, %28
  ret i64 %29

switch.default.body:                              ; preds = %entry
  %30 = load i64, ptr %elements_per_cell, align 8
  %31 = icmp ne i64 %30, 0
  br i1 %31, label %div.safe, label %div.edge

div.safe:                                         ; preds = %switch.default.body
  %32 = udiv i64 %2, %30
  br label %div.done

div.edge:                                         ; preds = %switch.default.body
  call void @llvm.trap()
  unreachable

div.done:                                         ; preds = %div.safe
  store i64 %32, ptr %cell_index2, align 8
  %33 = load i64, ptr %elements_per_cell, align 8
  %34 = icmp ne i64 %33, 0
  br i1 %34, label %mod.safe, label %mod.edge

mod.safe:                                         ; preds = %div.done
  %35 = urem i64 %2, %33
  br label %mod.done

mod.edge:                                         ; preds = %div.done
  call void @llvm.trap()
  unreachable

mod.done:                                         ; preds = %mod.safe
  store i64 %35, ptr %data_index3, align 8
  %36 = load ptr, ptr %4, align 8
  %37 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %36, i32 0, i32 0
  %38 = load i64, ptr %37, align 8
  store i64 %38, ptr %size_of_type4, align 8
  %39 = load i64, ptr %cell_index2, align 8
  %40 = load i64, ptr %size_of_cell, align 8
  %41 = mul i64 %39, %40
  %42 = add i64 %0, %41
  %43 = load i64, ptr %data_index3, align 8
  %44 = load i64, ptr %size_of_type4, align 8
  %45 = mul i64 %43, %44
  %46 = add i64 %42, %45
  ret i64 %46

switch.done:                                      ; No predecessors!
  unreachable
}

define internal void @"runtime::arena_free_all"(ptr %0, ptr %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.body, %entry
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr inbounds nuw %"runtime::Arena", ptr %3, i32 0, i32 1
  %5 = load ptr, ptr %4, align 8
  %6 = icmp ne ptr %5, null
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %cmp.and, label %for.done

cmp.and:                                          ; preds = %for.loop
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr inbounds nuw %"runtime::Arena", ptr %9, i32 0, i32 1
  %11 = load ptr, ptr %10, align 8
  %12 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %11, i32 0, i32 0
  %13 = load ptr, ptr %12, align 8
  %14 = icmp ne ptr %13, null
  %15 = zext i1 %14 to i8
  %16 = icmp ne i8 %15, 0
  br i1 %16, label %for.body, label %for.done

for.body:                                         ; preds = %cmp.and
  %17 = load %"runtime::Source_Code_Location", ptr %1, align 8
  call void @"runtime::arena_free_last_memory_block"(ptr %0, ptr %1, ptr %__.context_ptr)
  br label %for.loop

for.done:                                         ; preds = %cmp.and, %for.loop
  %18 = load ptr, ptr %2, align 8
  %19 = getelementptr inbounds nuw %"runtime::Arena", ptr %18, i32 0, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = icmp ne ptr %20, null
  %22 = zext i1 %21 to i8
  %23 = icmp ne i8 %22, 0
  br i1 %23, label %if.then, label %if.done

if.then:                                          ; preds = %for.done
  %24 = load ptr, ptr %2, align 8
  %25 = getelementptr inbounds nuw %"runtime::Arena", ptr %24, i32 0, i32 1
  %26 = load ptr, ptr %25, align 8
  %27 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %26, i32 0, i32 2
  %28 = load ptr, ptr %27, align 8
  %29 = load ptr, ptr %2, align 8
  %30 = getelementptr inbounds nuw %"runtime::Arena", ptr %29, i32 0, i32 1
  %31 = load ptr, ptr %30, align 8
  %32 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %31, i32 0, i32 3
  %33 = load i64, ptr %32, align 8
  call void @llvm.memset.p0.i64(ptr %28, i8 0, i64 %33, i1 false)
  %34 = load ptr, ptr %2, align 8
  %35 = getelementptr inbounds nuw %"runtime::Arena", ptr %34, i32 0, i32 1
  %36 = load ptr, ptr %35, align 8
  %37 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %36, i32 0, i32 3
  store i64 0, ptr %37, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %for.done
  %38 = load ptr, ptr %2, align 8
  %39 = getelementptr inbounds nuw %"runtime::Arena", ptr %38, i32 0, i32 2
  store i64 0, ptr %39, align 8
  ret void
}

; Function Attrs: noinline
define internal i8 @"runtime::_mem_resize"(ptr %0, i64 %1, i64 %2, i64 %3, { i64, i64 } %4, i8 %5, ptr %6, ptr noalias nonnull %7, ptr noalias nonnull "captures"="none" %__.context_ptr) #4 {
decls:
  %8 = alloca ptr, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca %"runtime::Allocator", align 16
  %13 = alloca i8, align 1
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %14 = alloca { ptr, i64 }, align 8
  %15 = alloca { { ptr, i64 }, i8 }, align 8
  %16 = alloca { ptr, i64 }, align 8
  %17 = alloca { { ptr, i64 }, i8 }, align 8
  %18 = alloca { ptr, i64 }, align 8
  %19 = alloca { { ptr, i64 }, i8 }, align 8
  %20 = alloca ptr, align 8
  %21 = alloca { ptr, i64 }, align 8
  %22 = alloca { ptr, i64 }, align 8
  %23 = alloca { { ptr, i64 }, i8 }, align 8
  %24 = alloca { ptr, i64 }, align 8
  %25 = alloca { { ptr, i64 }, i8 }, align 8
  %26 = alloca { ptr, i64 }, align 8
  %27 = alloca { { ptr, i64 }, i8 }, align 8
  %28 = alloca { ptr, i64 }, align 8
  %29 = alloca { { ptr, i64 }, i8 }, align 8
  %30 = alloca ptr, align 8
  %31 = alloca { ptr, i64 }, align 8
  %32 = alloca { ptr, i64 }, align 8
  %33 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %8, align 8
  store i64 %1, ptr %9, align 8
  store i64 %2, ptr %10, align 8
  store i64 %3, ptr %11, align 8
  store { i64, i64 } %4, ptr %12, align 8
  %34 = load %"runtime::Allocator", ptr %12, align 8
  store i8 %5, ptr %13, align 1
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %35 = call i8 @"runtime::is_power_of_two_int"(i64 %3)
  %36 = load %"runtime::Source_Code_Location", ptr %6, align 8
  call void @"runtime::assert"(i8 %35, %..string { ptr @"csbs$byte_world$1fb", i64 32 }, ptr %6, ptr %__.context_ptr)
  %37 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 0
  %38 = load ptr, ptr %37, align 8
  %39 = icmp eq ptr %38, null
  %40 = zext i1 %39 to i8
  %41 = icmp ne i8 %40, 0
  br i1 %41, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store { ptr, i64 } zeroinitializer, ptr %data, align 8
  store i8 0, ptr %err, align 1
  store { ptr, i64 } zeroinitializer, ptr %7, align 8
  ret i8 0

if.done:                                          ; preds = %entry
  %42 = icmp eq i64 %2, 0
  %43 = zext i1 %42 to i8
  %44 = icmp ne i8 %43, 0
  br i1 %44, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.done
  %45 = icmp ne ptr %0, null
  %46 = zext i1 %45 to i8
  %47 = icmp ne i8 %46, 0
  br i1 %47, label %if.then2, label %if.done3

if.then2:                                         ; preds = %if.then1
  %48 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 0
  %49 = load ptr, ptr %48, align 8
  %50 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %51 = load ptr, ptr %50, align 8
  %52 = load %"runtime::Source_Code_Location", ptr %6, align 8
  call void @llvm.memset.inline.p0.i64(ptr %14, i8 0, i64 16, i1 false)
  %53 = call i8 %49(ptr %51, i8 1, i64 0, i64 0, ptr %0, i64 %1, ptr %6, ptr %14, ptr %__.context_ptr)
  %54 = load { ptr, i64 }, ptr %14, align 8
  %55 = load { { ptr, i64 }, i8 }, ptr %15, align 8
  store i8 %53, ptr %err, align 1
  %56 = load { ptr, i64 }, ptr %data, align 8
  %57 = load i8, ptr %err, align 1
  store { ptr, i64 } %56, ptr %data, align 8
  store i8 %57, ptr %err, align 1
  store { ptr, i64 } %56, ptr %7, align 8
  ret i8 %57

if.done3:                                         ; preds = %if.then1
  %58 = load { ptr, i64 }, ptr %data, align 8
  %59 = load i8, ptr %err, align 1
  store { ptr, i64 } %58, ptr %data, align 8
  store i8 %59, ptr %err, align 1
  store { ptr, i64 } %58, ptr %7, align 8
  ret i8 %59

if.else:                                          ; preds = %if.done
  %60 = icmp eq ptr %0, null
  %61 = zext i1 %60 to i8
  %62 = icmp ne i8 %61, 0
  br i1 %62, label %if.then4, label %if.else8

if.then4:                                         ; preds = %if.else
  %63 = icmp ne i8 %5, 0
  br i1 %63, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.then4
  %64 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 0
  %65 = load ptr, ptr %64, align 8
  %66 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %67 = load ptr, ptr %66, align 8
  %68 = load %"runtime::Source_Code_Location", ptr %6, align 8
  call void @llvm.memset.inline.p0.i64(ptr %16, i8 0, i64 16, i1 false)
  %69 = call i8 %65(ptr %67, i8 0, i64 %2, i64 %3, ptr null, i64 0, ptr %6, ptr %16, ptr %__.context_ptr)
  %70 = load { ptr, i64 }, ptr %16, align 8
  %71 = load { { ptr, i64 }, i8 }, ptr %17, align 8
  store { ptr, i64 } %70, ptr %data, align 8
  store i8 %69, ptr %err, align 1
  store { ptr, i64 } %70, ptr %7, align 8
  ret i8 %69

if.else6:                                         ; preds = %if.then4
  %72 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 0
  %73 = load ptr, ptr %72, align 8
  %74 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %75 = load ptr, ptr %74, align 8
  %76 = load %"runtime::Source_Code_Location", ptr %6, align 8
  call void @llvm.memset.inline.p0.i64(ptr %18, i8 0, i64 16, i1 false)
  %77 = call i8 %73(ptr %75, i8 6, i64 %2, i64 %3, ptr null, i64 0, ptr %6, ptr %18, ptr %__.context_ptr)
  %78 = load { ptr, i64 }, ptr %18, align 8
  %79 = load { { ptr, i64 }, i8 }, ptr %19, align 8
  store { ptr, i64 } %78, ptr %data, align 8
  store i8 %77, ptr %err, align 1
  store { ptr, i64 } %78, ptr %7, align 8
  ret i8 %77

if.done7:                                         ; No predecessors!
  br label %if.done11

if.else8:                                         ; preds = %if.else
  %80 = icmp eq i64 %1, %2
  %81 = zext i1 %80 to i8
  %82 = icmp ne i8 %81, 0
  br i1 %82, label %cmp.and, label %if.done10

cmp.and:                                          ; preds = %if.else8
  %83 = ptrtoint ptr %0 to i64
  %84 = icmp ne i64 %3, 0
  br i1 %84, label %mod.safe, label %mod.edge

mod.safe:                                         ; preds = %cmp.and
  %85 = urem i64 %83, %3
  br label %mod.done

mod.edge:                                         ; preds = %cmp.and
  call void @llvm.trap()
  unreachable

mod.done:                                         ; preds = %mod.safe
  %86 = icmp eq i64 %85, 0
  %87 = zext i1 %86 to i8
  %88 = icmp ne i8 %87, 0
  br i1 %88, label %if.then9, label %if.done10

if.then9:                                         ; preds = %mod.done
  store ptr %0, ptr %20, align 8
  %89 = load ptr, ptr %20, align 8
  call void @"runtime::multi_pointer_slice_expr_error"(%..string { ptr @"csbs$byte_world$214", i64 40 }, i32 200, i32 24, i64 0, i64 %1)
  %90 = getelementptr i8, ptr %89, i64 0
  %91 = sub i64 %1, 0
  %92 = getelementptr inbounds nuw { ptr, i64 }, ptr %21, i32 0, i32 0
  %93 = getelementptr inbounds nuw { ptr, i64 }, ptr %21, i32 0, i32 1
  store ptr %90, ptr %92, align 8
  store i64 %91, ptr %93, align 8
  %94 = load { ptr, i64 }, ptr %21, align 8
  store { ptr, i64 } %94, ptr %data, align 8
  %95 = load { ptr, i64 }, ptr %data, align 8
  %96 = load i8, ptr %err, align 1
  store { ptr, i64 } %95, ptr %data, align 8
  store i8 %96, ptr %err, align 1
  store { ptr, i64 } %95, ptr %7, align 8
  ret i8 %96

if.done10:                                        ; preds = %mod.done, %if.else8
  br label %if.done11

if.done11:                                        ; preds = %if.done10, %if.done7
  br label %if.done12

if.done12:                                        ; preds = %if.done11
  %97 = icmp ne i8 %5, 0
  br i1 %97, label %if.then13, label %if.else14

if.then13:                                        ; preds = %if.done12
  %98 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 0
  %99 = load ptr, ptr %98, align 8
  %100 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %101 = load ptr, ptr %100, align 8
  %102 = load %"runtime::Source_Code_Location", ptr %6, align 8
  call void @llvm.memset.inline.p0.i64(ptr %22, i8 0, i64 16, i1 false)
  %103 = call i8 %99(ptr %101, i8 3, i64 %2, i64 %3, ptr %0, i64 %1, ptr %6, ptr %22, ptr %__.context_ptr)
  %104 = load { ptr, i64 }, ptr %22, align 8
  %105 = load { { ptr, i64 }, i8 }, ptr %23, align 8
  store { ptr, i64 } %104, ptr %data, align 8
  store i8 %103, ptr %err, align 1
  br label %if.done15

if.else14:                                        ; preds = %if.done12
  %106 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 0
  %107 = load ptr, ptr %106, align 8
  %108 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %109 = load ptr, ptr %108, align 8
  %110 = load %"runtime::Source_Code_Location", ptr %6, align 8
  call void @llvm.memset.inline.p0.i64(ptr %24, i8 0, i64 16, i1 false)
  %111 = call i8 %107(ptr %109, i8 7, i64 %2, i64 %3, ptr %0, i64 %1, ptr %6, ptr %24, ptr %__.context_ptr)
  %112 = load { ptr, i64 }, ptr %24, align 8
  %113 = load { { ptr, i64 }, i8 }, ptr %25, align 8
  store { ptr, i64 } %112, ptr %data, align 8
  store i8 %111, ptr %err, align 1
  br label %if.done15

if.done15:                                        ; preds = %if.else14, %if.then13
  %114 = load i8, ptr %err, align 1
  %115 = icmp eq i8 %114, 4
  %116 = zext i1 %115 to i8
  %117 = icmp ne i8 %116, 0
  br i1 %117, label %if.then16, label %if.done22

if.then16:                                        ; preds = %if.done15
  %118 = icmp ne i8 %5, 0
  br i1 %118, label %if.then17, label %if.else18

if.then17:                                        ; preds = %if.then16
  %119 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 0
  %120 = load ptr, ptr %119, align 8
  %121 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %122 = load ptr, ptr %121, align 8
  %123 = load %"runtime::Source_Code_Location", ptr %6, align 8
  call void @llvm.memset.inline.p0.i64(ptr %26, i8 0, i64 16, i1 false)
  %124 = call i8 %120(ptr %122, i8 0, i64 %2, i64 %3, ptr null, i64 0, ptr %6, ptr %26, ptr %__.context_ptr)
  %125 = load { ptr, i64 }, ptr %26, align 8
  %126 = load { { ptr, i64 }, i8 }, ptr %27, align 8
  store { ptr, i64 } %125, ptr %data, align 8
  store i8 %124, ptr %err, align 1
  br label %if.done19

if.else18:                                        ; preds = %if.then16
  %127 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 0
  %128 = load ptr, ptr %127, align 8
  %129 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %130 = load ptr, ptr %129, align 8
  %131 = load %"runtime::Source_Code_Location", ptr %6, align 8
  call void @llvm.memset.inline.p0.i64(ptr %28, i8 0, i64 16, i1 false)
  %132 = call i8 %128(ptr %130, i8 6, i64 %2, i64 %3, ptr null, i64 0, ptr %6, ptr %28, ptr %__.context_ptr)
  %133 = load { ptr, i64 }, ptr %28, align 8
  %134 = load { { ptr, i64 }, i8 }, ptr %29, align 8
  store { ptr, i64 } %133, ptr %data, align 8
  store i8 %132, ptr %err, align 1
  br label %if.done19

if.done19:                                        ; preds = %if.else18, %if.then17
  %135 = load i8, ptr %err, align 1
  %136 = icmp ne i8 %135, 0
  %137 = zext i1 %136 to i8
  %138 = icmp ne i8 %137, 0
  br i1 %138, label %if.then20, label %if.done21

if.then20:                                        ; preds = %if.done19
  %139 = load { ptr, i64 }, ptr %data, align 8
  %140 = load i8, ptr %err, align 1
  store { ptr, i64 } %139, ptr %data, align 8
  store i8 %140, ptr %err, align 1
  store { ptr, i64 } %139, ptr %7, align 8
  ret i8 %140

if.done21:                                        ; preds = %if.done19
  %141 = load { ptr, i64 }, ptr %data, align 8
  store ptr %0, ptr %30, align 8
  %142 = load ptr, ptr %30, align 8
  call void @"runtime::multi_pointer_slice_expr_error"(%..string { ptr @"csbs$byte_world$214", i64 40 }, i32 218, i32 28, i64 0, i64 %1)
  %143 = getelementptr i8, ptr %142, i64 0
  %144 = sub i64 %1, 0
  %145 = getelementptr inbounds nuw { ptr, i64 }, ptr %31, i32 0, i32 0
  %146 = getelementptr inbounds nuw { ptr, i64 }, ptr %31, i32 0, i32 1
  store ptr %143, ptr %145, align 8
  store i64 %144, ptr %146, align 8
  %147 = load { ptr, i64 }, ptr %31, align 8
  %148 = call i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]u8,src:[]u8)->(:int)"({ ptr, i64 } %141, { ptr, i64 } %147)
  %149 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 0
  %150 = load ptr, ptr %149, align 8
  %151 = getelementptr inbounds nuw %"runtime::Allocator", ptr %12, i32 0, i32 1
  %152 = load ptr, ptr %151, align 8
  %153 = load %"runtime::Source_Code_Location", ptr %6, align 8
  call void @llvm.memset.inline.p0.i64(ptr %32, i8 0, i64 16, i1 false)
  %154 = call i8 %150(ptr %152, i8 1, i64 0, i64 0, ptr %0, i64 %1, ptr %6, ptr %32, ptr %__.context_ptr)
  %155 = load { ptr, i64 }, ptr %32, align 8
  %156 = load { { ptr, i64 }, i8 }, ptr %33, align 8
  store i8 %154, ptr %err, align 1
  br label %if.done22

if.done22:                                        ; preds = %if.done21, %if.done15
  %157 = load { ptr, i64 }, ptr %data, align 8
  %158 = load i8, ptr %err, align 1
  store { ptr, i64 } %157, ptr %data, align 8
  store i8 %158, ptr %err, align 1
  store { ptr, i64 } %157, ptr %7, align 8
  ret i8 %158
}

define internal i64 @"os::processor_core_count"(ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %0 = call i64 @"os::[os_linux.odin]::_processor_core_count"(ptr %__.context_ptr)
  ret i64 %0
}

define internal void @"runtime::type_assertion_check2"(i8 %0, %..string %1, i32 %2, i32 %3, i64 %4, i64 %5, ptr %6) {
decls:
  %7 = alloca i8, align 1
  %8 = alloca %..string, align 8
  %9 = alloca i32, align 4
  %10 = alloca i32, align 4
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i8 %0, ptr %7, align 1
  store %..string %1, ptr %8, align 8
  store i32 %2, ptr %9, align 4
  store i32 %3, ptr %10, align 4
  store i64 %4, ptr %11, align 8
  store i64 %5, ptr %12, align 8
  store ptr %6, ptr %13, align 8
  %14 = icmp ne i8 %0, 0
  br i1 %14, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  call void @"runtime::type_assertion_check2.handle_error-1"(%..string %1, i32 %2, i32 %3, i64 %4, i64 %5, ptr %6)
  unreachable
}

; Function Attrs: noinline
define internal void @"runtime::print_typeid"(i64 %0) #4 {
decls:
  %1 = alloca i64, align 8
  %ti = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = icmp eq i64 %0, 0
  %3 = zext i1 %2 to i8
  %4 = icmp ne i8 %3, 0
  br i1 %4, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$215", i64 3 })
  br label %if.done

if.else:                                          ; preds = %entry
  %6 = call ptr @"runtime::__type_info_of"(i64 %0)
  store ptr %6, ptr %ti, align 8
  %7 = load ptr, ptr %ti, align 8
  call void @"runtime::print_type"(ptr %7)
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then
  ret void
}

define internal i8 @"reflect::is_unsigned"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca ptr, align 8
  %3 = alloca [2 x i8], align 1
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %4 = icmp eq ptr %0, null
  %5 = zext i1 %4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  %7 = call ptr @"runtime::type_info_base"(ptr %0)
  store ptr %7, ptr %2, align 8
  %8 = load ptr, ptr %2, align 8
  %9 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %8, i32 0, i32 5
  %10 = load { [9 x i64], i64 }, ptr %9, align 8
  %11 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %9, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  switch i64 %12, label %typeswitch.done [
    i64 2, label %typeswitch.body
    i64 4, label %typeswitch.body1
  ]

typeswitch.body:                                  ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %9, i64 2, i1 false)
  %13 = getelementptr inbounds nuw %"runtime::Type_Info_Integer", ptr %3, i32 0, i32 0
  %14 = load i8, ptr %13, align 1
  %15 = icmp eq i8 %14, 0
  %16 = zext i1 %15 to i8
  ret i8 %16

typeswitch.body1:                                 ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %3, ptr %9, i64 1, i1 false)
  ret i8 0

typeswitch.done:                                  ; preds = %if.done
  ret i8 0
}

define internal { i64, i64 } @"strings::to_stream"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %res = alloca %"io::Stream", align 8
  %2 = alloca %"io::Stream", align 8
  %3 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  call void @llvm.memset.inline.p0.i64(ptr %res, i8 0, i64 16, i1 false)
  call void @llvm.memset.inline.p0.i64(ptr %2, i8 0, i64 16, i1 false)
  store %"io::Stream" { ptr @"strings::[builder.odin]::_builder_stream_proc", ptr null }, ptr %2, align 8
  %4 = getelementptr inbounds nuw %"io::Stream", ptr %2, i32 0, i32 1
  store ptr %0, ptr %4, align 8
  %5 = load %"io::Stream", ptr %2, align 8
  store %"io::Stream" %5, ptr %res, align 8
  store %"io::Stream" %5, ptr %3, align 8
  %6 = load { i64, i64 }, ptr %3, align 8
  ret { i64, i64 } %6
}

define internal i64 @"runtime::pop:proc(array:^[dynamic]int,loc:runtime::Source_Code_Location)->(res:int)"(ptr %0, ptr %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %res = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 0, ptr %res, align 8
  %3 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, align 8
  %4 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 1
  %5 = load i64, ptr %4, align 8
  %6 = icmp sgt i64 %5, 0
  %7 = zext i1 %6 to i8
  %8 = load %"runtime::Source_Code_Location", ptr %1, align 8
  call void @"runtime::assert"(i8 %7, %..string { ptr @"csbs$byte_world$216", i64 14 }, ptr %1, ptr %__.context_ptr)
  %9 = load %"runtime::Source_Code_Location", ptr @"scl$[pop6342]", align 8
  call void @"runtime::_pop_type_erased"(ptr %res, ptr %0, i64 8, ptr @"scl$[pop6342]", ptr %__.context_ptr)
  %10 = load i64, ptr %res, align 8
  store i64 %10, ptr %res, align 8
  ret i64 %10
}

define internal void @"runtime::arena_destroy"(ptr %0, ptr %1) {
decls:
  %2 = alloca ptr, align 8
  %free_block = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.body, %entry
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr inbounds nuw %"runtime::Arena", ptr %3, i32 0, i32 1
  %5 = load ptr, ptr %4, align 8
  %6 = icmp ne ptr %5, null
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr inbounds nuw %"runtime::Arena", ptr %9, i32 0, i32 1
  %11 = load ptr, ptr %10, align 8
  store ptr %11, ptr %free_block, align 8
  %12 = load ptr, ptr %2, align 8
  %13 = getelementptr inbounds nuw %"runtime::Arena", ptr %12, i32 0, i32 1
  %14 = load ptr, ptr %free_block, align 8
  %15 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %14, i32 0, i32 0
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %13, align 8
  %17 = load ptr, ptr %2, align 8
  %18 = getelementptr inbounds nuw %"runtime::Arena", ptr %17, i32 0, i32 3
  %19 = load ptr, ptr %free_block, align 8
  %20 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %19, i32 0, i32 4
  %21 = load i64, ptr %20, align 8
  %22 = load i64, ptr %18, align 8
  %23 = sub i64 %22, %21
  store i64 %23, ptr %18, align 8
  %24 = load ptr, ptr %free_block, align 8
  %25 = load %"runtime::Source_Code_Location", ptr %1, align 8
  call void @"runtime::memory_block_dealloc"(ptr %24, ptr %1)
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %26 = load ptr, ptr %2, align 8
  %27 = getelementptr inbounds nuw %"runtime::Arena", ptr %26, i32 0, i32 2
  store i64 0, ptr %27, align 8
  %28 = load ptr, ptr %2, align 8
  %29 = getelementptr inbounds nuw %"runtime::Arena", ptr %28, i32 0, i32 3
  store i64 0, ptr %29, align 8
  ret void
}

define internal { i64, i64 } @"strings::to_writer"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %res = alloca %"io::Stream", align 8
  %2 = alloca %"io::Stream", align 16
  %3 = alloca { i64, i64 }, align 16
  %4 = alloca %"io::Stream", align 8
  %5 = alloca { %"io::Stream", i8 }, align 8
  %6 = alloca { i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  call void @llvm.memset.inline.p0.i64(ptr %res, i8 0, i64 16, i1 false)
  %7 = call { i64, i64 } @"strings::to_stream"(ptr %0, ptr %__.context_ptr)
  store { i64, i64 } %7, ptr %2, align 8
  %8 = load %"io::Stream", ptr %2, align 8
  store %"io::Stream" %8, ptr %3, align 8
  %9 = load { i64, i64 }, ptr %3, align 8
  call void @llvm.memset.inline.p0.i64(ptr %4, i8 0, i64 16, i1 false)
  %10 = call i8 @"io::to_writer"({ i64, i64 } %9, ptr %4, ptr %__.context_ptr)
  %11 = load %"io::Stream", ptr %4, align 8
  %12 = load { %"io::Stream", i8 }, ptr %5, align 8
  store %"io::Stream" %11, ptr %res, align 8
  store %"io::Stream" %11, ptr %6, align 8
  %13 = load { i64, i64 }, ptr %6, align 8
  ret { i64, i64 } %13
}

; Function Attrs: noinline optsize
define internal void @"runtime::print_type"(ptr %0) #5 {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca [72 x i8], align 8
  %3 = alloca { %"runtime::Type_Info_Parameters", i8 }, align 8
  %t = alloca %"runtime::Type_Info_Parameters", align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %t34 = alloca ptr, align 8
  %i = alloca i64, align 8
  %count = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %name = alloca %..string, align 8
  %i45 = alloca i64, align 8
  %t48 = alloca ptr, align 8
  %8 = alloca { ptr, i64 }, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %name75 = alloca %..string, align 8
  %i76 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %variant = alloca ptr, align 8
  %i87 = alloca i64, align 8
  %13 = alloca i64, align 8
  %14 = alloca i64, align 8
  %name94 = alloca %..string, align 8
  %i95 = alloca i64, align 8
  %15 = alloca ptr, align 8
  %16 = alloca [40 x i8], align 8
  %elem = alloca { [9 x i64], i64 }, align 8
  %17 = alloca { ptr, i64 }, align 8
  %18 = alloca i64, align 8
  %19 = alloca i64, align 8
  %name107 = alloca %..string, align 8
  %i108 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %20 = icmp eq ptr %0, null
  %21 = zext i1 %20 to i8
  %22 = icmp ne i8 %21, 0
  br i1 %22, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %23 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$215", i64 3 })
  ret void

if.done:                                          ; preds = %entry
  %24 = load ptr, ptr %1, align 8
  %25 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %24, i32 0, i32 5
  %26 = load { [9 x i64], i64 }, ptr %25, align 8
  %27 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %25, i32 0, i32 1
  %28 = load i64, ptr %27, align 8
  switch i64 %28, label %typeswitch.done114 [
    i64 1, label %typeswitch.body
    i64 2, label %typeswitch.body1
    i64 3, label %typeswitch.body8
    i64 4, label %typeswitch.body9
    i64 5, label %typeswitch.body10
    i64 6, label %typeswitch.body11
    i64 7, label %typeswitch.body12
    i64 8, label %typeswitch.body18
    i64 9, label %typeswitch.body23
    i64 10, label %typeswitch.body24
    i64 11, label %typeswitch.body25
    i64 12, label %typeswitch.body29
    i64 26, label %typeswitch.body30
    i64 13, label %typeswitch.body31
    i64 18, label %typeswitch.body40
    i64 14, label %typeswitch.body54
    i64 15, label %typeswitch.body55
    i64 16, label %typeswitch.body58
    i64 17, label %typeswitch.body59
    i64 22, label %typeswitch.body60
    i64 19, label %typeswitch.body61
    i64 20, label %typeswitch.body80
    i64 21, label %typeswitch.body91
    i64 23, label %typeswitch.body99
    i64 27, label %typeswitch.body104
    i64 24, label %typeswitch.body112
    i64 25, label %typeswitch.body113
  ]

typeswitch.body:                                  ; preds = %if.done
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %25, i64 48, i1 false)
  %29 = getelementptr inbounds nuw %"runtime::Type_Info_Named", ptr %2, i32 0, i32 0
  %30 = load %..string, ptr %29, align 8
  %31 = call i64 @"runtime::print_string"(%..string %30)
  br label %typeswitch.done114

typeswitch.body1:                                 ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 2, i1 false)
  %32 = load ptr, ptr %1, align 8
  %33 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %32, i32 0, i32 4
  %34 = load i64, ptr %33, align 8
  %35 = icmp eq i64 %34, 3143511548502526014
  br i1 %35, label %switch.case.body, label %switch.case.next

switch.case.next:                                 ; preds = %typeswitch.body1
  %36 = icmp eq i64 %34, 4128981603702996129
  br i1 %36, label %switch.case.body3, label %switch.case.next2

switch.case.body:                                 ; preds = %typeswitch.body1
  %37 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$218", i64 3 })
  br label %switch.done

switch.case.next2:                                ; preds = %switch.case.next
  %38 = icmp eq i64 %34, -5248816158460668987
  br i1 %38, label %switch.case.body5, label %switch.case.next4

switch.case.body3:                                ; preds = %switch.case.next
  %39 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$219", i64 4 })
  br label %switch.done

switch.case.next4:                                ; preds = %switch.case.next2
  br label %switch.default.body

switch.case.body5:                                ; preds = %switch.case.next2
  %40 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$21a", i64 7 })
  br label %switch.done

switch.default.body:                              ; preds = %switch.case.next4
  %41 = getelementptr inbounds nuw %"runtime::Type_Info_Integer", ptr %2, i32 0, i32 0
  %42 = load i8, ptr %41, align 1
  %43 = icmp ne i8 %42, 0
  br i1 %43, label %if.then6, label %if.else

if.then6:                                         ; preds = %switch.default.body
  br label %if.done7

if.else:                                          ; preds = %switch.default.body
  br label %if.done7

if.done7:                                         ; preds = %if.else, %if.then6
  %44 = phi i8 [ 105, %if.then6 ], [ 117, %if.else ]
  %45 = call i64 @"runtime::print_byte"(i8 %44)
  %46 = load ptr, ptr %1, align 8
  %47 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %46, i32 0, i32 0
  %48 = load i64, ptr %47, align 8
  %49 = mul i64 8, %48
  call void @"runtime::print_u64"(i64 %49)
  br label %switch.done

switch.done:                                      ; preds = %if.done7, %switch.case.body5, %switch.case.body3, %switch.case.body
  br label %typeswitch.done114

typeswitch.body8:                                 ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 0, i1 false)
  %50 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$21b", i64 4 })
  br label %typeswitch.done114

typeswitch.body9:                                 ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 1, i1 false)
  %51 = call i64 @"runtime::print_byte"(i8 102)
  %52 = load ptr, ptr %1, align 8
  %53 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %52, i32 0, i32 0
  %54 = load i64, ptr %53, align 8
  %55 = mul i64 8, %54
  call void @"runtime::print_u64"(i64 %55)
  br label %typeswitch.done114

typeswitch.body10:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 0, i1 false)
  %56 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$21c", i64 7 })
  %57 = load ptr, ptr %1, align 8
  %58 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %57, i32 0, i32 0
  %59 = load i64, ptr %58, align 8
  %60 = mul i64 8, %59
  call void @"runtime::print_u64"(i64 %60)
  br label %typeswitch.done114

typeswitch.body11:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 0, i1 false)
  %61 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$21d", i64 10 })
  %62 = load ptr, ptr %1, align 8
  %63 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %62, i32 0, i32 0
  %64 = load i64, ptr %63, align 8
  %65 = mul i64 8, %64
  call void @"runtime::print_u64"(i64 %65)
  br label %typeswitch.done114

typeswitch.body12:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 2, i1 false)
  %66 = getelementptr inbounds nuw %"runtime::Type_Info_String", ptr %2, i32 0, i32 0
  %67 = load i8, ptr %66, align 1
  %68 = icmp ne i8 %67, 0
  br i1 %68, label %if.then13, label %if.done14

if.then13:                                        ; preds = %typeswitch.body12
  %69 = call i64 @"runtime::print_byte"(i8 99)
  br label %if.done14

if.done14:                                        ; preds = %if.then13, %typeswitch.body12
  %70 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$21e", i64 6 })
  %71 = getelementptr inbounds nuw %"runtime::Type_Info_String", ptr %2, i32 0, i32 1
  %72 = load i8, ptr %71, align 1
  switch i8 %72, label %switch.done17 [
    i8 0, label %switch.case.body15
    i8 1, label %switch.case.body16
  ]

switch.case.body15:                               ; preds = %if.done14
  br label %switch.done17

switch.case.body16:                               ; preds = %if.done14
  %73 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$21f", i64 2 })
  br label %switch.done17

switch.done17:                                    ; preds = %switch.case.body16, %switch.case.body15, %if.done14
  br label %typeswitch.done114

typeswitch.body18:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 0, i1 false)
  %74 = load ptr, ptr %1, align 8
  %75 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %74, i32 0, i32 4
  %76 = load i64, ptr %75, align 8
  %77 = icmp eq i64 %76, -3661474206510476099
  br i1 %77, label %switch.case.body20, label %switch.case.next19

switch.case.next19:                               ; preds = %typeswitch.body18
  br label %switch.default.body21

switch.case.body20:                               ; preds = %typeswitch.body18
  %78 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$220", i64 4 })
  br label %switch.done22

switch.default.body21:                            ; preds = %switch.case.next19
  %79 = call i64 @"runtime::print_byte"(i8 98)
  %80 = load ptr, ptr %1, align 8
  %81 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %80, i32 0, i32 0
  %82 = load i64, ptr %81, align 8
  %83 = mul i64 8, %82
  call void @"runtime::print_u64"(i64 %83)
  br label %switch.done22

switch.done22:                                    ; preds = %switch.default.body21, %switch.case.body20
  br label %typeswitch.done114

typeswitch.body23:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 0, i1 false)
  %84 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$221", i64 3 })
  br label %typeswitch.done114

typeswitch.body24:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 0, i1 false)
  %85 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$222", i64 6 })
  br label %typeswitch.done114

typeswitch.body25:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 8, i1 false)
  %86 = getelementptr inbounds nuw %"runtime::Type_Info_Pointer", ptr %2, i32 0, i32 0
  %87 = load ptr, ptr %86, align 8
  %88 = icmp eq ptr %87, null
  %89 = zext i1 %88 to i8
  %90 = icmp ne i8 %89, 0
  br i1 %90, label %if.then26, label %if.else27

if.then26:                                        ; preds = %typeswitch.body25
  %91 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$223", i64 6 })
  br label %if.done28

if.else27:                                        ; preds = %typeswitch.body25
  %92 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$224", i64 1 })
  %93 = getelementptr inbounds nuw %"runtime::Type_Info_Pointer", ptr %2, i32 0, i32 0
  %94 = load ptr, ptr %93, align 8
  call void @"runtime::print_type"(ptr %94)
  br label %if.done28

if.done28:                                        ; preds = %if.else27, %if.then26
  br label %typeswitch.done114

typeswitch.body29:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 8, i1 false)
  %95 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$225", i64 3 })
  %96 = getelementptr inbounds nuw %"runtime::Type_Info_Multi_Pointer", ptr %2, i32 0, i32 0
  %97 = load ptr, ptr %96, align 8
  call void @"runtime::print_type"(ptr %97)
  br label %typeswitch.done114

typeswitch.body30:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 8, i1 false)
  %98 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$226", i64 6 })
  %99 = getelementptr inbounds nuw %"runtime::Type_Info_Soa_Pointer", ptr %2, i32 0, i32 0
  %100 = load ptr, ptr %99, align 8
  call void @"runtime::print_type"(ptr %100)
  br label %typeswitch.done114

typeswitch.body31:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 24, i1 false)
  %101 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$227", i64 4 })
  %102 = getelementptr inbounds nuw %"runtime::Type_Info_Procedure", ptr %2, i32 0, i32 0
  %103 = load ptr, ptr %102, align 8
  %104 = icmp eq ptr %103, null
  %105 = zext i1 %104 to i8
  %106 = icmp ne i8 %105, 0
  br i1 %106, label %if.then32, label %if.else33

if.then32:                                        ; preds = %typeswitch.body31
  %107 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$228", i64 2 })
  br label %if.done37

if.else33:                                        ; preds = %typeswitch.body31
  %108 = getelementptr inbounds nuw %"runtime::Type_Info_Procedure", ptr %2, i32 0, i32 0
  %109 = load ptr, ptr %108, align 8
  %110 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %109, i32 0, i32 5
  %111 = load { [9 x i64], i64 }, ptr %110, align 8
  call void @llvm.memset.p0.i64(ptr %3, i8 0, i64 33, i1 false)
  %112 = getelementptr inbounds nuw { %"runtime::Type_Info_Parameters", i8 }, ptr %3, i32 0, i32 0
  %113 = getelementptr inbounds nuw { %"runtime::Type_Info_Parameters", i8 }, ptr %3, i32 0, i32 1
  %114 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %110, i32 0, i32 1
  %115 = load i64, ptr %114, align 8
  %116 = icmp eq i64 %115, 18
  br i1 %116, label %union_cast.ok, label %union_cast.end

union_cast.ok:                                    ; preds = %if.else33
  %117 = load %"runtime::Type_Info_Parameters", ptr %110, align 8
  store %"runtime::Type_Info_Parameters" %117, ptr %112, align 8
  store i8 1, ptr %113, align 1
  br label %union_cast.end

union_cast.end:                                   ; preds = %union_cast.ok, %if.else33
  %118 = getelementptr inbounds nuw { %"runtime::Type_Info_Parameters", i8 }, ptr %3, i32 0, i32 1
  %119 = load i8, ptr %118, align 1
  call void @"runtime::type_assertion_check2"(i8 %119, %..string { ptr @"csbs$byte_world$208", i64 37 }, i32 334, i32 9, i64 -8076902416644092719, i64 -4545763294955837399, ptr %110)
  %120 = getelementptr inbounds nuw { %"runtime::Type_Info_Parameters", i8 }, ptr %3, i32 0, i32 0
  %121 = load %"runtime::Type_Info_Parameters", ptr %120, align 8
  store %"runtime::Type_Info_Parameters" %121, ptr %t, align 8
  %122 = call i64 @"runtime::print_byte"(i8 40)
  %123 = getelementptr inbounds nuw %"runtime::Type_Info_Parameters", ptr %t, i32 0, i32 0
  %124 = load { ptr, i64 }, ptr %123, align 8
  %125 = getelementptr inbounds nuw { ptr, i64 }, ptr %123, i32 0, i32 1
  %126 = load i64, ptr %125, align 8
  store i64 %126, ptr %4, align 8
  store i64 -1, ptr %5, align 8
  br label %for.index.loop

for.index.loop:                                   ; preds = %if.done36, %union_cast.end
  %127 = load i64, ptr %5, align 8
  %128 = add i64 %127, 1
  store i64 %128, ptr %5, align 8
  %129 = load i64, ptr %4, align 8
  %130 = icmp slt i64 %128, %129
  br i1 %130, label %for.index.body, label %for.index.done

for.index.body:                                   ; preds = %for.index.loop
  %131 = load i64, ptr %5, align 8
  %132 = getelementptr inbounds nuw { ptr, i64 }, ptr %123, i32 0, i32 0
  %133 = load ptr, ptr %132, align 8
  %134 = getelementptr ptr, ptr %133, i64 %131
  %135 = load ptr, ptr %134, align 8
  store ptr %135, ptr %t34, align 8
  store i64 %131, ptr %i, align 8
  %136 = load i64, ptr %i, align 8
  %137 = icmp sgt i64 %136, 0
  %138 = zext i1 %137 to i8
  %139 = icmp ne i8 %138, 0
  br i1 %139, label %if.then35, label %if.done36

if.then35:                                        ; preds = %for.index.body
  %140 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$229", i64 2 })
  br label %if.done36

if.done36:                                        ; preds = %if.then35, %for.index.body
  %141 = load ptr, ptr %t34, align 8
  call void @"runtime::print_type"(ptr %141)
  br label %for.index.loop

for.index.done:                                   ; preds = %for.index.loop
  %142 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$22a", i64 1 })
  br label %if.done37

if.done37:                                        ; preds = %for.index.done, %if.then32
  %143 = getelementptr inbounds nuw %"runtime::Type_Info_Procedure", ptr %2, i32 0, i32 1
  %144 = load ptr, ptr %143, align 8
  %145 = icmp ne ptr %144, null
  %146 = zext i1 %145 to i8
  %147 = icmp ne i8 %146, 0
  br i1 %147, label %if.then38, label %if.done39

if.then38:                                        ; preds = %if.done37
  %148 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$22b", i64 4 })
  %149 = getelementptr inbounds nuw %"runtime::Type_Info_Procedure", ptr %2, i32 0, i32 1
  %150 = load ptr, ptr %149, align 8
  call void @"runtime::print_type"(ptr %150)
  br label %if.done39

if.done39:                                        ; preds = %if.then38, %if.done37
  br label %typeswitch.done114

typeswitch.body40:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 32, i1 false)
  %151 = getelementptr inbounds nuw %"runtime::Type_Info_Parameters", ptr %2, i32 0, i32 1
  %152 = load { ptr, i64 }, ptr %151, align 8
  %153 = getelementptr inbounds nuw { ptr, i64 }, ptr %151, i32 0, i32 1
  %154 = load i64, ptr %153, align 8
  store i64 %154, ptr %count, align 8
  %155 = load i64, ptr %count, align 8
  %156 = icmp ne i64 %155, 1
  %157 = zext i1 %156 to i8
  %158 = icmp ne i8 %157, 0
  br i1 %158, label %if.then41, label %if.done42

if.then41:                                        ; preds = %typeswitch.body40
  %159 = call i64 @"runtime::print_byte"(i8 40)
  br label %if.done42

if.done42:                                        ; preds = %if.then41, %typeswitch.body40
  %160 = getelementptr inbounds nuw %"runtime::Type_Info_Parameters", ptr %2, i32 0, i32 1
  %161 = load { ptr, i64 }, ptr %160, align 8
  %162 = getelementptr inbounds nuw { ptr, i64 }, ptr %160, i32 0, i32 1
  %163 = load i64, ptr %162, align 8
  store i64 %163, ptr %6, align 8
  store i64 -1, ptr %7, align 8
  br label %for.index.loop43

for.index.loop43:                                 ; preds = %if.done50, %if.done42
  %164 = load i64, ptr %7, align 8
  %165 = add i64 %164, 1
  store i64 %165, ptr %7, align 8
  %166 = load i64, ptr %6, align 8
  %167 = icmp slt i64 %165, %166
  br i1 %167, label %for.index.body44, label %for.index.done51

for.index.body44:                                 ; preds = %for.index.loop43
  %168 = load i64, ptr %7, align 8
  %169 = getelementptr inbounds nuw { ptr, i64 }, ptr %160, i32 0, i32 0
  %170 = load ptr, ptr %169, align 8
  %171 = getelementptr %..string, ptr %170, i64 %168
  %172 = load %..string, ptr %171, align 8
  store %..string %172, ptr %name, align 8
  store i64 %168, ptr %i45, align 8
  %173 = load i64, ptr %i45, align 8
  %174 = icmp sgt i64 %173, 0
  %175 = zext i1 %174 to i8
  %176 = icmp ne i8 %175, 0
  br i1 %176, label %if.then46, label %if.done47

if.then46:                                        ; preds = %for.index.body44
  %177 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$229", i64 2 })
  br label %if.done47

if.done47:                                        ; preds = %if.then46, %for.index.body44
  %178 = getelementptr inbounds nuw %"runtime::Type_Info_Parameters", ptr %2, i32 0, i32 0
  %179 = load { ptr, i64 }, ptr %178, align 8
  %180 = getelementptr inbounds nuw { ptr, i64 }, ptr %178, i32 0, i32 0
  %181 = load ptr, ptr %180, align 8
  %182 = load i64, ptr %i45, align 8
  %183 = getelementptr inbounds nuw { ptr, i64 }, ptr %178, i32 0, i32 1
  %184 = load i64, ptr %183, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$208", i64 37 }, i32 352, i32 20, i64 %182, i64 %184)
  %185 = getelementptr ptr, ptr %181, i64 %182
  %186 = load ptr, ptr %185, align 8
  store ptr %186, ptr %t48, align 8
  %187 = load %..string, ptr %name, align 8
  %188 = getelementptr inbounds nuw %..string, ptr %name, i32 0, i32 1
  %189 = load i64, ptr %188, align 8
  %190 = icmp sgt i64 %189, 0
  %191 = zext i1 %190 to i8
  %192 = icmp ne i8 %191, 0
  br i1 %192, label %if.then49, label %if.done50

if.then49:                                        ; preds = %if.done47
  %193 = load %..string, ptr %name, align 8
  %194 = call i64 @"runtime::print_string"(%..string %193)
  %195 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$22c", i64 2 })
  br label %if.done50

if.done50:                                        ; preds = %if.then49, %if.done47
  %196 = load ptr, ptr %t48, align 8
  call void @"runtime::print_type"(ptr %196)
  br label %for.index.loop43

for.index.done51:                                 ; preds = %for.index.loop43
  %197 = load i64, ptr %count, align 8
  %198 = icmp ne i64 %197, 1
  %199 = zext i1 %198 to i8
  %200 = icmp ne i8 %199, 0
  br i1 %200, label %if.then52, label %if.done53

if.then52:                                        ; preds = %for.index.done51
  %201 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$22a", i64 1 })
  br label %if.done53

if.done53:                                        ; preds = %if.then52, %for.index.done51
  br label %typeswitch.done114

typeswitch.body54:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 24, i1 false)
  %202 = call i64 @"runtime::print_byte"(i8 91)
  %203 = getelementptr inbounds nuw %"runtime::Type_Info_Array", ptr %2, i32 0, i32 2
  %204 = load i64, ptr %203, align 8
  call void @"runtime::print_u64"(i64 %204)
  %205 = call i64 @"runtime::print_byte"(i8 93)
  %206 = getelementptr inbounds nuw %"runtime::Type_Info_Array", ptr %2, i32 0, i32 0
  %207 = load ptr, ptr %206, align 8
  call void @"runtime::print_type"(ptr %207)
  br label %typeswitch.done114

typeswitch.body55:                                ; preds = %if.done
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %25, i64 56, i1 false)
  %208 = getelementptr inbounds nuw %"runtime::Type_Info_Enumerated_Array", ptr %2, i32 0, i32 6
  %209 = load i8, ptr %208, align 1
  %210 = icmp ne i8 %209, 0
  br i1 %210, label %if.then56, label %if.done57

if.then56:                                        ; preds = %typeswitch.body55
  %211 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$22d", i64 7 })
  br label %if.done57

if.done57:                                        ; preds = %if.then56, %typeswitch.body55
  %212 = call i64 @"runtime::print_byte"(i8 91)
  %213 = getelementptr inbounds nuw %"runtime::Type_Info_Enumerated_Array", ptr %2, i32 0, i32 1
  %214 = load ptr, ptr %213, align 8
  call void @"runtime::print_type"(ptr %214)
  %215 = call i64 @"runtime::print_byte"(i8 93)
  %216 = getelementptr inbounds nuw %"runtime::Type_Info_Enumerated_Array", ptr %2, i32 0, i32 0
  %217 = load ptr, ptr %216, align 8
  call void @"runtime::print_type"(ptr %217)
  br label %typeswitch.done114

typeswitch.body58:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 16, i1 false)
  %218 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$22e", i64 9 })
  %219 = getelementptr inbounds nuw %"runtime::Type_Info_Dynamic_Array", ptr %2, i32 0, i32 0
  %220 = load ptr, ptr %219, align 8
  call void @"runtime::print_type"(ptr %220)
  br label %typeswitch.done114

typeswitch.body59:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 16, i1 false)
  %221 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$22f", i64 2 })
  %222 = getelementptr inbounds nuw %"runtime::Type_Info_Slice", ptr %2, i32 0, i32 0
  %223 = load ptr, ptr %222, align 8
  call void @"runtime::print_type"(ptr %223)
  br label %typeswitch.done114

typeswitch.body60:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 24, i1 false)
  %224 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$230", i64 4 })
  %225 = getelementptr inbounds nuw %"runtime::Type_Info_Map", ptr %2, i32 0, i32 0
  %226 = load ptr, ptr %225, align 8
  call void @"runtime::print_type"(ptr %226)
  %227 = call i64 @"runtime::print_byte"(i8 93)
  %228 = getelementptr inbounds nuw %"runtime::Type_Info_Map", ptr %2, i32 0, i32 1
  %229 = load ptr, ptr %228, align 8
  call void @"runtime::print_type"(ptr %229)
  br label %typeswitch.done114

typeswitch.body61:                                ; preds = %if.done
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %25, i64 72, i1 false)
  %230 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 7
  %231 = load i8, ptr %230, align 1
  switch i8 %231, label %switch.done66 [
    i8 0, label %switch.case.body62
    i8 1, label %switch.case.body63
    i8 2, label %switch.case.body64
    i8 3, label %switch.case.body65
  ]

switch.case.body62:                               ; preds = %typeswitch.body61
  br label %switch.done66

switch.case.body63:                               ; preds = %typeswitch.body61
  %232 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$231", i64 5 })
  %233 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 9
  %234 = load i32, ptr %233, align 4
  %235 = sext i32 %234 to i64
  call void @"runtime::print_u64"(i64 %235)
  %236 = call i64 @"runtime::print_byte"(i8 93)
  %237 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 11
  %238 = load ptr, ptr %237, align 8
  call void @"runtime::print_type"(ptr %238)
  ret void

switch.case.body64:                               ; preds = %typeswitch.body61
  %239 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$232", i64 6 })
  %240 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 11
  %241 = load ptr, ptr %240, align 8
  call void @"runtime::print_type"(ptr %241)
  ret void

switch.case.body65:                               ; preds = %typeswitch.body61
  %242 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$233", i64 13 })
  %243 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 11
  %244 = load ptr, ptr %243, align 8
  call void @"runtime::print_type"(ptr %244)
  ret void

switch.done66:                                    ; preds = %switch.case.body62, %typeswitch.body61
  %245 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$234", i64 7 })
  %246 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 6
  %247 = load i8, ptr %246, align 1
  %248 = and i8 %247, 1
  %249 = icmp ne i8 %248, 0
  %250 = zext i1 %249 to i8
  %251 = icmp ne i8 %250, 0
  br i1 %251, label %if.then67, label %if.done68

if.then67:                                        ; preds = %switch.done66
  %252 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$235", i64 8 })
  br label %if.done68

if.done68:                                        ; preds = %if.then67, %switch.done66
  %253 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 6
  %254 = load i8, ptr %253, align 1
  %255 = and i8 %254, 2
  %256 = icmp ne i8 %255, 0
  %257 = zext i1 %256 to i8
  %258 = icmp ne i8 %257, 0
  br i1 %258, label %if.then69, label %if.done70

if.then69:                                        ; preds = %if.done68
  %259 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$236", i64 11 })
  br label %if.done70

if.done70:                                        ; preds = %if.then69, %if.done68
  %260 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 6
  %261 = load i8, ptr %260, align 1
  %262 = and i8 %261, 8
  %263 = icmp ne i8 %262, 0
  %264 = zext i1 %263 to i8
  %265 = icmp ne i8 %264, 0
  br i1 %265, label %if.then71, label %if.done72

if.then71:                                        ; preds = %if.done70
  %266 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$237", i64 7 })
  %267 = load ptr, ptr %1, align 8
  %268 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %267, i32 0, i32 1
  %269 = load i64, ptr %268, align 8
  call void @"runtime::print_u64"(i64 %269)
  %270 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$238", i64 2 })
  br label %if.done72

if.done72:                                        ; preds = %if.then71, %if.done70
  %271 = call i64 @"runtime::print_byte"(i8 123)
  %272 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 1
  %273 = load ptr, ptr %272, align 8
  %274 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 5
  %275 = load i32, ptr %274, align 4
  %276 = sext i32 %275 to i64
  call void @"runtime::multi_pointer_slice_expr_error"(%..string { ptr @"csbs$byte_world$208", i64 37 }, i32 420, i32 28, i64 0, i64 %276)
  %277 = getelementptr %..string, ptr %273, i64 0
  %278 = sub i64 %276, 0
  %279 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 0
  %280 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 1
  store ptr %277, ptr %279, align 8
  store i64 %278, ptr %280, align 8
  %281 = load { ptr, i64 }, ptr %8, align 8
  %282 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 1
  %283 = load i64, ptr %282, align 8
  store i64 %283, ptr %9, align 8
  store i64 -1, ptr %10, align 8
  br label %for.index.loop73

for.index.loop73:                                 ; preds = %if.done78, %if.done72
  %284 = load i64, ptr %10, align 8
  %285 = add i64 %284, 1
  store i64 %285, ptr %10, align 8
  %286 = load i64, ptr %9, align 8
  %287 = icmp slt i64 %285, %286
  br i1 %287, label %for.index.body74, label %for.index.done79

for.index.body74:                                 ; preds = %for.index.loop73
  %288 = load i64, ptr %10, align 8
  %289 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 0
  %290 = load ptr, ptr %289, align 8
  %291 = getelementptr %..string, ptr %290, i64 %288
  %292 = load %..string, ptr %291, align 8
  store %..string %292, ptr %name75, align 8
  store i64 %288, ptr %i76, align 8
  %293 = load i64, ptr %i76, align 8
  %294 = icmp sgt i64 %293, 0
  %295 = zext i1 %294 to i8
  %296 = icmp ne i8 %295, 0
  br i1 %296, label %if.then77, label %if.done78

if.then77:                                        ; preds = %for.index.body74
  %297 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$229", i64 2 })
  br label %if.done78

if.done78:                                        ; preds = %if.then77, %for.index.body74
  %298 = load %..string, ptr %name75, align 8
  %299 = call i64 @"runtime::print_string"(%..string %298)
  %300 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$22c", i64 2 })
  %301 = getelementptr inbounds nuw %"runtime::Type_Info_Struct", ptr %2, i32 0, i32 0
  %302 = load ptr, ptr %301, align 8
  %303 = load i64, ptr %i76, align 8
  %304 = getelementptr ptr, ptr %302, i64 %303
  %305 = load ptr, ptr %304, align 8
  call void @"runtime::print_type"(ptr %305)
  br label %for.index.loop73

for.index.done79:                                 ; preds = %for.index.loop73
  %306 = call i64 @"runtime::print_byte"(i8 125)
  br label %typeswitch.done114

typeswitch.body80:                                ; preds = %if.done
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %25, i64 48, i1 false)
  %307 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$239", i64 6 })
  %308 = getelementptr inbounds nuw %"runtime::Type_Info_Union", ptr %2, i32 0, i32 4
  %309 = load i8, ptr %308, align 1
  %310 = icmp ne i8 %309, 0
  br i1 %310, label %if.then81, label %if.done82

if.then81:                                        ; preds = %typeswitch.body80
  %311 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$237", i64 7 })
  %312 = load ptr, ptr %1, align 8
  %313 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %312, i32 0, i32 1
  %314 = load i64, ptr %313, align 8
  call void @"runtime::print_u64"(i64 %314)
  %315 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$238", i64 2 })
  br label %if.done82

if.done82:                                        ; preds = %if.then81, %typeswitch.body80
  %316 = getelementptr inbounds nuw %"runtime::Type_Info_Union", ptr %2, i32 0, i32 5
  %317 = load i8, ptr %316, align 1
  %318 = icmp ne i8 %317, 0
  br i1 %318, label %if.then83, label %if.done84

if.then83:                                        ; preds = %if.done82
  %319 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$23a", i64 8 })
  br label %if.done84

if.done84:                                        ; preds = %if.then83, %if.done82
  %320 = call i64 @"runtime::print_byte"(i8 123)
  %321 = getelementptr inbounds nuw %"runtime::Type_Info_Union", ptr %2, i32 0, i32 0
  %322 = load { ptr, i64 }, ptr %321, align 8
  %323 = getelementptr inbounds nuw { ptr, i64 }, ptr %321, i32 0, i32 1
  %324 = load i64, ptr %323, align 8
  store i64 %324, ptr %11, align 8
  store i64 -1, ptr %12, align 8
  br label %for.index.loop85

for.index.loop85:                                 ; preds = %if.done89, %if.done84
  %325 = load i64, ptr %12, align 8
  %326 = add i64 %325, 1
  store i64 %326, ptr %12, align 8
  %327 = load i64, ptr %11, align 8
  %328 = icmp slt i64 %326, %327
  br i1 %328, label %for.index.body86, label %for.index.done90

for.index.body86:                                 ; preds = %for.index.loop85
  %329 = load i64, ptr %12, align 8
  %330 = getelementptr inbounds nuw { ptr, i64 }, ptr %321, i32 0, i32 0
  %331 = load ptr, ptr %330, align 8
  %332 = getelementptr ptr, ptr %331, i64 %329
  %333 = load ptr, ptr %332, align 8
  store ptr %333, ptr %variant, align 8
  store i64 %329, ptr %i87, align 8
  %334 = load i64, ptr %i87, align 8
  %335 = icmp sgt i64 %334, 0
  %336 = zext i1 %335 to i8
  %337 = icmp ne i8 %336, 0
  br i1 %337, label %if.then88, label %if.done89

if.then88:                                        ; preds = %for.index.body86
  %338 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$229", i64 2 })
  br label %if.done89

if.done89:                                        ; preds = %if.then88, %for.index.body86
  %339 = load ptr, ptr %variant, align 8
  call void @"runtime::print_type"(ptr %339)
  br label %for.index.loop85

for.index.done90:                                 ; preds = %for.index.loop85
  %340 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$23b", i64 1 })
  br label %typeswitch.done114

typeswitch.body91:                                ; preds = %if.done
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %25, i64 40, i1 false)
  %341 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$23c", i64 5 })
  %342 = getelementptr inbounds nuw %"runtime::Type_Info_Enum", ptr %2, i32 0, i32 0
  %343 = load ptr, ptr %342, align 8
  call void @"runtime::print_type"(ptr %343)
  %344 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$23d", i64 2 })
  %345 = getelementptr inbounds nuw %"runtime::Type_Info_Enum", ptr %2, i32 0, i32 1
  %346 = load { ptr, i64 }, ptr %345, align 8
  %347 = getelementptr inbounds nuw { ptr, i64 }, ptr %345, i32 0, i32 1
  %348 = load i64, ptr %347, align 8
  store i64 %348, ptr %13, align 8
  store i64 -1, ptr %14, align 8
  br label %for.index.loop92

for.index.loop92:                                 ; preds = %if.done97, %typeswitch.body91
  %349 = load i64, ptr %14, align 8
  %350 = add i64 %349, 1
  store i64 %350, ptr %14, align 8
  %351 = load i64, ptr %13, align 8
  %352 = icmp slt i64 %350, %351
  br i1 %352, label %for.index.body93, label %for.index.done98

for.index.body93:                                 ; preds = %for.index.loop92
  %353 = load i64, ptr %14, align 8
  %354 = getelementptr inbounds nuw { ptr, i64 }, ptr %345, i32 0, i32 0
  %355 = load ptr, ptr %354, align 8
  %356 = getelementptr %..string, ptr %355, i64 %353
  %357 = load %..string, ptr %356, align 8
  store %..string %357, ptr %name94, align 8
  store i64 %353, ptr %i95, align 8
  %358 = load i64, ptr %i95, align 8
  %359 = icmp sgt i64 %358, 0
  %360 = zext i1 %359 to i8
  %361 = icmp ne i8 %360, 0
  br i1 %361, label %if.then96, label %if.done97

if.then96:                                        ; preds = %for.index.body93
  %362 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$229", i64 2 })
  br label %if.done97

if.done97:                                        ; preds = %if.then96, %for.index.body93
  %363 = load %..string, ptr %name94, align 8
  %364 = call i64 @"runtime::print_string"(%..string %363)
  br label %for.index.loop92

for.index.done98:                                 ; preds = %for.index.loop92
  %365 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$23b", i64 1 })
  br label %typeswitch.done114

typeswitch.body99:                                ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 32, i1 false)
  %366 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$23e", i64 8 })
  %367 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 0
  %368 = load ptr, ptr %367, align 8
  %369 = call ptr @"runtime::type_info_base"(ptr %368)
  store ptr %369, ptr %15, align 8
  %370 = load ptr, ptr %15, align 8
  %371 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %370, i32 0, i32 5
  %372 = load { [9 x i64], i64 }, ptr %371, align 8
  %373 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %371, i32 0, i32 1
  %374 = load i64, ptr %373, align 8
  switch i64 %374, label %typeswitch.default.body [
    i64 21, label %typeswitch.body100
    i64 3, label %typeswitch.body101
  ]

typeswitch.body100:                               ; preds = %typeswitch.body99
  call void @llvm.memcpy.p0.p0.i64(ptr %16, ptr %371, i64 40, i1 false)
  %375 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 0
  %376 = load ptr, ptr %375, align 8
  call void @"runtime::print_type"(ptr %376)
  br label %typeswitch.done

typeswitch.body101:                               ; preds = %typeswitch.body99
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %16, ptr %371, i64 0, i1 false)
  %377 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 2
  %378 = load i64, ptr %377, align 8
  %379 = trunc i64 %378 to i32
  call void @"runtime::print_encoded_rune"(i32 %379)
  %380 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$23f", i64 2 })
  %381 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 3
  %382 = load i64, ptr %381, align 8
  %383 = trunc i64 %382 to i32
  call void @"runtime::print_encoded_rune"(i32 %383)
  br label %typeswitch.done

typeswitch.default.body:                          ; preds = %typeswitch.body99
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %elem, ptr align 1 %371, i64 80, i1 false)
  %384 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 2
  %385 = load i64, ptr %384, align 8
  call void @"runtime::print_i64"(i64 %385)
  %386 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$23f", i64 2 })
  %387 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 3
  %388 = load i64, ptr %387, align 8
  call void @"runtime::print_i64"(i64 %388)
  br label %typeswitch.done

typeswitch.done:                                  ; preds = %typeswitch.default.body, %typeswitch.body101, %typeswitch.body100
  %389 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 1
  %390 = load ptr, ptr %389, align 8
  %391 = icmp ne ptr %390, null
  %392 = zext i1 %391 to i8
  %393 = icmp ne i8 %392, 0
  br i1 %393, label %if.then102, label %if.done103

if.then102:                                       ; preds = %typeswitch.done
  %394 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$240", i64 2 })
  %395 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 1
  %396 = load ptr, ptr %395, align 8
  call void @"runtime::print_type"(ptr %396)
  br label %if.done103

if.done103:                                       ; preds = %if.then102, %typeswitch.done
  %397 = call i64 @"runtime::print_byte"(i8 93)
  br label %typeswitch.done114

typeswitch.body104:                               ; preds = %if.done
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %25, i64 56, i1 false)
  %398 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$241", i64 10 })
  %399 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Field", ptr %2, i32 0, i32 0
  %400 = load ptr, ptr %399, align 8
  call void @"runtime::print_type"(ptr %400)
  %401 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$23d", i64 2 })
  %402 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Field", ptr %2, i32 0, i32 1
  %403 = load ptr, ptr %402, align 8
  %404 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Field", ptr %2, i32 0, i32 6
  %405 = load i64, ptr %404, align 8
  call void @"runtime::multi_pointer_slice_expr_error"(%..string { ptr @"csbs$byte_world$208", i64 37 }, i32 480, i32 28, i64 0, i64 %405)
  %406 = getelementptr %..string, ptr %403, i64 0
  %407 = sub i64 %405, 0
  %408 = getelementptr inbounds nuw { ptr, i64 }, ptr %17, i32 0, i32 0
  %409 = getelementptr inbounds nuw { ptr, i64 }, ptr %17, i32 0, i32 1
  store ptr %406, ptr %408, align 8
  store i64 %407, ptr %409, align 8
  %410 = load { ptr, i64 }, ptr %17, align 8
  %411 = getelementptr inbounds nuw { ptr, i64 }, ptr %17, i32 0, i32 1
  %412 = load i64, ptr %411, align 8
  store i64 %412, ptr %18, align 8
  store i64 -1, ptr %19, align 8
  br label %for.index.loop105

for.index.loop105:                                ; preds = %if.done110, %typeswitch.body104
  %413 = load i64, ptr %19, align 8
  %414 = add i64 %413, 1
  store i64 %414, ptr %19, align 8
  %415 = load i64, ptr %18, align 8
  %416 = icmp slt i64 %414, %415
  br i1 %416, label %for.index.body106, label %for.index.done111

for.index.body106:                                ; preds = %for.index.loop105
  %417 = load i64, ptr %19, align 8
  %418 = getelementptr inbounds nuw { ptr, i64 }, ptr %17, i32 0, i32 0
  %419 = load ptr, ptr %418, align 8
  %420 = getelementptr %..string, ptr %419, i64 %417
  %421 = load %..string, ptr %420, align 8
  store %..string %421, ptr %name107, align 8
  store i64 %417, ptr %i108, align 8
  %422 = load i64, ptr %i108, align 8
  %423 = icmp sgt i64 %422, 0
  %424 = zext i1 %423 to i8
  %425 = icmp ne i8 %424, 0
  br i1 %425, label %if.then109, label %if.done110

if.then109:                                       ; preds = %for.index.body106
  %426 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$229", i64 2 })
  br label %if.done110

if.done110:                                       ; preds = %if.then109, %for.index.body106
  %427 = load %..string, ptr %name107, align 8
  %428 = call i64 @"runtime::print_string"(%..string %427)
  %429 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$22c", i64 2 })
  %430 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Field", ptr %2, i32 0, i32 2
  %431 = load ptr, ptr %430, align 8
  %432 = load i64, ptr %i108, align 8
  %433 = getelementptr ptr, ptr %431, i64 %432
  %434 = load ptr, ptr %433, align 8
  call void @"runtime::print_type"(ptr %434)
  %435 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$242", i64 3 })
  %436 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Field", ptr %2, i32 0, i32 3
  %437 = load ptr, ptr %436, align 8
  %438 = load i64, ptr %i108, align 8
  %439 = getelementptr i64, ptr %437, i64 %438
  %440 = load i64, ptr %439, align 8
  call void @"runtime::print_u64"(i64 %440)
  br label %for.index.loop105

for.index.done111:                                ; preds = %for.index.loop105
  %441 = call i64 @"runtime::print_byte"(i8 125)
  br label %typeswitch.done114

typeswitch.body112:                               ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %25, i64 24, i1 false)
  %442 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$243", i64 6 })
  %443 = getelementptr inbounds nuw %"runtime::Type_Info_Simd_Vector", ptr %2, i32 0, i32 2
  %444 = load i64, ptr %443, align 8
  call void @"runtime::print_u64"(i64 %444)
  %445 = call i64 @"runtime::print_byte"(i8 93)
  %446 = getelementptr inbounds nuw %"runtime::Type_Info_Simd_Vector", ptr %2, i32 0, i32 0
  %447 = load ptr, ptr %446, align 8
  call void @"runtime::print_type"(ptr %447)
  br label %typeswitch.done114

typeswitch.body113:                               ; preds = %if.done
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %25, i64 48, i1 false)
  %448 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$244", i64 7 })
  %449 = getelementptr inbounds nuw %"runtime::Type_Info_Matrix", ptr %2, i32 0, i32 3
  %450 = load i64, ptr %449, align 8
  call void @"runtime::print_u64"(i64 %450)
  %451 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$229", i64 2 })
  %452 = getelementptr inbounds nuw %"runtime::Type_Info_Matrix", ptr %2, i32 0, i32 4
  %453 = load i64, ptr %452, align 8
  call void @"runtime::print_u64"(i64 %453)
  %454 = call i64 @"runtime::print_string"(%..string { ptr @"csbs$byte_world$245", i64 1 })
  %455 = getelementptr inbounds nuw %"runtime::Type_Info_Matrix", ptr %2, i32 0, i32 0
  %456 = load ptr, ptr %455, align 8
  call void @"runtime::print_type"(ptr %456)
  br label %typeswitch.done114

typeswitch.done114:                               ; preds = %typeswitch.body113, %typeswitch.body112, %for.index.done111, %if.done103, %for.index.done98, %for.index.done90, %for.index.done79, %typeswitch.body60, %typeswitch.body59, %typeswitch.body58, %if.done57, %typeswitch.body54, %if.done53, %if.done39, %typeswitch.body30, %typeswitch.body29, %if.done28, %typeswitch.body24, %typeswitch.body23, %switch.done22, %switch.done17, %typeswitch.body11, %typeswitch.body10, %typeswitch.body9, %typeswitch.body8, %switch.done, %typeswitch.body, %if.done
  ret void
}

define internal void @"strconv::round_shortest"(ptr %0, i64 %1, i64 %2, ptr %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca ptr, align 8
  %minexp = alloca i64, align 8
  %upper_ = alloca %"strconv_decimal::Decimal", align 8
  %upper = alloca ptr, align 8
  %mantlo = alloca i64, align 8
  %explo = alloca i64, align 8
  %lower_ = alloca %"strconv_decimal::Decimal", align 8
  %lower = alloca ptr, align 8
  %inclusive = alloca i8, align 1
  %i = alloca i64, align 8
  %8 = alloca i64, align 8
  %i5 = alloca i64, align 8
  %l = alloca i8, align 1
  %m = alloca i8, align 1
  %u = alloca i8, align 1
  %ok_round_down = alloca i8, align 1
  %ok_round_up = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %4, align 8
  store i64 %1, ptr %5, align 8
  store i64 %2, ptr %6, align 8
  store ptr %3, ptr %7, align 8
  %9 = icmp eq i64 %1, 0
  %10 = zext i1 %9 to i8
  %11 = icmp ne i8 %10, 0
  br i1 %11, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %12 = load ptr, ptr %4, align 8
  %13 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %12, i32 0, i32 1
  store i64 0, ptr %13, align 8
  ret void

if.done:                                          ; preds = %entry
  %14 = load ptr, ptr %7, align 8
  %15 = getelementptr inbounds nuw %"strconv::Float_Info", ptr %14, i32 0, i32 2
  %16 = load i64, ptr %15, align 8
  %17 = add i64 %16, 1
  store i64 %17, ptr %minexp, align 8
  %18 = load i64, ptr %minexp, align 8
  %19 = icmp sgt i64 %2, %18
  %20 = zext i1 %19 to i8
  %21 = icmp ne i8 %20, 0
  br i1 %21, label %cmp.and, label %if.done2

cmp.and:                                          ; preds = %if.done
  %22 = load ptr, ptr %4, align 8
  %23 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %22, i32 0, i32 2
  %24 = load i64, ptr %23, align 8
  %25 = load ptr, ptr %4, align 8
  %26 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %25, i32 0, i32 1
  %27 = load i64, ptr %26, align 8
  %28 = sub i64 %24, %27
  %29 = mul i64 332, %28
  %30 = load ptr, ptr %7, align 8
  %31 = getelementptr inbounds nuw %"strconv::Float_Info", ptr %30, i32 0, i32 0
  %32 = load i64, ptr %31, align 8
  %33 = sub i64 %2, %32
  %34 = mul i64 100, %33
  %35 = icmp sge i64 %29, %34
  %36 = zext i1 %35 to i8
  %37 = icmp ne i8 %36, 0
  br i1 %37, label %if.then1, label %if.done2

if.then1:                                         ; preds = %cmp.and
  ret void

if.done2:                                         ; preds = %cmp.and, %if.done
  call void @llvm.memset.p0.i64(ptr %upper_, i8 0, i64 408, i1 false)
  store ptr %upper_, ptr %upper, align 8
  %38 = load ptr, ptr %upper, align 8
  %39 = mul i64 2, %1
  %40 = sub i64 %39, 1
  call void @"strconv_decimal::assign"(ptr %38, i64 %40, ptr %__.context_ptr)
  %41 = load ptr, ptr %upper, align 8
  %42 = load ptr, ptr %7, align 8
  %43 = getelementptr inbounds nuw %"strconv::Float_Info", ptr %42, i32 0, i32 0
  %44 = load i64, ptr %43, align 8
  %45 = sub i64 %2, %44
  %46 = sub i64 %45, 1
  call void @"strconv_decimal::shift"(ptr %41, i64 %46, ptr %__.context_ptr)
  store i64 0, ptr %mantlo, align 8
  store i64 0, ptr %explo, align 8
  %47 = load ptr, ptr %7, align 8
  %48 = getelementptr inbounds nuw %"strconv::Float_Info", ptr %47, i32 0, i32 0
  %49 = load i64, ptr %48, align 8
  %50 = icmp ult i64 %49, 64
  %51 = shl i64 1, %49
  %52 = select i1 %50, i64 %51, i64 0
  %53 = icmp ugt i64 %1, %52
  %54 = zext i1 %53 to i8
  %55 = icmp ne i8 %54, 0
  br i1 %55, label %if.then3, label %cmp.or

cmp.or:                                           ; preds = %if.done2
  %56 = load i64, ptr %minexp, align 8
  %57 = icmp eq i64 %2, %56
  %58 = zext i1 %57 to i8
  %59 = icmp ne i8 %58, 0
  br i1 %59, label %if.then3, label %if.else

if.then3:                                         ; preds = %cmp.or, %if.done2
  %60 = sub i64 %1, 1
  store i64 %60, ptr %mantlo, align 8
  store i64 %2, ptr %explo, align 8
  br label %if.done4

if.else:                                          ; preds = %cmp.or
  %61 = mul i64 2, %1
  %62 = sub i64 %61, 1
  store i64 %62, ptr %mantlo, align 8
  %63 = sub i64 %2, 1
  store i64 %63, ptr %explo, align 8
  br label %if.done4

if.done4:                                         ; preds = %if.else, %if.then3
  call void @llvm.memset.p0.i64(ptr %lower_, i8 0, i64 408, i1 false)
  store ptr %lower_, ptr %lower, align 8
  %64 = load ptr, ptr %lower, align 8
  %65 = load i64, ptr %mantlo, align 8
  %66 = mul i64 2, %65
  %67 = add i64 %66, 1
  call void @"strconv_decimal::assign"(ptr %64, i64 %67, ptr %__.context_ptr)
  %68 = load ptr, ptr %lower, align 8
  %69 = load i64, ptr %explo, align 8
  %70 = load ptr, ptr %7, align 8
  %71 = getelementptr inbounds nuw %"strconv::Float_Info", ptr %70, i32 0, i32 0
  %72 = load i64, ptr %71, align 8
  %73 = sub i64 %69, %72
  %74 = sub i64 %73, 1
  call void @"strconv_decimal::shift"(ptr %68, i64 %74, ptr %__.context_ptr)
  %75 = urem i64 %1, 2
  %76 = icmp eq i64 %75, 0
  %77 = zext i1 %76 to i8
  store i8 %77, ptr %inclusive, align 1
  store i64 0, ptr %i, align 8
  store i64 0, ptr %8, align 8
  br label %for.interval.loop

for.interval.loop:                                ; preds = %for.interval.post, %if.done4
  %78 = load ptr, ptr %4, align 8
  %79 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %78, i32 0, i32 1
  %80 = load i64, ptr %79, align 8
  %81 = load i64, ptr %i, align 8
  %82 = icmp slt i64 %81, %80
  br i1 %82, label %for.interval.body, label %for.interval.done

for.interval.body:                                ; preds = %for.interval.loop
  %83 = load i64, ptr %i, align 8
  %84 = load i64, ptr %8, align 8
  store i64 %83, ptr %i5, align 8
  store i8 48, ptr %l, align 1
  %85 = load i64, ptr %i5, align 8
  %86 = load ptr, ptr %lower, align 8
  %87 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %86, i32 0, i32 1
  %88 = load i64, ptr %87, align 8
  %89 = icmp slt i64 %85, %88
  %90 = zext i1 %89 to i8
  %91 = icmp ne i8 %90, 0
  br i1 %91, label %if.then6, label %if.done7

if.then6:                                         ; preds = %for.interval.body
  %92 = load ptr, ptr %lower, align 8
  %93 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %92, i32 0, i32 0
  %94 = load i64, ptr %i5, align 8
  %95 = getelementptr [384 x i8], ptr %93, i64 0, i64 %94
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1e7", i64 45 }, i32 305, i32 21, i64 %94, i64 384)
  %96 = load i8, ptr %95, align 1
  store i8 %96, ptr %l, align 1
  br label %if.done7

if.done7:                                         ; preds = %if.then6, %for.interval.body
  %97 = load ptr, ptr %4, align 8
  %98 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %97, i32 0, i32 0
  %99 = load i64, ptr %i5, align 8
  %100 = getelementptr [384 x i8], ptr %98, i64 0, i64 %99
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1e7", i64 45 }, i32 307, i32 17, i64 %99, i64 384)
  %101 = load i8, ptr %100, align 1
  store i8 %101, ptr %m, align 1
  store i8 48, ptr %u, align 1
  %102 = load i64, ptr %i5, align 8
  %103 = load ptr, ptr %upper, align 8
  %104 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %103, i32 0, i32 1
  %105 = load i64, ptr %104, align 8
  %106 = icmp slt i64 %102, %105
  %107 = zext i1 %106 to i8
  %108 = icmp ne i8 %107, 0
  br i1 %108, label %if.then8, label %if.done9

if.then8:                                         ; preds = %if.done7
  %109 = load ptr, ptr %upper, align 8
  %110 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %109, i32 0, i32 0
  %111 = load i64, ptr %i5, align 8
  %112 = getelementptr [384 x i8], ptr %110, i64 0, i64 %111
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1e7", i64 45 }, i32 310, i32 21, i64 %111, i64 384)
  %113 = load i8, ptr %112, align 1
  store i8 %113, ptr %u, align 1
  br label %if.done9

if.done9:                                         ; preds = %if.then8, %if.done7
  %114 = load i8, ptr %l, align 1
  %115 = load i8, ptr %m, align 1
  %116 = icmp ne i8 %114, %115
  %117 = zext i1 %116 to i8
  %118 = icmp ne i8 %117, 0
  br i1 %118, label %logical.cmp.done11, label %logical.cmp.rhs

logical.cmp.rhs:                                  ; preds = %if.done9
  %119 = load i8, ptr %inclusive, align 1
  %120 = icmp ne i8 %119, 0
  br i1 %120, label %logical.cmp.rhs10, label %logical.cmp.done

logical.cmp.rhs10:                                ; preds = %logical.cmp.rhs
  %121 = load i64, ptr %i5, align 8
  %122 = add i64 %121, 1
  %123 = load ptr, ptr %lower, align 8
  %124 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %123, i32 0, i32 1
  %125 = load i64, ptr %124, align 8
  %126 = icmp eq i64 %122, %125
  %127 = zext i1 %126 to i8
  %128 = icmp ne i8 %127, 0
  br label %logical.cmp.done

logical.cmp.done:                                 ; preds = %logical.cmp.rhs10, %logical.cmp.rhs
  %129 = phi i1 [ false, %logical.cmp.rhs ], [ %128, %logical.cmp.rhs10 ]
  %130 = zext i1 %129 to i8
  %131 = icmp ne i8 %130, 0
  br label %logical.cmp.done11

logical.cmp.done11:                               ; preds = %logical.cmp.done, %if.done9
  %132 = phi i1 [ true, %if.done9 ], [ %131, %logical.cmp.done ]
  %133 = zext i1 %132 to i8
  store i8 %133, ptr %ok_round_down, align 1
  %134 = load i8, ptr %m, align 1
  %135 = load i8, ptr %u, align 1
  %136 = icmp ne i8 %134, %135
  %137 = zext i1 %136 to i8
  %138 = icmp ne i8 %137, 0
  br i1 %138, label %logical.cmp.rhs12, label %logical.cmp.done16

logical.cmp.rhs12:                                ; preds = %logical.cmp.done11
  %139 = load i8, ptr %inclusive, align 1
  %140 = icmp ne i8 %139, 0
  br i1 %140, label %logical.cmp.done15, label %cmp.or13

cmp.or13:                                         ; preds = %logical.cmp.rhs12
  %141 = load i8, ptr %m, align 1
  %142 = add i8 %141, 1
  %143 = load i8, ptr %u, align 1
  %144 = icmp ult i8 %142, %143
  %145 = zext i1 %144 to i8
  %146 = icmp ne i8 %145, 0
  br i1 %146, label %logical.cmp.done15, label %logical.cmp.rhs14

logical.cmp.rhs14:                                ; preds = %cmp.or13
  %147 = load i64, ptr %i5, align 8
  %148 = add i64 %147, 1
  %149 = load ptr, ptr %upper, align 8
  %150 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %149, i32 0, i32 1
  %151 = load i64, ptr %150, align 8
  %152 = icmp slt i64 %148, %151
  %153 = zext i1 %152 to i8
  %154 = icmp ne i8 %153, 0
  br label %logical.cmp.done15

logical.cmp.done15:                               ; preds = %logical.cmp.rhs14, %cmp.or13, %logical.cmp.rhs12
  %155 = phi i1 [ true, %logical.cmp.rhs12 ], [ true, %cmp.or13 ], [ %154, %logical.cmp.rhs14 ]
  %156 = zext i1 %155 to i8
  %157 = icmp ne i8 %156, 0
  br label %logical.cmp.done16

logical.cmp.done16:                               ; preds = %logical.cmp.done15, %logical.cmp.done11
  %158 = phi i1 [ false, %logical.cmp.done11 ], [ %157, %logical.cmp.done15 ]
  %159 = zext i1 %158 to i8
  store i8 %159, ptr %ok_round_up, align 1
  %160 = load i8, ptr %ok_round_down, align 1
  %161 = icmp ne i8 %160, 0
  br i1 %161, label %cmp.and17, label %if.done19

cmp.and17:                                        ; preds = %logical.cmp.done16
  %162 = load i8, ptr %ok_round_up, align 1
  %163 = icmp ne i8 %162, 0
  br i1 %163, label %if.then18, label %if.done19

if.then18:                                        ; preds = %cmp.and17
  %164 = load i64, ptr %i5, align 8
  %165 = add i64 %164, 1
  call void @"strconv_decimal::round"(ptr %0, i64 %165, ptr %__.context_ptr)
  ret void

if.done19:                                        ; preds = %cmp.and17, %logical.cmp.done16
  %166 = load i8, ptr %ok_round_down, align 1
  %167 = icmp ne i8 %166, 0
  br i1 %167, label %if.then20, label %if.done21

if.then20:                                        ; preds = %if.done19
  %168 = load i64, ptr %i5, align 8
  %169 = add i64 %168, 1
  call void @"strconv_decimal::round_down"(ptr %0, i64 %169, ptr %__.context_ptr)
  ret void

if.done21:                                        ; preds = %if.done19
  %170 = load i8, ptr %ok_round_up, align 1
  %171 = icmp ne i8 %170, 0
  br i1 %171, label %if.then22, label %if.done23

if.then22:                                        ; preds = %if.done21
  %172 = load i64, ptr %i5, align 8
  %173 = add i64 %172, 1
  call void @"strconv_decimal::round_up"(ptr %0, i64 %173, ptr %__.context_ptr)
  ret void

if.done23:                                        ; preds = %if.done21
  br label %for.interval.post

for.interval.post:                                ; preds = %if.done23
  %174 = load i64, ptr %i, align 8
  %175 = add i64 %174, 1
  store i64 %175, ptr %i, align 8
  %176 = load i64, ptr %8, align 8
  %177 = add i64 %176, 1
  store i64 %177, ptr %8, align 8
  br label %for.interval.loop

for.interval.done:                                ; preds = %for.interval.loop
  ret void
}

define internal void @"strings::builder_destroy"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = load ptr, ptr %1, align 8
  %3 = getelementptr inbounds nuw %"strings::Builder", ptr %2, i32 0, i32 0
  %4 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %3, align 8
  %5 = load %"runtime::Source_Code_Location", ptr @"scl$[builder_destroy5982]", align 8
  %6 = call i8 @"runtime::delete_dynamic_array:proc(array:[dynamic]u8,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"(ptr %3, ptr @"scl$[builder_destroy5982]", ptr %__.context_ptr)
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr inbounds nuw %"strings::Builder", ptr %7, i32 0, i32 0
  call void @llvm.memset.p0.i64(ptr %8, i8 0, i64 40, i1 false)
  ret void
}

define internal i64 @"time::date"(i64 %0, ptr noalias nonnull %1, ptr noalias nonnull %2) {
decls:
  %3 = alloca %"time::Time", align 16
  %year = alloca i64, align 8
  %month = alloca i64, align 8
  %day = alloca i64, align 8
  %4 = alloca i64, align 16
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca { i64, i64, i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %3, align 8
  %9 = load %"time::Time", ptr %3, align 8
  store i64 0, ptr %year, align 8
  store i64 0, ptr %month, align 8
  store i64 0, ptr %day, align 8
  store %"time::Time" %9, ptr %4, align 8
  %10 = load i64, ptr %4, align 8
  %11 = call i64 @"time::[time.odin]::_time_abs"(i64 %10)
  store i64 0, ptr %5, align 8
  store i64 0, ptr %6, align 8
  store i64 0, ptr %7, align 8
  %12 = call i64 @"time::[time.odin]::_abs_date"(i64 %11, i8 1, ptr %5, ptr %6, ptr %7)
  %13 = load i64, ptr %5, align 8
  %14 = load i64, ptr %6, align 8
  %15 = load i64, ptr %7, align 8
  %16 = load { i64, i64, i64, i64 }, ptr %8, align 8
  store i64 %13, ptr %year, align 8
  store i64 %14, ptr %month, align 8
  store i64 %15, ptr %day, align 8
  %17 = load i64, ptr %year, align 8
  %18 = load i64, ptr %month, align 8
  %19 = load i64, ptr %day, align 8
  store i64 %17, ptr %year, align 8
  store i64 %18, ptr %month, align 8
  store i64 %19, ptr %day, align 8
  store i64 %17, ptr %1, align 8
  store i64 %18, ptr %2, align 8
  ret i64 %19
}

define internal i8 @"runtime::arena_allocator_proc"(ptr %0, i8 %1, i64 %2, i64 %3, ptr %4, i64 %5, ptr %6, ptr noalias nonnull %7, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %8 = alloca ptr, align 8
  %9 = alloca i8, align 1
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca ptr, align 8
  %13 = alloca i64, align 8
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %arena = alloca ptr, align 8
  %size = alloca i64, align 8
  %alignment = alloca i64, align 8
  %old_size = alloca i64, align 8
  %14 = alloca { ptr, i64 }, align 8
  %15 = alloca { { ptr, i64 }, i8 }, align 8
  %old_data = alloca ptr, align 8
  %16 = alloca { ptr, i64 }, align 8
  %17 = alloca { { ptr, i64 }, i8 }, align 8
  %18 = alloca { ptr, i64 }, align 8
  %19 = alloca { ptr, i64 }, align 8
  %block = alloca ptr, align 8
  %start = alloca i64, align 8
  %old_end = alloca i64, align 8
  %new_end = alloca i64, align 8
  %20 = alloca { ptr, i64 }, align 8
  %21 = alloca { ptr, i64 }, align 8
  %22 = alloca { { ptr, i64 }, i8 }, align 8
  %new_memory = alloca { ptr, i64 }, align 8
  %23 = alloca { ptr, i64 }, align 8
  %set = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %8, align 8
  store i8 %1, ptr %9, align 1
  store i64 %2, ptr %10, align 8
  store i64 %3, ptr %11, align 8
  store ptr %4, ptr %12, align 8
  store i64 %5, ptr %13, align 8
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  store ptr %0, ptr %arena, align 8
  store i64 %2, ptr %size, align 8
  store i64 %3, ptr %alignment, align 8
  store i64 %5, ptr %old_size, align 8
  switch i8 %1, label %switch.done22 [
    i8 0, label %switch.case.body
    i8 6, label %switch.case.body
    i8 1, label %switch.case.body1
    i8 2, label %switch.case.body2
    i8 3, label %switch.case.body3
    i8 7, label %switch.case.body3
    i8 4, label %switch.case.body18
    i8 5, label %switch.case.body21
  ]

switch.case.body:                                 ; preds = %entry, %entry
  %24 = load ptr, ptr %arena, align 8
  %25 = load i64, ptr %size, align 8
  %26 = load i64, ptr %alignment, align 8
  %27 = load %"runtime::Source_Code_Location", ptr %6, align 8
  call void @llvm.memset.inline.p0.i64(ptr %14, i8 0, i64 16, i1 false)
  %28 = call i8 @"runtime::arena_alloc"(ptr %24, i64 %25, i64 %26, ptr %6, ptr %14, ptr %__.context_ptr)
  %29 = load { ptr, i64 }, ptr %14, align 8
  %30 = load { { ptr, i64 }, i8 }, ptr %15, align 8
  store { ptr, i64 } %29, ptr %data, align 8
  store i8 %28, ptr %err, align 1
  store { ptr, i64 } %29, ptr %7, align 8
  ret i8 %28

switch.case.body1:                                ; preds = %entry
  store i8 4, ptr %err, align 1
  br label %switch.done22

switch.case.body2:                                ; preds = %entry
  %31 = load ptr, ptr %arena, align 8
  %32 = load %"runtime::Source_Code_Location", ptr %6, align 8
  call void @"runtime::arena_free_all"(ptr %31, ptr %6, ptr %__.context_ptr)
  br label %switch.done22

switch.case.body3:                                ; preds = %entry, %entry
  store ptr %4, ptr %old_data, align 8
  %33 = load ptr, ptr %old_data, align 8
  %34 = icmp eq ptr %33, null
  %35 = zext i1 %34 to i8
  %36 = icmp eq i8 1, %35
  br i1 %36, label %switch.case.body4, label %switch.case.next

switch.case.next:                                 ; preds = %switch.case.body3
  %37 = load i64, ptr %size, align 8
  %38 = load i64, ptr %old_size, align 8
  %39 = icmp eq i64 %37, %38
  %40 = zext i1 %39 to i8
  %41 = icmp eq i8 1, %40
  br i1 %41, label %switch.case.body6, label %switch.case.next5

switch.case.body4:                                ; preds = %switch.case.body3
  %42 = load ptr, ptr %arena, align 8
  %43 = load i64, ptr %size, align 8
  %44 = load i64, ptr %alignment, align 8
  %45 = load %"runtime::Source_Code_Location", ptr %6, align 8
  call void @llvm.memset.inline.p0.i64(ptr %16, i8 0, i64 16, i1 false)
  %46 = call i8 @"runtime::arena_alloc"(ptr %42, i64 %43, i64 %44, ptr %6, ptr %16, ptr %__.context_ptr)
  %47 = load { ptr, i64 }, ptr %16, align 8
  %48 = load { { ptr, i64 }, i8 }, ptr %17, align 8
  store { ptr, i64 } %47, ptr %data, align 8
  store i8 %46, ptr %err, align 1
  store { ptr, i64 } %47, ptr %7, align 8
  ret i8 %46

switch.case.next5:                                ; preds = %switch.case.next
  %49 = load i64, ptr %size, align 8
  %50 = icmp eq i64 %49, 0
  %51 = zext i1 %50 to i8
  %52 = icmp eq i8 1, %51
  br i1 %52, label %switch.case.body8, label %switch.case.next7

switch.case.body6:                                ; preds = %switch.case.next
  %53 = load ptr, ptr %old_data, align 8
  %54 = load i64, ptr %size, align 8
  call void @"runtime::multi_pointer_slice_expr_error"(%..string { ptr @"csbs$byte_world$1e1", i64 60 }, i32 219, i32 19, i64 0, i64 %54)
  %55 = getelementptr i8, ptr %53, i64 0
  %56 = sub i64 %54, 0
  %57 = getelementptr inbounds nuw { ptr, i64 }, ptr %18, i32 0, i32 0
  %58 = getelementptr inbounds nuw { ptr, i64 }, ptr %18, i32 0, i32 1
  store ptr %55, ptr %57, align 8
  store i64 %56, ptr %58, align 8
  %59 = load { ptr, i64 }, ptr %18, align 8
  store { ptr, i64 } %59, ptr %data, align 8
  %60 = load { ptr, i64 }, ptr %data, align 8
  %61 = load i8, ptr %err, align 1
  store { ptr, i64 } %60, ptr %data, align 8
  store i8 %61, ptr %err, align 1
  store { ptr, i64 } %60, ptr %7, align 8
  ret i8 %61

switch.case.next7:                                ; preds = %switch.case.next5
  %62 = load ptr, ptr %old_data, align 8
  %63 = ptrtoint ptr %62 to i64
  %64 = load i64, ptr %alignment, align 8
  %65 = sub i64 %64, 1
  %66 = and i64 %63, %65
  %67 = icmp eq i64 %66, 0
  %68 = zext i1 %67 to i8
  %69 = icmp eq i8 1, %68
  br i1 %69, label %switch.case.body10, label %switch.case.next9

switch.case.body8:                                ; preds = %switch.case.next5
  store i8 4, ptr %err, align 1
  %70 = load { ptr, i64 }, ptr %data, align 8
  %71 = load i8, ptr %err, align 1
  store { ptr, i64 } %70, ptr %data, align 8
  store i8 %71, ptr %err, align 1
  store { ptr, i64 } %70, ptr %7, align 8
  ret i8 %71

switch.case.next9:                                ; preds = %switch.case.next7
  br label %switch.done

switch.case.body10:                               ; preds = %switch.case.next7
  %72 = load i64, ptr %size, align 8
  %73 = load i64, ptr %old_size, align 8
  %74 = icmp ult i64 %72, %73
  %75 = zext i1 %74 to i8
  %76 = icmp ne i8 %75, 0
  br i1 %76, label %if.then, label %if.done

if.then:                                          ; preds = %switch.case.body10
  %77 = load ptr, ptr %old_data, align 8
  %78 = load i64, ptr %size, align 8
  call void @"runtime::multi_pointer_slice_expr_error"(%..string { ptr @"csbs$byte_world$1e1", i64 60 }, i32 227, i32 20, i64 0, i64 %78)
  %79 = getelementptr i8, ptr %77, i64 0
  %80 = sub i64 %78, 0
  %81 = getelementptr inbounds nuw { ptr, i64 }, ptr %19, i32 0, i32 0
  %82 = getelementptr inbounds nuw { ptr, i64 }, ptr %19, i32 0, i32 1
  store ptr %79, ptr %81, align 8
  store i64 %80, ptr %82, align 8
  %83 = load { ptr, i64 }, ptr %19, align 8
  store { ptr, i64 } %83, ptr %data, align 8
  %84 = load { ptr, i64 }, ptr %data, align 8
  %85 = load i8, ptr %err, align 1
  store { ptr, i64 } %84, ptr %data, align 8
  store i8 %85, ptr %err, align 1
  store { ptr, i64 } %84, ptr %7, align 8
  ret i8 %85

if.done:                                          ; preds = %switch.case.body10
  br label %if.init

if.init:                                          ; preds = %if.done
  %86 = load ptr, ptr %arena, align 8
  %87 = getelementptr inbounds nuw %"runtime::Arena", ptr %86, i32 0, i32 1
  %88 = load ptr, ptr %87, align 8
  store ptr %88, ptr %block, align 8
  %89 = load ptr, ptr %block, align 8
  %90 = icmp ne ptr %89, null
  %91 = zext i1 %90 to i8
  %92 = icmp ne i8 %91, 0
  br i1 %92, label %if.then11, label %if.done15

if.then11:                                        ; preds = %if.init
  %93 = ptrtoint ptr %4 to i64
  %94 = load ptr, ptr %block, align 8
  %95 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %94, i32 0, i32 2
  %96 = load ptr, ptr %95, align 8
  %97 = ptrtoint ptr %96 to i64
  %98 = sub i64 %93, %97
  store i64 %98, ptr %start, align 8
  %99 = load i64, ptr %start, align 8
  %100 = load i64, ptr %old_size, align 8
  %101 = add i64 %99, %100
  store i64 %101, ptr %old_end, align 8
  %102 = load i64, ptr %start, align 8
  %103 = load i64, ptr %size, align 8
  %104 = add i64 %102, %103
  store i64 %104, ptr %new_end, align 8
  %105 = load i64, ptr %start, align 8
  %106 = load i64, ptr %old_end, align 8
  %107 = icmp ult i64 %105, %106
  %108 = zext i1 %107 to i8
  %109 = icmp ne i8 %108, 0
  br i1 %109, label %cmp.and, label %if.done14

cmp.and:                                          ; preds = %if.then11
  %110 = load i64, ptr %old_end, align 8
  %111 = load ptr, ptr %block, align 8
  %112 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %111, i32 0, i32 3
  %113 = load i64, ptr %112, align 8
  %114 = icmp eq i64 %110, %113
  %115 = zext i1 %114 to i8
  %116 = icmp ne i8 %115, 0
  br i1 %116, label %cmp.and12, label %if.done14

cmp.and12:                                        ; preds = %cmp.and
  %117 = load i64, ptr %new_end, align 8
  %118 = load ptr, ptr %block, align 8
  %119 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %118, i32 0, i32 4
  %120 = load i64, ptr %119, align 8
  %121 = icmp ule i64 %117, %120
  %122 = zext i1 %121 to i8
  %123 = icmp ne i8 %122, 0
  br i1 %123, label %if.then13, label %if.done14

if.then13:                                        ; preds = %cmp.and12
  %124 = load ptr, ptr %block, align 8
  %125 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %124, i32 0, i32 3
  %126 = load i64, ptr %new_end, align 8
  store i64 %126, ptr %125, align 8
  %127 = load ptr, ptr %block, align 8
  %128 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %127, i32 0, i32 2
  %129 = load ptr, ptr %128, align 8
  %130 = load i64, ptr %start, align 8
  %131 = load i64, ptr %new_end, align 8
  call void @"runtime::multi_pointer_slice_expr_error"(%..string { ptr @"csbs$byte_world$1e1", i64 60 }, i32 238, i32 23, i64 %130, i64 %131)
  %132 = getelementptr i8, ptr %129, i64 %130
  %133 = sub i64 %131, %130
  %134 = getelementptr inbounds nuw { ptr, i64 }, ptr %20, i32 0, i32 0
  %135 = getelementptr inbounds nuw { ptr, i64 }, ptr %20, i32 0, i32 1
  store ptr %132, ptr %134, align 8
  store i64 %133, ptr %135, align 8
  %136 = load { ptr, i64 }, ptr %20, align 8
  store { ptr, i64 } %136, ptr %data, align 8
  %137 = load { ptr, i64 }, ptr %data, align 8
  %138 = load i8, ptr %err, align 1
  store { ptr, i64 } %137, ptr %data, align 8
  store i8 %138, ptr %err, align 1
  store { ptr, i64 } %137, ptr %7, align 8
  ret i8 %138

if.done14:                                        ; preds = %cmp.and12, %cmp.and, %if.then11
  br label %if.done15

if.done15:                                        ; preds = %if.done14, %if.init
  br label %switch.done

switch.done:                                      ; preds = %switch.case.next9, %if.done15
  %139 = load ptr, ptr %arena, align 8
  %140 = load i64, ptr %size, align 8
  %141 = load i64, ptr %alignment, align 8
  %142 = load %"runtime::Source_Code_Location", ptr %6, align 8
  call void @llvm.memset.inline.p0.i64(ptr %21, i8 0, i64 16, i1 false)
  %143 = call i8 @"runtime::arena_alloc"(ptr %139, i64 %140, i64 %141, ptr %6, ptr %21, ptr %__.context_ptr)
  %144 = load { ptr, i64 }, ptr %21, align 8
  %145 = load { { ptr, i64 }, i8 }, ptr %22, align 8
  %146 = icmp eq i8 %143, 0
  br i1 %146, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %switch.done
  store i8 %143, ptr %err, align 1
  %147 = load { ptr, i64 }, ptr %data, align 8
  %148 = load i8, ptr %err, align 1
  store { ptr, i64 } %147, ptr %data, align 8
  store i8 %148, ptr %err, align 1
  store { ptr, i64 } %147, ptr %7, align 8
  ret i8 %148

or_return.continue:                               ; preds = %switch.done
  store { ptr, i64 } %144, ptr %new_memory, align 8
  %149 = load { ptr, i64 }, ptr %new_memory, align 8
  %150 = getelementptr inbounds nuw { ptr, i64 }, ptr %new_memory, i32 0, i32 0
  %151 = load ptr, ptr %150, align 8
  %152 = icmp eq ptr %151, null
  %153 = zext i1 %152 to i8
  %154 = icmp ne i8 %153, 0
  br i1 %154, label %if.then16, label %if.done17

if.then16:                                        ; preds = %or_return.continue
  %155 = load { ptr, i64 }, ptr %data, align 8
  %156 = load i8, ptr %err, align 1
  store { ptr, i64 } %155, ptr %data, align 8
  store i8 %156, ptr %err, align 1
  store { ptr, i64 } %155, ptr %7, align 8
  ret i8 %156

if.done17:                                        ; preds = %or_return.continue
  %157 = load { ptr, i64 }, ptr %new_memory, align 8
  %158 = load ptr, ptr %old_data, align 8
  %159 = load i64, ptr %old_size, align 8
  call void @"runtime::multi_pointer_slice_expr_error"(%..string { ptr @"csbs$byte_world$1e1", i64 60 }, i32 249, i32 28, i64 0, i64 %159)
  %160 = getelementptr i8, ptr %158, i64 0
  %161 = sub i64 %159, 0
  %162 = getelementptr inbounds nuw { ptr, i64 }, ptr %23, i32 0, i32 0
  %163 = getelementptr inbounds nuw { ptr, i64 }, ptr %23, i32 0, i32 1
  store ptr %160, ptr %162, align 8
  store i64 %161, ptr %163, align 8
  %164 = load { ptr, i64 }, ptr %23, align 8
  %165 = call i64 @"runtime::copy_slice:proc\22contextless\22(dst:[]u8,src:[]u8)->(:int)"({ ptr, i64 } %157, { ptr, i64 } %164)
  %166 = load { ptr, i64 }, ptr %new_memory, align 8
  store { ptr, i64 } %166, ptr %data, align 8
  store i8 0, ptr %err, align 1
  store { ptr, i64 } %166, ptr %7, align 8
  ret i8 0

switch.case.body18:                               ; preds = %entry
  store ptr %4, ptr %set, align 8
  %167 = load ptr, ptr %set, align 8
  %168 = icmp ne ptr %167, null
  %169 = zext i1 %168 to i8
  %170 = icmp ne i8 %169, 0
  br i1 %170, label %if.then19, label %if.done20

if.then19:                                        ; preds = %switch.case.body18
  %171 = load ptr, ptr %set, align 8
  store i8 93, ptr %171, align 1
  br label %if.done20

if.done20:                                        ; preds = %if.then19, %switch.case.body18
  br label %switch.done22

switch.case.body21:                               ; preds = %entry
  store i8 4, ptr %err, align 1
  br label %switch.done22

switch.done22:                                    ; preds = %switch.case.body21, %if.done20, %switch.case.body2, %switch.case.body1, %entry
  %172 = load { ptr, i64 }, ptr %data, align 8
  %173 = load i8, ptr %err, align 1
  store { ptr, i64 } %172, ptr %data, align 8
  store i8 %173, ptr %err, align 1
  store { ptr, i64 } %172, ptr %7, align 8
  ret i8 %173
}

; Function Attrs: alwaysinline
define internal i8 @"utf8::rune_start"(i8 %0) #3 {
decls:
  %1 = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store i8 %0, ptr %1, align 1
  %2 = and i8 %0, -64
  %3 = icmp ne i8 %2, -128
  %4 = zext i1 %3 to i8
  ret i8 %4
}

declare i32 @pthread_attr_setstacksize(ptr, i64)

define internal i8 @"reflect::is_rune"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca ptr, align 8
  %3 = alloca { i8, i8 }, align 1
  %ok = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %4 = icmp eq ptr %0, null
  %5 = zext i1 %4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  %7 = call ptr @"runtime::type_info_base"(ptr %0)
  store ptr %7, ptr %2, align 8
  %8 = load ptr, ptr %2, align 8
  %9 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %8, i32 0, i32 5
  %10 = load { [9 x i64], i64 }, ptr %9, align 8
  %11 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %9, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  %13 = icmp eq i64 %12, 3
  %14 = getelementptr inbounds nuw { i8, i8 }, ptr %3, i32 0, i32 1
  %15 = zext i1 %13 to i8
  store i8 %15, ptr %14, align 1
  %16 = load { i8, i8 }, ptr %3, align 1
  %17 = getelementptr inbounds nuw { i8, i8 }, ptr %3, i32 0, i32 0
  %18 = load i8, ptr %17, align 1
  %19 = getelementptr inbounds nuw { i8, i8 }, ptr %3, i32 0, i32 1
  %20 = load i8, ptr %19, align 1
  store i8 %20, ptr %ok, align 1
  %21 = load i8, ptr %ok, align 1
  ret i8 %21
}

; Function Attrs: alwaysinline
define internal i64 @"utf8::rune_count_in_string"(%..string %0, ptr noalias nonnull "captures"="none" %__.context_ptr) #3 {
decls:
  %1 = alloca %..string, align 8
  %2 = alloca %..string, align 8
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %1, align 8
  store %..string %0, ptr %2, align 8
  %3 = load { ptr, i64 }, ptr %2, align 8
  %4 = call i64 @"utf8::rune_count_in_bytes"({ ptr, i64 } %3)
  ret i64 %4
}

define internal void @"runtime::_pop_type_erased"(ptr %0, ptr %1, i64 %2, ptr %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca ptr, align 8
  %5 = alloca ptr, align 8
  %6 = alloca i64, align 8
  %end = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %4, align 8
  store ptr %1, ptr %5, align 8
  store i64 %2, ptr %6, align 8
  %7 = load ptr, ptr %5, align 8
  %8 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %7, i32 0, i32 0
  %9 = load ptr, ptr %8, align 8
  %10 = ptrtoint ptr %9 to i64
  %11 = load ptr, ptr %5, align 8
  %12 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %11, i32 0, i32 1
  %13 = load i64, ptr %12, align 8
  %14 = sub i64 %13, 1
  %15 = mul i64 %2, %14
  %16 = add i64 %10, %15
  %17 = inttoptr i64 %16 to ptr
  store ptr %17, ptr %end, align 8
  %18 = load ptr, ptr %end, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %0, ptr %18, i64 %2, i1 false)
  %19 = load ptr, ptr %5, align 8
  %20 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %19, i32 0, i32 1
  %21 = load i64, ptr %20, align 8
  %22 = sub i64 %21, 1
  store i64 %22, ptr %20, align 8
  ret void
}

define internal i64 @"utf8::rune_count_in_bytes"({ ptr, i64 } %0) {
decls:
  %1 = alloca { ptr, i64 }, align 8
  %count = alloca i64, align 8
  %n = alloca i64, align 8
  %i = alloca i64, align 8
  %si = alloca i8, align 1
  %x = alloca i8, align 1
  %size = alloca i64, align 8
  %ar = alloca %"utf8::Accept_Range", align 1
  %b = alloca i8, align 1
  %c = alloca i8, align 1
  %d = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %1, align 8
  store i64 0, ptr %count, align 8
  %2 = extractvalue { ptr, i64 } %0, 1
  store i64 %2, ptr %n, align 8
  br label %for.init

for.init:                                         ; preds = %entry
  store i64 0, ptr %i, align 8
  br label %for.loop

for.loop:                                         ; preds = %defer26, %defer6, %defer2, %defer, %for.init
  %3 = load i64, ptr %i, align 8
  %4 = load i64, ptr %n, align 8
  %5 = icmp slt i64 %3, %4
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %8 = extractvalue { ptr, i64 } %0, 0
  %9 = load i64, ptr %i, align 8
  %10 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1fa", i64 41 }, i32 330, i32 11, i64 %9, i64 %10)
  %11 = getelementptr i8, ptr %8, i64 %9
  %12 = load i8, ptr %11, align 1
  store i8 %12, ptr %si, align 1
  %13 = load i8, ptr %si, align 1
  %14 = icmp ult i8 %13, -128
  %15 = zext i1 %14 to i8
  %16 = icmp ne i8 %15, 0
  br i1 %16, label %if.then, label %if.done

if.then:                                          ; preds = %for.body
  %17 = load i64, ptr %i, align 8
  %18 = add i64 %17, 1
  store i64 %18, ptr %i, align 8
  br label %defer

defer:                                            ; preds = %if.then
  %19 = load i64, ptr %count, align 8
  %20 = add i64 %19, 1
  store i64 %20, ptr %count, align 8
  br label %for.loop

unreachable:                                      ; No predecessors!
  br label %if.done

if.done:                                          ; preds = %unreachable, %for.body
  %21 = load i8, ptr %si, align 1
  %22 = zext i8 %21 to i64
  %23 = getelementptr [256 x i8], ptr @"utf8::accept_sizes", i64 0, i64 %22
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1fa", i64 41 }, i32 335, i32 21, i64 %22, i64 256)
  %24 = load i8, ptr %23, align 1
  store i8 %24, ptr %x, align 1
  %25 = load i8, ptr %x, align 1
  %26 = icmp eq i8 %25, -15
  %27 = zext i1 %26 to i8
  %28 = icmp ne i8 %27, 0
  br i1 %28, label %if.then1, label %if.done4

if.then1:                                         ; preds = %if.done
  %29 = load i64, ptr %i, align 8
  %30 = add i64 %29, 1
  store i64 %30, ptr %i, align 8
  br label %defer2

defer2:                                           ; preds = %if.then1
  %31 = load i64, ptr %count, align 8
  %32 = add i64 %31, 1
  store i64 %32, ptr %count, align 8
  br label %for.loop

unreachable3:                                     ; No predecessors!
  br label %if.done4

if.done4:                                         ; preds = %unreachable3, %if.done
  %33 = load i8, ptr %x, align 1
  %34 = and i8 %33, 7
  %35 = zext i8 %34 to i64
  store i64 %35, ptr %size, align 8
  %36 = load i64, ptr %i, align 8
  %37 = load i64, ptr %size, align 8
  %38 = add i64 %36, %37
  %39 = load i64, ptr %n, align 8
  %40 = icmp sgt i64 %38, %39
  %41 = zext i1 %40 to i8
  %42 = icmp ne i8 %41, 0
  br i1 %42, label %if.then5, label %if.done8

if.then5:                                         ; preds = %if.done4
  %43 = load i64, ptr %i, align 8
  %44 = add i64 %43, 1
  store i64 %44, ptr %i, align 8
  br label %defer6

defer6:                                           ; preds = %if.then5
  %45 = load i64, ptr %count, align 8
  %46 = add i64 %45, 1
  store i64 %46, ptr %count, align 8
  br label %for.loop

unreachable7:                                     ; No predecessors!
  br label %if.done8

if.done8:                                         ; preds = %unreachable7, %if.done4
  %47 = load i8, ptr %x, align 1
  %48 = lshr i8 %47, 4
  %49 = select i1 true, i8 %48, i8 0
  %50 = zext i8 %49 to i64
  %51 = getelementptr [5 x %"utf8::Accept_Range"], ptr @"utf8::accept_ranges", i64 0, i64 %50
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1fa", i64 41 }, i32 345, i32 23, i64 %50, i64 5)
  %52 = load %"utf8::Accept_Range", ptr %51, align 1
  store %"utf8::Accept_Range" %52, ptr %ar, align 1
  br label %if.init

if.init:                                          ; preds = %if.done8
  %53 = extractvalue { ptr, i64 } %0, 0
  %54 = load i64, ptr %i, align 8
  %55 = add i64 %54, 1
  %56 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1fa", i64 41 }, i32 346, i32 13, i64 %55, i64 %56)
  %57 = getelementptr i8, ptr %53, i64 %55
  %58 = load i8, ptr %57, align 1
  store i8 %58, ptr %b, align 1
  %59 = load i8, ptr %b, align 1
  %60 = getelementptr inbounds nuw %"utf8::Accept_Range", ptr %ar, i32 0, i32 0
  %61 = load i8, ptr %60, align 1
  %62 = icmp ult i8 %59, %61
  %63 = zext i1 %62 to i8
  %64 = icmp ne i8 %63, 0
  br i1 %64, label %if.then9, label %cmp.or

cmp.or:                                           ; preds = %if.init
  %65 = getelementptr inbounds nuw %"utf8::Accept_Range", ptr %ar, i32 0, i32 1
  %66 = load i8, ptr %65, align 1
  %67 = load i8, ptr %b, align 1
  %68 = icmp ult i8 %66, %67
  %69 = zext i1 %68 to i8
  %70 = icmp ne i8 %69, 0
  br i1 %70, label %if.then9, label %if.else

if.then9:                                         ; preds = %cmp.or, %if.init
  store i64 1, ptr %size, align 8
  br label %if.done25

if.else:                                          ; preds = %cmp.or
  %71 = load i64, ptr %size, align 8
  %72 = icmp eq i64 %71, 2
  %73 = zext i1 %72 to i8
  %74 = icmp ne i8 %73, 0
  br i1 %74, label %if.then10, label %if.else11

if.then10:                                        ; preds = %if.else
  br label %if.done24

if.else11:                                        ; preds = %if.else
  br label %if.init12

if.init12:                                        ; preds = %if.else11
  %75 = extractvalue { ptr, i64 } %0, 0
  %76 = load i64, ptr %i, align 8
  %77 = add i64 %76, 2
  %78 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1fa", i64 41 }, i32 350, i32 20, i64 %77, i64 %78)
  %79 = getelementptr i8, ptr %75, i64 %77
  %80 = load i8, ptr %79, align 1
  store i8 %80, ptr %c, align 1
  %81 = load i8, ptr %c, align 1
  %82 = icmp ult i8 %81, -128
  %83 = zext i1 %82 to i8
  %84 = icmp ne i8 %83, 0
  br i1 %84, label %if.then14, label %cmp.or13

cmp.or13:                                         ; preds = %if.init12
  %85 = load i8, ptr %c, align 1
  %86 = icmp ult i8 -65, %85
  %87 = zext i1 %86 to i8
  %88 = icmp ne i8 %87, 0
  br i1 %88, label %if.then14, label %if.else15

if.then14:                                        ; preds = %cmp.or13, %if.init12
  store i64 1, ptr %size, align 8
  br label %if.done23

if.else15:                                        ; preds = %cmp.or13
  %89 = load i64, ptr %size, align 8
  %90 = icmp eq i64 %89, 3
  %91 = zext i1 %90 to i8
  %92 = icmp ne i8 %91, 0
  br i1 %92, label %if.then16, label %if.else17

if.then16:                                        ; preds = %if.else15
  br label %if.done22

if.else17:                                        ; preds = %if.else15
  br label %if.init18

if.init18:                                        ; preds = %if.else17
  %93 = extractvalue { ptr, i64 } %0, 0
  %94 = load i64, ptr %i, align 8
  %95 = add i64 %94, 3
  %96 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$1fa", i64 41 }, i32 354, i32 20, i64 %95, i64 %96)
  %97 = getelementptr i8, ptr %93, i64 %95
  %98 = load i8, ptr %97, align 1
  store i8 %98, ptr %d, align 1
  %99 = load i8, ptr %d, align 1
  %100 = icmp ult i8 %99, -128
  %101 = zext i1 %100 to i8
  %102 = icmp ne i8 %101, 0
  br i1 %102, label %if.then20, label %cmp.or19

cmp.or19:                                         ; preds = %if.init18
  %103 = load i8, ptr %d, align 1
  %104 = icmp ult i8 -65, %103
  %105 = zext i1 %104 to i8
  %106 = icmp ne i8 %105, 0
  br i1 %106, label %if.then20, label %if.done21

if.then20:                                        ; preds = %cmp.or19, %if.init18
  store i64 1, ptr %size, align 8
  br label %if.done21

if.done21:                                        ; preds = %if.then20, %cmp.or19
  br label %if.done22

if.done22:                                        ; preds = %if.done21, %if.then16
  br label %if.done23

if.done23:                                        ; preds = %if.done22, %if.then14
  br label %if.done24

if.done24:                                        ; preds = %if.done23, %if.then10
  br label %if.done25

if.done25:                                        ; preds = %if.done24, %if.then9
  %107 = load i64, ptr %size, align 8
  %108 = load i64, ptr %i, align 8
  %109 = add i64 %108, %107
  store i64 %109, ptr %i, align 8
  br label %defer26

defer26:                                          ; preds = %if.done25
  %110 = load i64, ptr %count, align 8
  %111 = add i64 %110, 1
  store i64 %111, ptr %count, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %112 = load i64, ptr %count, align 8
  ret i64 %112
}

define internal i64 @"bytes::index_byte"({ ptr, i64 } %0, i8 %1) {
decls:
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca i8, align 1
  %index = alloca i64, align 8
  %i = alloca i64, align 8
  %l = alloca i64, align 8
  %c_vec = alloca <16 x i8>, align 16
  %s_vecs = alloca [4 x <16 x i8>], align 16
  %c_vecs = alloca [4 x <16 x i8>], align 16
  %m_vecs = alloca [4 x i8], align 1
  %nr_blocks = alloca i64, align 8
  %j = alloca i64, align 8
  %4 = alloca { ptr, i64 }, align 8
  %5 = alloca { ptr, i64 }, align 8
  %6 = alloca { ptr, i64 }, align 8
  %7 = alloca { ptr, i64 }, align 8
  %j6 = alloca i64, align 8
  %sel = alloca <16 x i8>, align 16
  %off = alloca i8, align 1
  %sel10 = alloca <16 x i8>, align 16
  %off11 = alloca i8, align 1
  %sel14 = alloca <16 x i8>, align 16
  %off15 = alloca i8, align 1
  %sel18 = alloca <16 x i8>, align 16
  %off19 = alloca i8, align 1
  %nr_blocks25 = alloca i64, align 8
  %8 = alloca { ptr, i64 }, align 8
  %s0 = alloca <16 x i8>, align 16
  %c0 = alloca <16 x i8>, align 16
  %sel29 = alloca <16 x i8>, align 16
  %off30 = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %2, align 8
  store i8 %1, ptr %3, align 1
  store i64 0, ptr %index, align 8
  %9 = extractvalue { ptr, i64 } %0, 1
  store i64 0, ptr %i, align 8
  store i64 %9, ptr %l, align 8
  %10 = load i64, ptr %l, align 8
  %11 = icmp slt i64 %10, 16
  %12 = zext i1 %11 to i8
  %13 = icmp ne i8 %12, 0
  br i1 %13, label %if.then, label %if.done2

if.then:                                          ; preds = %entry
  br label %for.loop

for.loop:                                         ; preds = %for.post, %if.then
  %14 = load i64, ptr %i, align 8
  %15 = load i64, ptr %l, align 8
  %16 = icmp slt i64 %14, %15
  %17 = zext i1 %16 to i8
  %18 = icmp ne i8 %17, 0
  br i1 %18, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %19 = extractvalue { ptr, i64 } %0, 0
  %20 = load i64, ptr %i, align 8
  %21 = extractvalue { ptr, i64 } %0, 1
  %22 = getelementptr i8, ptr %19, i64 %20
  %23 = load i8, ptr %22, align 1
  %24 = icmp eq i8 %23, %1
  %25 = zext i1 %24 to i8
  %26 = icmp ne i8 %25, 0
  br i1 %26, label %if.then1, label %if.done

if.then1:                                         ; preds = %for.body
  %27 = load i64, ptr %i, align 8
  store i64 %27, ptr %index, align 8
  ret i64 %27

if.done:                                          ; preds = %for.body
  br label %for.post

for.post:                                         ; preds = %if.done
  %28 = load i64, ptr %i, align 8
  %29 = add i64 %28, 1
  store i64 %29, ptr %i, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  store i64 -1, ptr %index, align 8
  ret i64 -1

if.done2:                                         ; preds = %entry
  %30 = insertelement <16 x i8> zeroinitializer, i8 %1, i32 0
  %31 = insertelement <16 x i8> %30, i8 %1, i32 1
  %32 = insertelement <16 x i8> %31, i8 %1, i32 2
  %33 = insertelement <16 x i8> %32, i8 %1, i32 3
  %34 = insertelement <16 x i8> %33, i8 %1, i32 4
  %35 = insertelement <16 x i8> %34, i8 %1, i32 5
  %36 = insertelement <16 x i8> %35, i8 %1, i32 6
  %37 = insertelement <16 x i8> %36, i8 %1, i32 7
  %38 = insertelement <16 x i8> %37, i8 %1, i32 8
  %39 = insertelement <16 x i8> %38, i8 %1, i32 9
  %40 = insertelement <16 x i8> %39, i8 %1, i32 10
  %41 = insertelement <16 x i8> %40, i8 %1, i32 11
  %42 = insertelement <16 x i8> %41, i8 %1, i32 12
  %43 = insertelement <16 x i8> %42, i8 %1, i32 13
  %44 = insertelement <16 x i8> %43, i8 %1, i32 14
  %45 = insertelement <16 x i8> %44, i8 %1, i32 15
  store <16 x i8> %45, ptr %c_vec, align 16
  br label %for.init

for.init:                                         ; preds = %if.done2
  %46 = load i64, ptr %l, align 8
  %47 = sdiv i64 %46, 64
  store i64 %47, ptr %nr_blocks, align 8
  br label %for.loop3

for.loop3:                                        ; preds = %for.post22, %for.init
  %48 = load i64, ptr %nr_blocks, align 8
  %49 = icmp sgt i64 %48, 0
  %50 = zext i1 %49 to i8
  %51 = icmp ne i8 %50, 0
  br i1 %51, label %for.body4, label %for.done23

for.body4:                                        ; preds = %for.loop3
  store i64 0, ptr %j, align 8
  store i64 0, ptr %j, align 8
  %52 = load i64, ptr %j, align 8
  %53 = getelementptr [4 x <16 x i8>], ptr %s_vecs, i64 0, i64 %52
  %54 = load { ptr, i64 }, ptr %2, align 8
  %55 = load i64, ptr %i, align 8
  %56 = load i64, ptr %j, align 8
  %57 = mul i64 %56, 16
  %58 = add i64 %55, %57
  %59 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  %60 = load i64, ptr %59, align 8
  %61 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  %62 = load ptr, ptr %61, align 8
  %63 = getelementptr i8, ptr %62, i64 %58
  %64 = sub i64 %60, %58
  %65 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 0
  store ptr %63, ptr %65, align 8
  %66 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 1
  store i64 %64, ptr %66, align 8
  %67 = load { ptr, i64 }, ptr %4, align 8
  %68 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 0
  %69 = load ptr, ptr %68, align 8
  %70 = load <16 x i8>, ptr %69, align 1
  store <16 x i8> %70, ptr %53, align 16
  %71 = load i64, ptr %j, align 8
  %72 = getelementptr [4 x <16 x i8>], ptr %c_vecs, i64 0, i64 %71
  %73 = load i64, ptr %j, align 8
  %74 = getelementptr [4 x <16 x i8>], ptr %s_vecs, i64 0, i64 %73
  %75 = load <16 x i8>, ptr %74, align 16
  %76 = load <16 x i8>, ptr %c_vec, align 16
  %77 = icmp eq <16 x i8> %75, %76
  %78 = sext <16 x i1> %77 to <16 x i8>
  store <16 x i8> %78, ptr %72, align 16
  %79 = load i64, ptr %j, align 8
  %80 = getelementptr [4 x i8], ptr %m_vecs, i64 0, i64 %79
  %81 = load i64, ptr %j, align 8
  %82 = getelementptr [4 x <16 x i8>], ptr %c_vecs, i64 0, i64 %81
  %83 = load <16 x i8>, ptr %82, align 16
  %84 = call i8 @llvm.vector.reduce.or.v16i8(<16 x i8> %83)
  store i8 %84, ptr %80, align 1
  store i64 1, ptr %j, align 8
  %85 = load i64, ptr %j, align 8
  %86 = getelementptr [4 x <16 x i8>], ptr %s_vecs, i64 0, i64 %85
  %87 = load { ptr, i64 }, ptr %2, align 8
  %88 = load i64, ptr %i, align 8
  %89 = load i64, ptr %j, align 8
  %90 = mul i64 %89, 16
  %91 = add i64 %88, %90
  %92 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  %93 = load i64, ptr %92, align 8
  %94 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  %95 = load ptr, ptr %94, align 8
  %96 = getelementptr i8, ptr %95, i64 %91
  %97 = sub i64 %93, %91
  %98 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 0
  store ptr %96, ptr %98, align 8
  %99 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 1
  store i64 %97, ptr %99, align 8
  %100 = load { ptr, i64 }, ptr %5, align 8
  %101 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 0
  %102 = load ptr, ptr %101, align 8
  %103 = load <16 x i8>, ptr %102, align 1
  store <16 x i8> %103, ptr %86, align 16
  %104 = load i64, ptr %j, align 8
  %105 = getelementptr [4 x <16 x i8>], ptr %c_vecs, i64 0, i64 %104
  %106 = load i64, ptr %j, align 8
  %107 = getelementptr [4 x <16 x i8>], ptr %s_vecs, i64 0, i64 %106
  %108 = load <16 x i8>, ptr %107, align 16
  %109 = load <16 x i8>, ptr %c_vec, align 16
  %110 = icmp eq <16 x i8> %108, %109
  %111 = sext <16 x i1> %110 to <16 x i8>
  store <16 x i8> %111, ptr %105, align 16
  %112 = load i64, ptr %j, align 8
  %113 = getelementptr [4 x i8], ptr %m_vecs, i64 0, i64 %112
  %114 = load i64, ptr %j, align 8
  %115 = getelementptr [4 x <16 x i8>], ptr %c_vecs, i64 0, i64 %114
  %116 = load <16 x i8>, ptr %115, align 16
  %117 = call i8 @llvm.vector.reduce.or.v16i8(<16 x i8> %116)
  store i8 %117, ptr %113, align 1
  store i64 2, ptr %j, align 8
  %118 = load i64, ptr %j, align 8
  %119 = getelementptr [4 x <16 x i8>], ptr %s_vecs, i64 0, i64 %118
  %120 = load { ptr, i64 }, ptr %2, align 8
  %121 = load i64, ptr %i, align 8
  %122 = load i64, ptr %j, align 8
  %123 = mul i64 %122, 16
  %124 = add i64 %121, %123
  %125 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  %126 = load i64, ptr %125, align 8
  %127 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  %128 = load ptr, ptr %127, align 8
  %129 = getelementptr i8, ptr %128, i64 %124
  %130 = sub i64 %126, %124
  %131 = getelementptr inbounds nuw { ptr, i64 }, ptr %6, i32 0, i32 0
  store ptr %129, ptr %131, align 8
  %132 = getelementptr inbounds nuw { ptr, i64 }, ptr %6, i32 0, i32 1
  store i64 %130, ptr %132, align 8
  %133 = load { ptr, i64 }, ptr %6, align 8
  %134 = getelementptr inbounds nuw { ptr, i64 }, ptr %6, i32 0, i32 0
  %135 = load ptr, ptr %134, align 8
  %136 = load <16 x i8>, ptr %135, align 1
  store <16 x i8> %136, ptr %119, align 16
  %137 = load i64, ptr %j, align 8
  %138 = getelementptr [4 x <16 x i8>], ptr %c_vecs, i64 0, i64 %137
  %139 = load i64, ptr %j, align 8
  %140 = getelementptr [4 x <16 x i8>], ptr %s_vecs, i64 0, i64 %139
  %141 = load <16 x i8>, ptr %140, align 16
  %142 = load <16 x i8>, ptr %c_vec, align 16
  %143 = icmp eq <16 x i8> %141, %142
  %144 = sext <16 x i1> %143 to <16 x i8>
  store <16 x i8> %144, ptr %138, align 16
  %145 = load i64, ptr %j, align 8
  %146 = getelementptr [4 x i8], ptr %m_vecs, i64 0, i64 %145
  %147 = load i64, ptr %j, align 8
  %148 = getelementptr [4 x <16 x i8>], ptr %c_vecs, i64 0, i64 %147
  %149 = load <16 x i8>, ptr %148, align 16
  %150 = call i8 @llvm.vector.reduce.or.v16i8(<16 x i8> %149)
  store i8 %150, ptr %146, align 1
  store i64 3, ptr %j, align 8
  %151 = load i64, ptr %j, align 8
  %152 = getelementptr [4 x <16 x i8>], ptr %s_vecs, i64 0, i64 %151
  %153 = load { ptr, i64 }, ptr %2, align 8
  %154 = load i64, ptr %i, align 8
  %155 = load i64, ptr %j, align 8
  %156 = mul i64 %155, 16
  %157 = add i64 %154, %156
  %158 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  %159 = load i64, ptr %158, align 8
  %160 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  %161 = load ptr, ptr %160, align 8
  %162 = getelementptr i8, ptr %161, i64 %157
  %163 = sub i64 %159, %157
  %164 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 0
  store ptr %162, ptr %164, align 8
  %165 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 1
  store i64 %163, ptr %165, align 8
  %166 = load { ptr, i64 }, ptr %7, align 8
  %167 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 0
  %168 = load ptr, ptr %167, align 8
  %169 = load <16 x i8>, ptr %168, align 1
  store <16 x i8> %169, ptr %152, align 16
  %170 = load i64, ptr %j, align 8
  %171 = getelementptr [4 x <16 x i8>], ptr %c_vecs, i64 0, i64 %170
  %172 = load i64, ptr %j, align 8
  %173 = getelementptr [4 x <16 x i8>], ptr %s_vecs, i64 0, i64 %172
  %174 = load <16 x i8>, ptr %173, align 16
  %175 = load <16 x i8>, ptr %c_vec, align 16
  %176 = icmp eq <16 x i8> %174, %175
  %177 = sext <16 x i1> %176 to <16 x i8>
  store <16 x i8> %177, ptr %171, align 16
  %178 = load i64, ptr %j, align 8
  %179 = getelementptr [4 x i8], ptr %m_vecs, i64 0, i64 %178
  %180 = load i64, ptr %j, align 8
  %181 = getelementptr [4 x <16 x i8>], ptr %c_vecs, i64 0, i64 %180
  %182 = load <16 x i8>, ptr %181, align 16
  %183 = call i8 @llvm.vector.reduce.or.v16i8(<16 x i8> %182)
  store i8 %183, ptr %179, align 1
  %184 = getelementptr [4 x i8], ptr %m_vecs, i64 0, i64 0
  %185 = load i8, ptr %184, align 1
  %186 = getelementptr [4 x i8], ptr %m_vecs, i64 0, i64 1
  %187 = load i8, ptr %186, align 1
  %188 = or i8 %185, %187
  %189 = getelementptr [4 x i8], ptr %m_vecs, i64 0, i64 2
  %190 = load i8, ptr %189, align 1
  %191 = or i8 %188, %190
  %192 = getelementptr [4 x i8], ptr %m_vecs, i64 0, i64 3
  %193 = load i8, ptr %192, align 1
  %194 = or i8 %191, %193
  %195 = icmp ugt i8 %194, 0
  %196 = zext i1 %195 to i8
  %197 = icmp ne i8 %196, 0
  br i1 %197, label %if.then5, label %if.done21

if.then5:                                         ; preds = %for.body4
  store i64 0, ptr %j6, align 8
  store i64 0, ptr %j6, align 8
  %198 = load i64, ptr %j6, align 8
  %199 = getelementptr [4 x i8], ptr %m_vecs, i64 0, i64 %198
  %200 = load i8, ptr %199, align 1
  %201 = icmp ugt i8 %200, 0
  %202 = zext i1 %201 to i8
  %203 = icmp ne i8 %202, 0
  br i1 %203, label %if.then7, label %if.done8

if.then7:                                         ; preds = %if.then5
  %204 = load i64, ptr %j6, align 8
  %205 = getelementptr [4 x <16 x i8>], ptr %c_vecs, i64 0, i64 %204
  %206 = load <16 x i8>, ptr %205, align 16
  %207 = icmp ne <16 x i8> %206, zeroinitializer
  %208 = select <16 x i1> %207, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 4, i8 5, i8 6, i8 7, i8 8, i8 9, i8 10, i8 11, i8 12, i8 13, i8 14, i8 15>, <16 x i8> splat (i8 -1)
  store <16 x i8> %208, ptr %sel, align 16
  %209 = load <16 x i8>, ptr %sel, align 16
  %210 = call i8 @llvm.vector.reduce.umin.v16i8(<16 x i8> %209)
  store i8 %210, ptr %off, align 1
  %211 = load i64, ptr %i, align 8
  %212 = load i64, ptr %j6, align 8
  %213 = mul i64 %212, 16
  %214 = add i64 %211, %213
  %215 = load i8, ptr %off, align 1
  %216 = zext i8 %215 to i64
  %217 = add i64 %214, %216
  store i64 %217, ptr %index, align 8
  ret i64 %217

if.done8:                                         ; preds = %if.then5
  store i64 1, ptr %j6, align 8
  %218 = load i64, ptr %j6, align 8
  %219 = getelementptr [4 x i8], ptr %m_vecs, i64 0, i64 %218
  %220 = load i8, ptr %219, align 1
  %221 = icmp ugt i8 %220, 0
  %222 = zext i1 %221 to i8
  %223 = icmp ne i8 %222, 0
  br i1 %223, label %if.then9, label %if.done12

if.then9:                                         ; preds = %if.done8
  %224 = load i64, ptr %j6, align 8
  %225 = getelementptr [4 x <16 x i8>], ptr %c_vecs, i64 0, i64 %224
  %226 = load <16 x i8>, ptr %225, align 16
  %227 = icmp ne <16 x i8> %226, zeroinitializer
  %228 = select <16 x i1> %227, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 4, i8 5, i8 6, i8 7, i8 8, i8 9, i8 10, i8 11, i8 12, i8 13, i8 14, i8 15>, <16 x i8> splat (i8 -1)
  store <16 x i8> %228, ptr %sel10, align 16
  %229 = load <16 x i8>, ptr %sel10, align 16
  %230 = call i8 @llvm.vector.reduce.umin.v16i8(<16 x i8> %229)
  store i8 %230, ptr %off11, align 1
  %231 = load i64, ptr %i, align 8
  %232 = load i64, ptr %j6, align 8
  %233 = mul i64 %232, 16
  %234 = add i64 %231, %233
  %235 = load i8, ptr %off11, align 1
  %236 = zext i8 %235 to i64
  %237 = add i64 %234, %236
  store i64 %237, ptr %index, align 8
  ret i64 %237

if.done12:                                        ; preds = %if.done8
  store i64 2, ptr %j6, align 8
  %238 = load i64, ptr %j6, align 8
  %239 = getelementptr [4 x i8], ptr %m_vecs, i64 0, i64 %238
  %240 = load i8, ptr %239, align 1
  %241 = icmp ugt i8 %240, 0
  %242 = zext i1 %241 to i8
  %243 = icmp ne i8 %242, 0
  br i1 %243, label %if.then13, label %if.done16

if.then13:                                        ; preds = %if.done12
  %244 = load i64, ptr %j6, align 8
  %245 = getelementptr [4 x <16 x i8>], ptr %c_vecs, i64 0, i64 %244
  %246 = load <16 x i8>, ptr %245, align 16
  %247 = icmp ne <16 x i8> %246, zeroinitializer
  %248 = select <16 x i1> %247, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 4, i8 5, i8 6, i8 7, i8 8, i8 9, i8 10, i8 11, i8 12, i8 13, i8 14, i8 15>, <16 x i8> splat (i8 -1)
  store <16 x i8> %248, ptr %sel14, align 16
  %249 = load <16 x i8>, ptr %sel14, align 16
  %250 = call i8 @llvm.vector.reduce.umin.v16i8(<16 x i8> %249)
  store i8 %250, ptr %off15, align 1
  %251 = load i64, ptr %i, align 8
  %252 = load i64, ptr %j6, align 8
  %253 = mul i64 %252, 16
  %254 = add i64 %251, %253
  %255 = load i8, ptr %off15, align 1
  %256 = zext i8 %255 to i64
  %257 = add i64 %254, %256
  store i64 %257, ptr %index, align 8
  ret i64 %257

if.done16:                                        ; preds = %if.done12
  store i64 3, ptr %j6, align 8
  %258 = load i64, ptr %j6, align 8
  %259 = getelementptr [4 x i8], ptr %m_vecs, i64 0, i64 %258
  %260 = load i8, ptr %259, align 1
  %261 = icmp ugt i8 %260, 0
  %262 = zext i1 %261 to i8
  %263 = icmp ne i8 %262, 0
  br i1 %263, label %if.then17, label %if.done20

if.then17:                                        ; preds = %if.done16
  %264 = load i64, ptr %j6, align 8
  %265 = getelementptr [4 x <16 x i8>], ptr %c_vecs, i64 0, i64 %264
  %266 = load <16 x i8>, ptr %265, align 16
  %267 = icmp ne <16 x i8> %266, zeroinitializer
  %268 = select <16 x i1> %267, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 4, i8 5, i8 6, i8 7, i8 8, i8 9, i8 10, i8 11, i8 12, i8 13, i8 14, i8 15>, <16 x i8> splat (i8 -1)
  store <16 x i8> %268, ptr %sel18, align 16
  %269 = load <16 x i8>, ptr %sel18, align 16
  %270 = call i8 @llvm.vector.reduce.umin.v16i8(<16 x i8> %269)
  store i8 %270, ptr %off19, align 1
  %271 = load i64, ptr %i, align 8
  %272 = load i64, ptr %j6, align 8
  %273 = mul i64 %272, 16
  %274 = add i64 %271, %273
  %275 = load i8, ptr %off19, align 1
  %276 = zext i8 %275 to i64
  %277 = add i64 %274, %276
  store i64 %277, ptr %index, align 8
  ret i64 %277

if.done20:                                        ; preds = %if.done16
  br label %if.done21

if.done21:                                        ; preds = %if.done20, %for.body4
  %278 = load i64, ptr %i, align 8
  %279 = add i64 %278, 64
  store i64 %279, ptr %i, align 8
  br label %for.post22

for.post22:                                       ; preds = %if.done21
  %280 = load i64, ptr %nr_blocks, align 8
  %281 = sub i64 %280, 1
  store i64 %281, ptr %nr_blocks, align 8
  br label %for.loop3

for.done23:                                       ; preds = %for.loop3
  br label %for.init24

for.init24:                                       ; preds = %for.done23
  %282 = load i64, ptr %l, align 8
  %283 = load i64, ptr %i, align 8
  %284 = sub i64 %282, %283
  %285 = sdiv i64 %284, 16
  store i64 %285, ptr %nr_blocks25, align 8
  br label %for.loop26

for.loop26:                                       ; preds = %for.post32, %for.init24
  %286 = load i64, ptr %nr_blocks25, align 8
  %287 = icmp sgt i64 %286, 0
  %288 = zext i1 %287 to i8
  %289 = icmp ne i8 %288, 0
  br i1 %289, label %for.body27, label %for.done33

for.body27:                                       ; preds = %for.loop26
  %290 = load { ptr, i64 }, ptr %2, align 8
  %291 = load i64, ptr %i, align 8
  %292 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  %293 = load i64, ptr %292, align 8
  %294 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  %295 = load ptr, ptr %294, align 8
  %296 = getelementptr i8, ptr %295, i64 %291
  %297 = sub i64 %293, %291
  %298 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 0
  store ptr %296, ptr %298, align 8
  %299 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 1
  store i64 %297, ptr %299, align 8
  %300 = load { ptr, i64 }, ptr %8, align 8
  %301 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 0
  %302 = load ptr, ptr %301, align 8
  %303 = load <16 x i8>, ptr %302, align 1
  store <16 x i8> %303, ptr %s0, align 16
  %304 = load <16 x i8>, ptr %s0, align 16
  %305 = load <16 x i8>, ptr %c_vec, align 16
  %306 = icmp eq <16 x i8> %304, %305
  %307 = sext <16 x i1> %306 to <16 x i8>
  store <16 x i8> %307, ptr %c0, align 16
  %308 = load <16 x i8>, ptr %c0, align 16
  %309 = call i8 @llvm.vector.reduce.or.v16i8(<16 x i8> %308)
  %310 = icmp ugt i8 %309, 0
  %311 = zext i1 %310 to i8
  %312 = icmp ne i8 %311, 0
  br i1 %312, label %if.then28, label %if.done31

if.then28:                                        ; preds = %for.body27
  %313 = load <16 x i8>, ptr %c0, align 16
  %314 = icmp ne <16 x i8> %313, zeroinitializer
  %315 = select <16 x i1> %314, <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 4, i8 5, i8 6, i8 7, i8 8, i8 9, i8 10, i8 11, i8 12, i8 13, i8 14, i8 15>, <16 x i8> splat (i8 -1)
  store <16 x i8> %315, ptr %sel29, align 16
  %316 = load <16 x i8>, ptr %sel29, align 16
  %317 = call i8 @llvm.vector.reduce.umin.v16i8(<16 x i8> %316)
  store i8 %317, ptr %off30, align 1
  %318 = load i64, ptr %i, align 8
  %319 = load i8, ptr %off30, align 1
  %320 = zext i8 %319 to i64
  %321 = add i64 %318, %320
  store i64 %321, ptr %index, align 8
  ret i64 %321

if.done31:                                        ; preds = %for.body27
  %322 = load i64, ptr %i, align 8
  %323 = add i64 %322, 16
  store i64 %323, ptr %i, align 8
  br label %for.post32

for.post32:                                       ; preds = %if.done31
  %324 = load i64, ptr %nr_blocks25, align 8
  %325 = sub i64 %324, 1
  store i64 %325, ptr %nr_blocks25, align 8
  br label %for.loop26

for.done33:                                       ; preds = %for.loop26
  br label %for.loop34

for.loop34:                                       ; preds = %for.post38, %for.done33
  %326 = load i64, ptr %i, align 8
  %327 = load i64, ptr %l, align 8
  %328 = icmp slt i64 %326, %327
  %329 = zext i1 %328 to i8
  %330 = icmp ne i8 %329, 0
  br i1 %330, label %for.body35, label %for.done39

for.body35:                                       ; preds = %for.loop34
  %331 = extractvalue { ptr, i64 } %0, 0
  %332 = load i64, ptr %i, align 8
  %333 = extractvalue { ptr, i64 } %0, 1
  %334 = getelementptr i8, ptr %331, i64 %332
  %335 = load i8, ptr %334, align 1
  %336 = icmp eq i8 %335, %1
  %337 = zext i1 %336 to i8
  %338 = icmp ne i8 %337, 0
  br i1 %338, label %if.then36, label %if.done37

if.then36:                                        ; preds = %for.body35
  %339 = load i64, ptr %i, align 8
  store i64 %339, ptr %index, align 8
  ret i64 %339

if.done37:                                        ; preds = %for.body35
  br label %for.post38

for.post38:                                       ; preds = %if.done37
  %340 = load i64, ptr %i, align 8
  %341 = add i64 %340, 1
  store i64 %341, ptr %i, align 8
  br label %for.loop34

for.done39:                                       ; preds = %for.loop34
  store i64 -1, ptr %index, align 8
  ret i64 -1
}

define internal i8 @"runtime::mem_resize"(ptr %0, i64 %1, i64 %2, i64 %3, { i64, i64 } %4, ptr %5, ptr noalias nonnull %6, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %7 = alloca ptr, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca %"runtime::Allocator", align 16
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %12 = alloca { i64, i64 }, align 16
  %13 = alloca { ptr, i64 }, align 8
  %14 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %7, align 8
  store i64 %1, ptr %8, align 8
  store i64 %2, ptr %9, align 8
  store i64 %3, ptr %10, align 8
  store { i64, i64 } %4, ptr %11, align 8
  %15 = load %"runtime::Allocator", ptr %11, align 8
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %16 = call i8 @"runtime::is_power_of_two_int"(i64 %3)
  %17 = load %"runtime::Source_Code_Location", ptr %5, align 8
  call void @"runtime::assert"(i8 %16, %..string { ptr @"csbs$byte_world$1fb", i64 32 }, ptr %5, ptr %__.context_ptr)
  %18 = load %"runtime::Source_Code_Location", ptr %5, align 8
  store %"runtime::Allocator" %15, ptr %12, align 8
  %19 = load { i64, i64 }, ptr %12, align 8
  call void @llvm.memset.inline.p0.i64(ptr %13, i8 0, i64 16, i1 false)
  %20 = call i8 @"runtime::_mem_resize"(ptr %0, i64 %1, i64 %2, i64 %3, { i64, i64 } %19, i8 1, ptr %5, ptr %13, ptr %__.context_ptr)
  %21 = load { ptr, i64 }, ptr %13, align 8
  %22 = load { { ptr, i64 }, i8 }, ptr %14, align 8
  store { ptr, i64 } %21, ptr %data, align 8
  store i8 %20, ptr %err, align 1
  store { ptr, i64 } %21, ptr %6, align 8
  ret i8 %20
}

define internal %..string @"fmt::tprintf"(%..string %0, { ptr, i64 } %1, i8 %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca %..string, align 8
  %4 = alloca { ptr, i64 }, align 8
  %5 = alloca i8, align 1
  %str = alloca %"strings::Builder", align 8
  %6 = alloca { i64, i64 }, align 16
  %7 = alloca ptr, align 8
  %8 = alloca { ptr, i8 }, align 8
  %9 = alloca %..string, align 8
  br label %entry

entry:                                            ; preds = %decls
  store %..string %0, ptr %3, align 8
  store { ptr, i64 } %1, ptr %4, align 8
  store i8 %2, ptr %5, align 1
  call void @llvm.memset.p0.i64(ptr %str, i8 0, i64 40, i1 false)
  %10 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 1
  %11 = load %"runtime::Allocator", ptr %10, align 8
  %12 = load %"runtime::Source_Code_Location", ptr @"scl$[tprintf6994]", align 8
  store %"runtime::Allocator" %11, ptr %6, align 8
  %13 = load { i64, i64 }, ptr %6, align 8
  store ptr null, ptr %7, align 8
  %14 = call i8 @"strings::builder_init_none"(ptr %str, { i64, i64 } %13, ptr @"scl$[tprintf6994]", ptr %7, ptr %__.context_ptr)
  %15 = load ptr, ptr %7, align 8
  %16 = load { ptr, i8 }, ptr %8, align 8
  %17 = call %..string @"fmt::sbprintf"(ptr %str, %..string %0, { ptr, i64 } %1, i8 %2, ptr %__.context_ptr)
  store %..string %17, ptr %9, align 8
  %18 = load %..string, ptr %9, align 8
  ret %..string %18
}

declare i32 @pthread_create(ptr, ptr, ptr, ptr)

; Function Attrs: alwaysinline
define internal void @"runtime::make_slice_error_loc"(ptr %0, i64 %1) #3 {
decls:
  %2 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %1, ptr %2, align 8
  %3 = icmp sle i64 0, %1
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  %6 = load %"runtime::Source_Code_Location", ptr %0, align 8
  call void @"runtime::make_slice_error_loc.handle_error-0"(ptr %0, i64 %1)
  unreachable
}

define internal void @"strings::builder_from_bytes"(ptr noalias sret(%"strings::Builder") %agg.result, { ptr, i64 } %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca { ptr, i64 }, align 8
  %res = alloca %"strings::Builder", align 8
  %2 = alloca %"strings::Builder", align 8
  %3 = alloca { ptr, i64, i64, %"runtime::Allocator" }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %1, align 8
  call void @llvm.memset.p0.i64(ptr %res, i8 0, i64 40, i1 false)
  call void @llvm.memset.p0.i64(ptr %2, i8 0, i64 40, i1 false)
  call void @llvm.memset.p0.i64(ptr %2, i8 0, i64 40, i1 false)
  call void @llvm.memset.p0.i64(ptr %3, i8 0, i64 40, i1 false)
  call void @"mem::buffer_from_slice:proc\22contextless\22(backing:[]u8)->(:[dynamic]u8)"(ptr sret(ptr) %3, { ptr, i64 } %0)
  %4 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %3, align 8
  %5 = getelementptr inbounds nuw %"strings::Builder", ptr %2, i32 0, i32 0
  store { ptr, i64, i64, %"runtime::Allocator" } %4, ptr %5, align 8
  %6 = load %"strings::Builder", ptr %2, align 8
  store %"strings::Builder" %6, ptr %res, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %agg.result, ptr %2, i64 40, i1 false)
  ret void
}

define internal i32 @"io::write_byte"({ i64, i64 } %0, i8 %1, ptr %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca %"io::Stream", align 16
  %4 = alloca i8, align 1
  %5 = alloca ptr, align 8
  %buf = alloca [1 x i8], align 1
  %6 = alloca { ptr, i64 }, align 8
  %7 = alloca { i64, i64 }, align 16
  %8 = alloca i64, align 8
  %9 = alloca { i64, i32 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %3, align 8
  %10 = load %"io::Stream", ptr %3, align 8
  store i8 %1, ptr %4, align 1
  store ptr %2, ptr %5, align 8
  call void @llvm.memset.inline.p0.i64(ptr %buf, i8 0, i64 1, i1 false)
  %11 = getelementptr [1 x i8], ptr %buf, i64 0, i64 0
  store i8 %1, ptr %11, align 1
  %12 = load [1 x i8], ptr %buf, align 1
  %13 = getelementptr [1 x i8], ptr %buf, i64 0, i64 0
  %14 = getelementptr i8, ptr %13, i64 0
  %15 = getelementptr inbounds nuw { ptr, i64 }, ptr %6, i32 0, i32 0
  store ptr %14, ptr %15, align 8
  %16 = getelementptr inbounds nuw { ptr, i64 }, ptr %6, i32 0, i32 1
  store i64 1, ptr %16, align 8
  %17 = load { ptr, i64 }, ptr %6, align 8
  store %"io::Stream" %10, ptr %7, align 8
  %18 = load { i64, i64 }, ptr %7, align 8
  store i64 0, ptr %8, align 8
  %19 = call i32 @"io::write"({ i64, i64 } %18, { ptr, i64 } %17, ptr %2, ptr %8, ptr %__.context_ptr)
  %20 = load i64, ptr %8, align 8
  %21 = load { i64, i32 }, ptr %9, align 8
  %22 = icmp eq i32 %19, 0
  br i1 %22, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %entry
  ret i32 %19

or_return.continue:                               ; preds = %entry
  ret i32 0
}

define internal void @"mem::buffer_from_slice:proc\22contextless\22(backing:[]u8)->(:[dynamic]u8)"(ptr noalias sret({ ptr, i64, i64, %"runtime::Allocator" }) %agg.result, { ptr, i64 } %0) {
decls:
  %1 = alloca { ptr, i64 }, align 8
  %2 = alloca %"runtime::Raw_Dynamic_Array", align 8
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %1, align 8
  call void @llvm.memset.p0.i64(ptr %2, i8 0, i64 40, i1 false)
  store %"runtime::Raw_Dynamic_Array" { ptr null, i64 0, i64 0, %"runtime::Allocator" { ptr @"mem::nil_allocator_proc", ptr null } }, ptr %2, align 8
  %3 = extractvalue { ptr, i64 } %0, 0
  %4 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %2, i32 0, i32 0
  store ptr %3, ptr %4, align 8
  %5 = extractvalue { ptr, i64 } %0, 1
  %6 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %2, i32 0, i32 2
  store i64 %5, ptr %6, align 8
  %7 = load %"runtime::Raw_Dynamic_Array", ptr %2, align 8
  %8 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %2, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %agg.result, ptr %2, i64 40, i1 false)
  ret void
}

define internal i8 @"runtime::non_zero_mem_resize"(ptr %0, i64 %1, i64 %2, i64 %3, { i64, i64 } %4, ptr %5, ptr noalias nonnull %6, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %7 = alloca ptr, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca %"runtime::Allocator", align 16
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %12 = alloca { i64, i64 }, align 16
  %13 = alloca { ptr, i64 }, align 8
  %14 = alloca { { ptr, i64 }, i8 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %7, align 8
  store i64 %1, ptr %8, align 8
  store i64 %2, ptr %9, align 8
  store i64 %3, ptr %10, align 8
  store { i64, i64 } %4, ptr %11, align 8
  %15 = load %"runtime::Allocator", ptr %11, align 8
  call void @llvm.memset.inline.p0.i64(ptr %data, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %16 = call i8 @"runtime::is_power_of_two_int"(i64 %3)
  %17 = load %"runtime::Source_Code_Location", ptr %5, align 8
  call void @"runtime::assert"(i8 %16, %..string { ptr @"csbs$byte_world$1fb", i64 32 }, ptr %5, ptr %__.context_ptr)
  %18 = load %"runtime::Source_Code_Location", ptr %5, align 8
  store %"runtime::Allocator" %15, ptr %12, align 8
  %19 = load { i64, i64 }, ptr %12, align 8
  call void @llvm.memset.inline.p0.i64(ptr %13, i8 0, i64 16, i1 false)
  %20 = call i8 @"runtime::_mem_resize"(ptr %0, i64 %1, i64 %2, i64 %3, { i64, i64 } %19, i8 0, ptr %5, ptr %13, ptr %__.context_ptr)
  %21 = load { ptr, i64 }, ptr %13, align 8
  %22 = load { { ptr, i64 }, i8 }, ptr %14, align 8
  store { ptr, i64 } %21, ptr %data, align 8
  store i8 %20, ptr %err, align 1
  store { ptr, i64 } %21, ptr %6, align 8
  ret i8 %20
}

define internal i8 @"reflect::is_any"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca ptr, align 8
  %3 = alloca { i8, i8 }, align 1
  %ok = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %4 = icmp eq ptr %0, null
  %5 = zext i1 %4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  %7 = call ptr @"runtime::type_info_base"(ptr %0)
  store ptr %7, ptr %2, align 8
  %8 = load ptr, ptr %2, align 8
  %9 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %8, i32 0, i32 5
  %10 = load { [9 x i64], i64 }, ptr %9, align 8
  %11 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %9, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  %13 = icmp eq i64 %12, 9
  %14 = getelementptr inbounds nuw { i8, i8 }, ptr %3, i32 0, i32 1
  %15 = zext i1 %13 to i8
  store i8 %15, ptr %14, align 1
  %16 = load { i8, i8 }, ptr %3, align 1
  %17 = getelementptr inbounds nuw { i8, i8 }, ptr %3, i32 0, i32 0
  %18 = load i8, ptr %17, align 1
  %19 = getelementptr inbounds nuw { i8, i8 }, ptr %3, i32 0, i32 1
  %20 = load i8, ptr %19, align 1
  store i8 %20, ptr %ok, align 1
  %21 = load i8, ptr %ok, align 1
  ret i8 %21
}

declare i32 @pthread_detach(i64)

define internal i64 @"time::clock_from_time"(i64 %0, ptr noalias nonnull %1, ptr noalias nonnull %2) {
decls:
  %3 = alloca %"time::Time", align 16
  %hour = alloca i64, align 8
  %min = alloca i64, align 8
  %sec = alloca i64, align 8
  %4 = alloca i64, align 16
  %5 = alloca i64, align 8
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  %8 = alloca { i64, i64, i64, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %3, align 8
  %9 = load %"time::Time", ptr %3, align 8
  store i64 0, ptr %hour, align 8
  store i64 0, ptr %min, align 8
  store i64 0, ptr %sec, align 8
  store %"time::Time" %9, ptr %4, align 8
  %10 = load i64, ptr %4, align 8
  store i64 0, ptr %5, align 8
  store i64 0, ptr %6, align 8
  store i64 0, ptr %7, align 8
  %11 = call i64 @"time::precise_clock_from_time"(i64 %10, ptr %5, ptr %6, ptr %7)
  %12 = load i64, ptr %5, align 8
  %13 = load i64, ptr %6, align 8
  %14 = load i64, ptr %7, align 8
  %15 = load { i64, i64, i64, i64 }, ptr %8, align 8
  store i64 %12, ptr %hour, align 8
  store i64 %13, ptr %min, align 8
  store i64 %14, ptr %sec, align 8
  %16 = load i64, ptr %hour, align 8
  %17 = load i64, ptr %min, align 8
  %18 = load i64, ptr %sec, align 8
  store i64 %16, ptr %hour, align 8
  store i64 %17, ptr %min, align 8
  store i64 %18, ptr %sec, align 8
  store i64 %16, ptr %1, align 8
  store i64 %17, ptr %2, align 8
  ret i64 %18
}

define internal i32 @"io::write_quoted_string"({ i64, i64 } %0, %..string %1, i8 %2, ptr %3, i8 %4, ptr noalias nonnull %5, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %6 = alloca %"io::Stream", align 16
  %7 = alloca %..string, align 8
  %8 = alloca i8, align 1
  %9 = alloca ptr, align 8
  %10 = alloca i8, align 1
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  %11 = alloca { i64, i64 }, align 16
  %width = alloca i64, align 8
  %s = alloca %..string, align 8
  %r = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca { i32, i64 }, align 8
  %14 = alloca { i64, i64 }, align 16
  %15 = alloca { i64, i64 }, align 16
  %16 = alloca { i64, i64 }, align 16
  %17 = alloca { i64, i64 }, align 16
  %18 = alloca { i64, i64 }, align 16
  %19 = alloca i64, align 8
  %20 = alloca { i64, i32 }, align 8
  %21 = alloca %..string, align 8
  %22 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %6, align 8
  %23 = load %"io::Stream", ptr %6, align 8
  store %..string %1, ptr %7, align 8
  store i8 %2, ptr %8, align 1
  store ptr %3, ptr %9, align 8
  store i8 %4, ptr %10, align 1
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  store %"io::Stream" %23, ptr %11, align 8
  %24 = load { i64, i64 }, ptr %11, align 8
  %25 = call i32 @"io::write_byte"({ i64, i64 } %24, i8 %2, ptr %n, ptr %__.context_ptr)
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %entry
  store i32 %25, ptr %err, align 4
  %27 = load i64, ptr %n, align 8
  %28 = load i32, ptr %err, align 4
  store i64 %27, ptr %n, align 8
  store i32 %28, ptr %err, align 4
  store i64 %27, ptr %5, align 8
  br label %defer

defer:                                            ; preds = %or_return.return
  %29 = icmp ne ptr %3, null
  %30 = zext i1 %29 to i8
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %if.then, label %if.done

if.then:                                          ; preds = %defer
  %32 = load i64, ptr %n, align 8
  %33 = load i64, ptr %3, align 8
  %34 = add i64 %33, %32
  store i64 %34, ptr %3, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %defer
  ret i32 %28

or_return.continue:                               ; preds = %entry
  br label %for.init

for.init:                                         ; preds = %or_return.continue
  store i64 0, ptr %width, align 8
  store %..string %1, ptr %s, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %for.init
  %35 = load %..string, ptr %s, align 8
  %36 = getelementptr inbounds nuw %..string, ptr %s, i32 0, i32 1
  %37 = load i64, ptr %36, align 8
  %38 = icmp sgt i64 %37, 0
  %39 = zext i1 %38 to i8
  %40 = icmp ne i8 %39, 0
  br i1 %40, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %41 = load %..string, ptr %s, align 8
  %42 = getelementptr inbounds nuw %..string, ptr %s, i32 0, i32 0
  %43 = load ptr, ptr %42, align 8
  %44 = getelementptr inbounds nuw %..string, ptr %s, i32 0, i32 1
  %45 = load i64, ptr %44, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 264, i32 15, i64 0, i64 %45)
  %46 = getelementptr i8, ptr %43, i64 0
  %47 = load i8, ptr %46, align 1
  %48 = zext i8 %47 to i32
  store i32 %48, ptr %r, align 4
  store i64 1, ptr %width, align 8
  %49 = load i32, ptr %r, align 4
  %50 = icmp sge i32 %49, 128
  %51 = zext i1 %50 to i8
  %52 = icmp ne i8 %51, 0
  br i1 %52, label %if.then1, label %if.done2

if.then1:                                         ; preds = %for.body
  %53 = load %..string, ptr %s, align 8
  store i32 0, ptr %12, align 4
  %54 = call i64 @"utf8::decode_rune_in_string"(%..string %53, ptr %12)
  %55 = load i32, ptr %12, align 4
  %56 = load { i32, i64 }, ptr %13, align 8
  store i32 %55, ptr %r, align 4
  store i64 %54, ptr %width, align 8
  br label %if.done2

if.done2:                                         ; preds = %if.then1, %for.body
  %57 = load i64, ptr %width, align 8
  %58 = icmp eq i64 %57, 1
  %59 = zext i1 %58 to i8
  %60 = icmp ne i8 %59, 0
  br i1 %60, label %cmp.and, label %if.done24

cmp.and:                                          ; preds = %if.done2
  %61 = load i32, ptr %r, align 4
  %62 = icmp eq i32 %61, 65533
  %63 = zext i1 %62 to i8
  %64 = icmp ne i8 %63, 0
  br i1 %64, label %if.then3, label %if.done24

if.then3:                                         ; preds = %cmp.and
  store %"io::Stream" %23, ptr %14, align 8
  %65 = load { i64, i64 }, ptr %14, align 8
  %66 = call i32 @"io::write_byte"({ i64, i64 } %65, i8 92, ptr %n, ptr %__.context_ptr)
  %67 = icmp eq i32 %66, 0
  br i1 %67, label %or_return.continue8, label %or_return.return4

or_return.return4:                                ; preds = %if.then3
  store i32 %66, ptr %err, align 4
  %68 = load i64, ptr %n, align 8
  %69 = load i32, ptr %err, align 4
  store i64 %68, ptr %n, align 8
  store i32 %69, ptr %err, align 4
  store i64 %68, ptr %5, align 8
  br label %defer5

defer5:                                           ; preds = %or_return.return4
  %70 = icmp ne ptr %3, null
  %71 = zext i1 %70 to i8
  %72 = icmp ne i8 %71, 0
  br i1 %72, label %if.then6, label %if.done7

if.then6:                                         ; preds = %defer5
  %73 = load i64, ptr %n, align 8
  %74 = load i64, ptr %3, align 8
  %75 = add i64 %74, %73
  store i64 %75, ptr %3, align 8
  br label %if.done7

if.done7:                                         ; preds = %if.then6, %defer5
  ret i32 %69

or_return.continue8:                              ; preds = %if.then3
  store %"io::Stream" %23, ptr %15, align 8
  %76 = load { i64, i64 }, ptr %15, align 8
  %77 = call i32 @"io::write_byte"({ i64, i64 } %76, i8 120, ptr %n, ptr %__.context_ptr)
  %78 = icmp eq i32 %77, 0
  br i1 %78, label %or_return.continue13, label %or_return.return9

or_return.return9:                                ; preds = %or_return.continue8
  store i32 %77, ptr %err, align 4
  %79 = load i64, ptr %n, align 8
  %80 = load i32, ptr %err, align 4
  store i64 %79, ptr %n, align 8
  store i32 %80, ptr %err, align 4
  store i64 %79, ptr %5, align 8
  br label %defer10

defer10:                                          ; preds = %or_return.return9
  %81 = icmp ne ptr %3, null
  %82 = zext i1 %81 to i8
  %83 = icmp ne i8 %82, 0
  br i1 %83, label %if.then11, label %if.done12

if.then11:                                        ; preds = %defer10
  %84 = load i64, ptr %n, align 8
  %85 = load i64, ptr %3, align 8
  %86 = add i64 %85, %84
  store i64 %86, ptr %3, align 8
  br label %if.done12

if.done12:                                        ; preds = %if.then11, %defer10
  ret i32 %80

or_return.continue13:                             ; preds = %or_return.continue8
  %87 = load %..string, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %88 = load ptr, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %89 = load i64, ptr getelementptr (%..string, ptr @"io::[util.odin]::DIGITS_LOWER", i64 0, i32 1), align 8
  %90 = load %..string, ptr %s, align 8
  %91 = getelementptr inbounds nuw %..string, ptr %s, i32 0, i32 0
  %92 = load ptr, ptr %91, align 8
  %93 = getelementptr inbounds nuw %..string, ptr %s, i32 0, i32 1
  %94 = load i64, ptr %93, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 272, i32 33, i64 0, i64 %94)
  %95 = getelementptr i8, ptr %92, i64 0
  %96 = load i8, ptr %95, align 1
  %97 = lshr i8 %96, 4
  %98 = select i1 true, i8 %97, i8 0
  %99 = zext i8 %98 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 272, i32 31, i64 %99, i64 %89)
  %100 = getelementptr i8, ptr %88, i64 %99
  %101 = load i8, ptr %100, align 1
  store %"io::Stream" %23, ptr %16, align 8
  %102 = load { i64, i64 }, ptr %16, align 8
  %103 = call i32 @"io::write_byte"({ i64, i64 } %102, i8 %101, ptr %n, ptr %__.context_ptr)
  %104 = icmp eq i32 %103, 0
  br i1 %104, label %or_return.continue18, label %or_return.return14

or_return.return14:                               ; preds = %or_return.continue13
  store i32 %103, ptr %err, align 4
  %105 = load i64, ptr %n, align 8
  %106 = load i32, ptr %err, align 4
  store i64 %105, ptr %n, align 8
  store i32 %106, ptr %err, align 4
  store i64 %105, ptr %5, align 8
  br label %defer15

defer15:                                          ; preds = %or_return.return14
  %107 = icmp ne ptr %3, null
  %108 = zext i1 %107 to i8
  %109 = icmp ne i8 %108, 0
  br i1 %109, label %if.then16, label %if.done17

if.then16:                                        ; preds = %defer15
  %110 = load i64, ptr %n, align 8
  %111 = load i64, ptr %3, align 8
  %112 = add i64 %111, %110
  store i64 %112, ptr %3, align 8
  br label %if.done17

if.done17:                                        ; preds = %if.then16, %defer15
  ret i32 %106

or_return.continue18:                             ; preds = %or_return.continue13
  %113 = load %..string, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %114 = load ptr, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %115 = load i64, ptr getelementptr (%..string, ptr @"io::[util.odin]::DIGITS_LOWER", i64 0, i32 1), align 8
  %116 = load %..string, ptr %s, align 8
  %117 = getelementptr inbounds nuw %..string, ptr %s, i32 0, i32 0
  %118 = load ptr, ptr %117, align 8
  %119 = getelementptr inbounds nuw %..string, ptr %s, i32 0, i32 1
  %120 = load i64, ptr %119, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 273, i32 33, i64 0, i64 %120)
  %121 = getelementptr i8, ptr %118, i64 0
  %122 = load i8, ptr %121, align 1
  %123 = and i8 %122, 15
  %124 = zext i8 %123 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 273, i32 31, i64 %124, i64 %115)
  %125 = getelementptr i8, ptr %114, i64 %124
  %126 = load i8, ptr %125, align 1
  store %"io::Stream" %23, ptr %17, align 8
  %127 = load { i64, i64 }, ptr %17, align 8
  %128 = call i32 @"io::write_byte"({ i64, i64 } %127, i8 %126, ptr %n, ptr %__.context_ptr)
  %129 = icmp eq i32 %128, 0
  br i1 %129, label %or_return.continue23, label %or_return.return19

or_return.return19:                               ; preds = %or_return.continue18
  store i32 %128, ptr %err, align 4
  %130 = load i64, ptr %n, align 8
  %131 = load i32, ptr %err, align 4
  store i64 %130, ptr %n, align 8
  store i32 %131, ptr %err, align 4
  store i64 %130, ptr %5, align 8
  br label %defer20

defer20:                                          ; preds = %or_return.return19
  %132 = icmp ne ptr %3, null
  %133 = zext i1 %132 to i8
  %134 = icmp ne i8 %133, 0
  br i1 %134, label %if.then21, label %if.done22

if.then21:                                        ; preds = %defer20
  %135 = load i64, ptr %n, align 8
  %136 = load i64, ptr %3, align 8
  %137 = add i64 %136, %135
  store i64 %137, ptr %3, align 8
  br label %if.done22

if.done22:                                        ; preds = %if.then21, %defer20
  ret i32 %131

or_return.continue23:                             ; preds = %or_return.continue18
  br label %for.post

unreachable:                                      ; No predecessors!
  br label %if.done24

if.done24:                                        ; preds = %unreachable, %cmp.and, %if.done2
  %138 = load i32, ptr %r, align 4
  store %"io::Stream" %23, ptr %18, align 8
  %139 = load { i64, i64 }, ptr %18, align 8
  store i64 0, ptr %19, align 8
  %140 = call i32 @"io::write_escaped_rune"({ i64, i64 } %139, i32 %138, i8 %2, i8 0, ptr null, i8 %4, ptr %19, ptr %__.context_ptr)
  %141 = load i64, ptr %19, align 8
  %142 = load { i64, i32 }, ptr %20, align 8
  %143 = call i32 @"io::n_wrapper"(i64 %141, i32 %140, ptr %n, ptr %__.context_ptr)
  %144 = icmp eq i32 %143, 0
  br i1 %144, label %or_return.continue29, label %or_return.return25

or_return.return25:                               ; preds = %if.done24
  store i32 %143, ptr %err, align 4
  %145 = load i64, ptr %n, align 8
  %146 = load i32, ptr %err, align 4
  store i64 %145, ptr %n, align 8
  store i32 %146, ptr %err, align 4
  store i64 %145, ptr %5, align 8
  br label %defer26

defer26:                                          ; preds = %or_return.return25
  %147 = icmp ne ptr %3, null
  %148 = zext i1 %147 to i8
  %149 = icmp ne i8 %148, 0
  br i1 %149, label %if.then27, label %if.done28

if.then27:                                        ; preds = %defer26
  %150 = load i64, ptr %n, align 8
  %151 = load i64, ptr %3, align 8
  %152 = add i64 %151, %150
  store i64 %152, ptr %3, align 8
  br label %if.done28

if.done28:                                        ; preds = %if.then27, %defer26
  ret i32 %146

or_return.continue29:                             ; preds = %if.done24
  br label %for.post

for.post:                                         ; preds = %or_return.continue29, %or_return.continue23
  %153 = load %..string, ptr %s, align 8
  %154 = load i64, ptr %width, align 8
  %155 = getelementptr inbounds nuw %..string, ptr %s, i32 0, i32 1
  %156 = load i64, ptr %155, align 8
  call void @"runtime::slice_expr_error_lo_hi"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 263, i32 43, i64 %154, i64 %156, i64 %156)
  %157 = getelementptr inbounds nuw %..string, ptr %s, i32 0, i32 0
  %158 = load ptr, ptr %157, align 8
  %159 = getelementptr i8, ptr %158, i64 %154
  %160 = sub i64 %156, %154
  %161 = getelementptr inbounds nuw %..string, ptr %21, i32 0, i32 0
  store ptr %159, ptr %161, align 8
  %162 = getelementptr inbounds nuw %..string, ptr %21, i32 0, i32 1
  store i64 %160, ptr %162, align 8
  %163 = load %..string, ptr %21, align 8
  store %..string %163, ptr %s, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  store %"io::Stream" %23, ptr %22, align 8
  %164 = load { i64, i64 }, ptr %22, align 8
  %165 = call i32 @"io::write_byte"({ i64, i64 } %164, i8 %2, ptr %n, ptr %__.context_ptr)
  %166 = icmp eq i32 %165, 0
  br i1 %166, label %or_return.continue34, label %or_return.return30

or_return.return30:                               ; preds = %for.done
  store i32 %165, ptr %err, align 4
  %167 = load i64, ptr %n, align 8
  %168 = load i32, ptr %err, align 4
  store i64 %167, ptr %n, align 8
  store i32 %168, ptr %err, align 4
  store i64 %167, ptr %5, align 8
  br label %defer31

defer31:                                          ; preds = %or_return.return30
  %169 = icmp ne ptr %3, null
  %170 = zext i1 %169 to i8
  %171 = icmp ne i8 %170, 0
  br i1 %171, label %if.then32, label %if.done33

if.then32:                                        ; preds = %defer31
  %172 = load i64, ptr %n, align 8
  %173 = load i64, ptr %3, align 8
  %174 = add i64 %173, %172
  store i64 %174, ptr %3, align 8
  br label %if.done33

if.done33:                                        ; preds = %if.then32, %defer31
  ret i32 %168

or_return.continue34:                             ; preds = %for.done
  %175 = load i64, ptr %n, align 8
  %176 = load i32, ptr %err, align 4
  store i64 %175, ptr %n, align 8
  store i32 %176, ptr %err, align 4
  store i64 %175, ptr %5, align 8
  br label %defer35

defer35:                                          ; preds = %or_return.continue34
  %177 = icmp ne ptr %3, null
  %178 = zext i1 %177 to i8
  %179 = icmp ne i8 %178, 0
  br i1 %179, label %if.then36, label %if.done37

if.then36:                                        ; preds = %defer35
  %180 = load i64, ptr %n, align 8
  %181 = load i64, ptr %3, align 8
  %182 = add i64 %181, %180
  store i64 %182, ptr %3, align 8
  br label %if.done37

if.done37:                                        ; preds = %if.then36, %defer35
  ret i32 %176
}

; Function Attrs: alwaysinline
define internal void @"runtime::make_dynamic_array_error_loc"(ptr %0, i64 %1, i64 %2) #3 {
decls:
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %1, ptr %3, align 8
  store i64 %2, ptr %4, align 8
  %5 = icmp sle i64 0, %1
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %entry
  %8 = icmp sle i64 %1, %2
  %9 = zext i1 %8 to i8
  %10 = icmp ne i8 %9, 0
  br i1 %10, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and
  ret void

if.done:                                          ; preds = %cmp.and, %entry
  %11 = load %"runtime::Source_Code_Location", ptr %0, align 8
  call void @"runtime::make_dynamic_array_error_loc.handle_error-0"(ptr %0, i64 %1, i64 %2)
  unreachable
}

define internal %..string @"strings::to_string"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %res = alloca %..string, align 8
  %1 = alloca { ptr, i64 }, align 8
  %2 = alloca %..string, align 8
  br label %entry

entry:                                            ; preds = %decls
  call void @llvm.memset.inline.p0.i64(ptr %res, i8 0, i64 16, i1 false)
  %3 = getelementptr inbounds nuw %"strings::Builder", ptr %0, i32 0, i32 0
  %4 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %3, align 8
  %5 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %3, i32 0, i32 1
  %6 = load i64, ptr %5, align 8
  %7 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %3, i32 0, i32 0
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr i8, ptr %8, i64 0
  %10 = sub i64 %6, 0
  %11 = getelementptr inbounds nuw { ptr, i64 }, ptr %1, i32 0, i32 0
  store ptr %9, ptr %11, align 8
  %12 = getelementptr inbounds nuw { ptr, i64 }, ptr %1, i32 0, i32 1
  store i64 %10, ptr %12, align 8
  %13 = load { ptr, i64 }, ptr %1, align 8
  %14 = load %..string, ptr %1, align 8
  store %..string %14, ptr %res, align 8
  store %..string %14, ptr %2, align 8
  %15 = load %..string, ptr %2, align 8
  ret %..string %15
}

declare i32 @pthread_equal(i64, i64)

define internal i64 @"time::precise_clock_from_time"(i64 %0, ptr noalias nonnull %1, ptr noalias nonnull %2, ptr noalias nonnull %3) {
decls:
  %4 = alloca %"time::Time", align 16
  %hour = alloca i64, align 8
  %min = alloca i64, align 8
  %sec = alloca i64, align 8
  %nanos = alloca i64, align 8
  %_sec = alloca i64, align 8
  %_nanos = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %4, align 8
  %5 = load %"time::Time", ptr %4, align 8
  store i64 0, ptr %hour, align 8
  store i64 0, ptr %min, align 8
  store i64 0, ptr %sec, align 8
  store i64 0, ptr %nanos, align 8
  %6 = getelementptr inbounds nuw %"time::Time", ptr %4, i32 0, i32 0
  %7 = load i64, ptr %6, align 8
  %8 = sdiv i64 %7, 1000000000
  %9 = getelementptr inbounds nuw %"time::Time", ptr %4, i32 0, i32 0
  %10 = load i64, ptr %9, align 8
  %11 = srem i64 %10, 1000000000
  store i64 %8, ptr %_sec, align 8
  store i64 %11, ptr %_nanos, align 8
  %12 = load i64, ptr %_sec, align 8
  %13 = add i64 %12, 9223371966579724800
  store i64 %13, ptr %_sec, align 8
  %14 = load i64, ptr %_nanos, align 8
  store i64 %14, ptr %nanos, align 8
  %15 = load i64, ptr %_sec, align 8
  %16 = srem i64 %15, 86400
  store i64 %16, ptr %sec, align 8
  %17 = load i64, ptr %sec, align 8
  %18 = sdiv i64 %17, 3600
  store i64 %18, ptr %hour, align 8
  %19 = load i64, ptr %hour, align 8
  %20 = mul i64 %19, 3600
  %21 = load i64, ptr %sec, align 8
  %22 = sub i64 %21, %20
  store i64 %22, ptr %sec, align 8
  %23 = load i64, ptr %sec, align 8
  %24 = sdiv i64 %23, 60
  store i64 %24, ptr %min, align 8
  %25 = load i64, ptr %min, align 8
  %26 = mul i64 %25, 60
  %27 = load i64, ptr %sec, align 8
  %28 = sub i64 %27, %26
  store i64 %28, ptr %sec, align 8
  %29 = load i64, ptr %hour, align 8
  %30 = load i64, ptr %min, align 8
  %31 = load i64, ptr %sec, align 8
  %32 = load i64, ptr %nanos, align 8
  store i64 %29, ptr %hour, align 8
  store i64 %30, ptr %min, align 8
  store i64 %31, ptr %sec, align 8
  store i64 %32, ptr %nanos, align 8
  store i64 %29, ptr %1, align 8
  store i64 %30, ptr %2, align 8
  store i64 %31, ptr %3, align 8
  ret i64 %32
}

define internal i8 @"reflect::is_string"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca ptr, align 8
  %3 = alloca { i8, i8 }, align 1
  %ok = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %4 = icmp eq ptr %0, null
  %5 = zext i1 %4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  %7 = call ptr @"runtime::type_info_base"(ptr %0)
  store ptr %7, ptr %2, align 8
  %8 = load ptr, ptr %2, align 8
  %9 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %8, i32 0, i32 5
  %10 = load { [9 x i64], i64 }, ptr %9, align 8
  %11 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %9, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  %13 = icmp eq i64 %12, 7
  %14 = getelementptr inbounds nuw { i8, i8 }, ptr %3, i32 0, i32 1
  %15 = zext i1 %13 to i8
  store i8 %15, ptr %14, align 1
  %16 = load { i8, i8 }, ptr %3, align 1
  %17 = getelementptr inbounds nuw { i8, i8 }, ptr %3, i32 0, i32 0
  %18 = load i8, ptr %17, align 1
  %19 = getelementptr inbounds nuw { i8, i8 }, ptr %3, i32 0, i32 1
  %20 = load i8, ptr %19, align 1
  store i8 %20, ptr %ok, align 1
  %21 = load i8, ptr %ok, align 1
  ret i8 %21
}

define internal void @"runtime::conditional_mem_zero"(ptr %0, i64 %1) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %n = alloca i64, align 8
  %n_words = alloca i64, align 8
  %4 = alloca ptr, align 8
  %5 = alloca { ptr, i64 }, align 8
  %p_words = alloca { ptr, i64 }, align 8
  %6 = alloca ptr, align 8
  %7 = alloca { ptr, i64 }, align 8
  %p_bytes = alloca { ptr, i64 }, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %12 = icmp sle i64 %1, 0
  %13 = zext i1 %12 to i8
  %14 = icmp ne i8 %13, 0
  br i1 %14, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  store i64 %1, ptr %n, align 8
  %15 = load i64, ptr %n, align 8
  %16 = lshr i64 %15, 3
  store i64 %16, ptr %n_words, align 8
  store ptr %0, ptr %4, align 8
  %17 = load ptr, ptr %4, align 8
  %18 = load i64, ptr %n_words, align 8
  %19 = getelementptr i64, ptr %17, i64 0
  %20 = sub i64 %18, 0
  %21 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 0
  %22 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 1
  store ptr %19, ptr %21, align 8
  store i64 %20, ptr %22, align 8
  %23 = load { ptr, i64 }, ptr %5, align 8
  store { ptr, i64 } %23, ptr %p_words, align 8
  store ptr %0, ptr %6, align 8
  %24 = load ptr, ptr %6, align 8
  %25 = load i64, ptr %n_words, align 8
  %26 = mul i64 8, %25
  %27 = load i64, ptr %n, align 8
  %28 = getelementptr i8, ptr %24, i64 %26
  %29 = sub i64 %27, %26
  %30 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 0
  %31 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 1
  store ptr %28, ptr %30, align 8
  store i64 %29, ptr %31, align 8
  %32 = load { ptr, i64 }, ptr %7, align 8
  store { ptr, i64 } %32, ptr %p_bytes, align 8
  %33 = load { ptr, i64 }, ptr %p_words, align 8
  %34 = getelementptr inbounds nuw { ptr, i64 }, ptr %p_words, i32 0, i32 1
  %35 = load i64, ptr %34, align 8
  store i64 %35, ptr %8, align 8
  store i64 -1, ptr %9, align 8
  br label %for.index.loop

for.index.loop:                                   ; preds = %if.done2, %if.done
  %36 = load i64, ptr %9, align 8
  %37 = add i64 %36, 1
  store i64 %37, ptr %9, align 8
  %38 = load i64, ptr %8, align 8
  %39 = icmp slt i64 %37, %38
  br i1 %39, label %for.index.body, label %for.index.done

for.index.body:                                   ; preds = %for.index.loop
  %40 = load i64, ptr %9, align 8
  %41 = getelementptr inbounds nuw { ptr, i64 }, ptr %p_words, i32 0, i32 0
  %42 = load ptr, ptr %41, align 8
  %43 = getelementptr i64, ptr %42, i64 %40
  %44 = load i64, ptr %43, align 8
  %45 = load i64, ptr %43, align 8
  %46 = icmp ne i64 %45, 0
  %47 = zext i1 %46 to i8
  %48 = icmp ne i8 %47, 0
  br i1 %48, label %if.then1, label %if.done2

if.then1:                                         ; preds = %for.index.body
  store i64 0, ptr %43, align 8
  br label %if.done2

if.done2:                                         ; preds = %if.then1, %for.index.body
  br label %for.index.loop

for.index.done:                                   ; preds = %for.index.loop
  %49 = load { ptr, i64 }, ptr %p_bytes, align 8
  %50 = getelementptr inbounds nuw { ptr, i64 }, ptr %p_bytes, i32 0, i32 1
  %51 = load i64, ptr %50, align 8
  store i64 %51, ptr %10, align 8
  store i64 -1, ptr %11, align 8
  br label %for.index.loop3

for.index.loop3:                                  ; preds = %if.done6, %for.index.done
  %52 = load i64, ptr %11, align 8
  %53 = add i64 %52, 1
  store i64 %53, ptr %11, align 8
  %54 = load i64, ptr %10, align 8
  %55 = icmp slt i64 %53, %54
  br i1 %55, label %for.index.body4, label %for.index.done7

for.index.body4:                                  ; preds = %for.index.loop3
  %56 = load i64, ptr %11, align 8
  %57 = getelementptr inbounds nuw { ptr, i64 }, ptr %p_bytes, i32 0, i32 0
  %58 = load ptr, ptr %57, align 8
  %59 = getelementptr i8, ptr %58, i64 %56
  %60 = load i8, ptr %59, align 1
  %61 = load i8, ptr %59, align 1
  %62 = icmp ne i8 %61, 0
  %63 = zext i1 %62 to i8
  %64 = icmp ne i8 %63, 0
  br i1 %64, label %if.then5, label %if.done6

if.then5:                                         ; preds = %for.index.body4
  store i8 0, ptr %59, align 1
  br label %if.done6

if.done6:                                         ; preds = %if.then5, %for.index.body4
  br label %for.index.loop3

for.index.done7:                                  ; preds = %for.index.loop3
  ret void
}

define internal float @"main::min_f32"(float %0, float %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca float, align 4
  %3 = alloca float, align 4
  br label %entry

entry:                                            ; preds = %decls
  store float %0, ptr %2, align 4
  store float %1, ptr %3, align 4
  %4 = fcmp ogt float %0, %1
  %5 = zext i1 %4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.done

if.else:                                          ; preds = %entry
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then
  %7 = phi float [ %1, %if.then ], [ %0, %if.else ]
  ret float %7
}

define internal i32 @"main::hsv_to_rgb"(i32 %0, float %1, float %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca i32, align 4
  %4 = alloca float, align 4
  %5 = alloca float, align 4
  %h = alloca float, align 4
  %s = alloca float, align 4
  %v = alloca float, align 4
  %c = alloca float, align 4
  %x = alloca float, align 4
  %m = alloca float, align 4
  %r = alloca float, align 4
  %g = alloca float, align 4
  %b = alloca float, align 4
  %6 = alloca [4 x i8], align 4
  %7 = alloca i32, align 16
  br label %entry

entry:                                            ; preds = %decls
  store i32 %0, ptr %3, align 4
  store float %1, ptr %4, align 4
  store float %2, ptr %5, align 4
  %8 = urem i32 %0, 360
  %9 = uitofp i32 %8 to float
  store float %9, ptr %h, align 4
  store float %1, ptr %s, align 4
  store float %2, ptr %v, align 4
  %10 = load float, ptr %v, align 4
  %11 = load float, ptr %s, align 4
  %12 = fmul float %10, %11
  store float %12, ptr %c, align 4
  %13 = load float, ptr %c, align 4
  %14 = load float, ptr %h, align 4
  %15 = fdiv float %14, 6.000000e+01
  %16 = fptosi float %15 to i32
  %17 = sext i32 %16 to i64
  %18 = srem i64 %17, 2
  %19 = sitofp i64 %18 to float
  %20 = load float, ptr %h, align 4
  %21 = fdiv float %20, 6.000000e+01
  %22 = load float, ptr %h, align 4
  %23 = fdiv float %22, 6.000000e+01
  %24 = fptosi float %23 to i32
  %25 = sext i32 %24 to i64
  %26 = sitofp i64 %25 to float
  %27 = fsub float %21, %26
  %28 = fadd float %19, %27
  %29 = fsub float %28, 1.000000e+00
  %30 = call float @"main::abs"(float %29, ptr %__.context_ptr)
  %31 = fsub float 1.000000e+00, %30
  %32 = fmul float %13, %31
  store float %32, ptr %x, align 4
  %33 = load float, ptr %v, align 4
  %34 = load float, ptr %c, align 4
  %35 = fsub float %33, %34
  store float %35, ptr %m, align 4
  store float 0.000000e+00, ptr %r, align 4
  store float 0.000000e+00, ptr %g, align 4
  store float 0.000000e+00, ptr %b, align 4
  %36 = load float, ptr %h, align 4
  %37 = fcmp olt float %36, 6.000000e+01
  %38 = zext i1 %37 to i8
  %39 = icmp ne i8 %38, 0
  br i1 %39, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %40 = load float, ptr %c, align 4
  %41 = load float, ptr %x, align 4
  store float %40, ptr %r, align 4
  store float %41, ptr %g, align 4
  store float 0.000000e+00, ptr %b, align 4
  br label %if.done12

if.else:                                          ; preds = %entry
  %42 = load float, ptr %h, align 4
  %43 = fcmp olt float %42, 1.200000e+02
  %44 = zext i1 %43 to i8
  %45 = icmp ne i8 %44, 0
  br i1 %45, label %if.then1, label %if.else2

if.then1:                                         ; preds = %if.else
  %46 = load float, ptr %x, align 4
  %47 = load float, ptr %c, align 4
  store float %46, ptr %r, align 4
  store float %47, ptr %g, align 4
  store float 0.000000e+00, ptr %b, align 4
  br label %if.done11

if.else2:                                         ; preds = %if.else
  %48 = load float, ptr %h, align 4
  %49 = fcmp olt float %48, 1.800000e+02
  %50 = zext i1 %49 to i8
  %51 = icmp ne i8 %50, 0
  br i1 %51, label %if.then3, label %if.else4

if.then3:                                         ; preds = %if.else2
  %52 = load float, ptr %c, align 4
  %53 = load float, ptr %x, align 4
  store float 0.000000e+00, ptr %r, align 4
  store float %52, ptr %g, align 4
  store float %53, ptr %b, align 4
  br label %if.done10

if.else4:                                         ; preds = %if.else2
  %54 = load float, ptr %h, align 4
  %55 = fcmp olt float %54, 2.400000e+02
  %56 = zext i1 %55 to i8
  %57 = icmp ne i8 %56, 0
  br i1 %57, label %if.then5, label %if.else6

if.then5:                                         ; preds = %if.else4
  %58 = load float, ptr %x, align 4
  %59 = load float, ptr %c, align 4
  store float 0.000000e+00, ptr %r, align 4
  store float %58, ptr %g, align 4
  store float %59, ptr %b, align 4
  br label %if.done9

if.else6:                                         ; preds = %if.else4
  %60 = load float, ptr %h, align 4
  %61 = fcmp olt float %60, 3.000000e+02
  %62 = zext i1 %61 to i8
  %63 = icmp ne i8 %62, 0
  br i1 %63, label %if.then7, label %if.else8

if.then7:                                         ; preds = %if.else6
  %64 = load float, ptr %x, align 4
  %65 = load float, ptr %c, align 4
  store float %64, ptr %r, align 4
  store float 0.000000e+00, ptr %g, align 4
  store float %65, ptr %b, align 4
  br label %if.done

if.else8:                                         ; preds = %if.else6
  %66 = load float, ptr %c, align 4
  %67 = load float, ptr %x, align 4
  store float %66, ptr %r, align 4
  store float 0.000000e+00, ptr %g, align 4
  store float %67, ptr %b, align 4
  br label %if.done

if.done:                                          ; preds = %if.else8, %if.then7
  br label %if.done9

if.done9:                                         ; preds = %if.done, %if.then5
  br label %if.done10

if.done10:                                        ; preds = %if.done9, %if.then3
  br label %if.done11

if.done11:                                        ; preds = %if.done10, %if.then1
  br label %if.done12

if.done12:                                        ; preds = %if.done11, %if.then
  call void @llvm.memset.inline.p0.i64(ptr %6, i8 0, i64 4, i1 false)
  store [4 x i8] c"\00\00\00\FF", ptr %6, align 1
  %68 = load float, ptr %r, align 4
  %69 = load float, ptr %m, align 4
  %70 = fadd float %68, %69
  %71 = fmul float %70, 2.550000e+02
  %72 = fptoui float %71 to i32
  %73 = trunc i32 %72 to i8
  %74 = load float, ptr %g, align 4
  %75 = load float, ptr %m, align 4
  %76 = fadd float %74, %75
  %77 = fmul float %76, 2.550000e+02
  %78 = fptoui float %77 to i32
  %79 = trunc i32 %78 to i8
  %80 = load float, ptr %b, align 4
  %81 = load float, ptr %m, align 4
  %82 = fadd float %80, %81
  %83 = fmul float %82, 2.550000e+02
  %84 = fptoui float %83 to i32
  %85 = trunc i32 %84 to i8
  %86 = getelementptr [4 x i8], ptr %6, i64 0, i64 0
  %87 = getelementptr [4 x i8], ptr %6, i64 0, i64 1
  %88 = getelementptr [4 x i8], ptr %6, i64 0, i64 2
  store i8 %73, ptr %86, align 1
  store i8 %79, ptr %87, align 1
  store i8 %85, ptr %88, align 1
  %89 = load [4 x i8], ptr %6, align 1
  store [4 x i8] %89, ptr %7, align 1
  %90 = load i32, ptr %7, align 4
  ret i32 %90
}

define internal void @"strconv_decimal::shift_left"(ptr %0, i64 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %delta = alloca i64, align 8
  %4 = alloca { ptr, i64 }, align 8
  %read_index = alloca i64, align 8
  %write_index = alloca i64, align 8
  %n = alloca i64, align 8
  %quo = alloca i64, align 8
  %rem = alloca i64, align 8
  %quo7 = alloca i64, align 8
  %rem8 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %5 = icmp ult i64 %1, 61
  %6 = zext i1 %5 to i8
  %7 = load %"runtime::Source_Code_Location", ptr @"scl$[shift_left8268]", align 8
  call void @"runtime::assert"(i8 %6, %..string { ptr @"csbs$byte_world$249", i64 6 }, ptr @"scl$[shift_left8268]", ptr %__.context_ptr)
  %8 = getelementptr [61 x { i64, %..string }], ptr @"strconv_decimal::[decimal.odin]::_shift_left_offsets", i64 0, i64 %1
  %9 = getelementptr inbounds nuw { i64, %..string }, ptr %8, i32 0, i32 0
  %10 = load i64, ptr %9, align 8
  store i64 %10, ptr %delta, align 8
  %11 = load ptr, ptr %2, align 8
  %12 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %11, i32 0, i32 0
  %13 = load [384 x i8], ptr %12, align 1
  %14 = load ptr, ptr %2, align 8
  %15 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %14, i32 0, i32 1
  %16 = load i64, ptr %15, align 8
  %17 = getelementptr [384 x i8], ptr %12, i64 0, i64 0
  %18 = getelementptr i8, ptr %17, i64 0
  %19 = sub i64 %16, 0
  %20 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 0
  store ptr %18, ptr %20, align 8
  %21 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 1
  store i64 %19, ptr %21, align 8
  %22 = load { ptr, i64 }, ptr %4, align 8
  %23 = getelementptr [61 x { i64, %..string }], ptr @"strconv_decimal::[decimal.odin]::_shift_left_offsets", i64 0, i64 %1
  %24 = getelementptr inbounds nuw { i64, %..string }, ptr %23, i32 0, i32 1
  %25 = load %..string, ptr %24, align 8
  %26 = call i8 @"strconv_decimal::shift_left.prefix_less-0"({ ptr, i64 } %22, %..string %25)
  %27 = icmp ne i8 %26, 0
  br i1 %27, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %28 = load i64, ptr %delta, align 8
  %29 = sub i64 %28, 1
  store i64 %29, ptr %delta, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %30 = load ptr, ptr %2, align 8
  %31 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %30, i32 0, i32 1
  %32 = load i64, ptr %31, align 8
  store i64 %32, ptr %read_index, align 8
  %33 = load ptr, ptr %2, align 8
  %34 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %33, i32 0, i32 1
  %35 = load i64, ptr %34, align 8
  %36 = load i64, ptr %delta, align 8
  %37 = add i64 %35, %36
  store i64 %37, ptr %write_index, align 8
  store i64 0, ptr %n, align 8
  br label %for.init

for.init:                                         ; preds = %if.done
  %38 = load i64, ptr %read_index, align 8
  %39 = sub i64 %38, 1
  store i64 %39, ptr %read_index, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %for.init
  %40 = load i64, ptr %read_index, align 8
  %41 = icmp sge i64 %40, 0
  %42 = zext i1 %41 to i8
  %43 = icmp ne i8 %42, 0
  br i1 %43, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %44 = load ptr, ptr %2, align 8
  %45 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %44, i32 0, i32 0
  %46 = load i64, ptr %read_index, align 8
  %47 = getelementptr [384 x i8], ptr %45, i64 0, i64 %46
  %48 = load i8, ptr %47, align 1
  %49 = zext i8 %48 to i64
  %50 = sub i64 %49, 48
  %51 = icmp ult i64 %1, 64
  %52 = shl i64 %50, %1
  %53 = select i1 %51, i64 %52, i64 0
  %54 = load i64, ptr %n, align 8
  %55 = add i64 %54, %53
  store i64 %55, ptr %n, align 8
  %56 = load i64, ptr %n, align 8
  %57 = udiv i64 %56, 10
  store i64 %57, ptr %quo, align 8
  %58 = load i64, ptr %n, align 8
  %59 = load i64, ptr %quo, align 8
  %60 = mul i64 10, %59
  %61 = sub i64 %58, %60
  store i64 %61, ptr %rem, align 8
  %62 = load i64, ptr %write_index, align 8
  %63 = sub i64 %62, 1
  store i64 %63, ptr %write_index, align 8
  %64 = load i64, ptr %write_index, align 8
  %65 = icmp slt i64 %64, 384
  %66 = zext i1 %65 to i8
  %67 = icmp ne i8 %66, 0
  br i1 %67, label %if.then1, label %if.else

if.then1:                                         ; preds = %for.body
  %68 = load ptr, ptr %2, align 8
  %69 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %68, i32 0, i32 0
  %70 = load i64, ptr %write_index, align 8
  %71 = getelementptr [384 x i8], ptr %69, i64 0, i64 %70
  %72 = load i64, ptr %rem, align 8
  %73 = add i64 48, %72
  %74 = trunc i64 %73 to i8
  store i8 %74, ptr %71, align 1
  br label %if.done4

if.else:                                          ; preds = %for.body
  %75 = load i64, ptr %rem, align 8
  %76 = icmp ne i64 %75, 0
  %77 = zext i1 %76 to i8
  %78 = icmp ne i8 %77, 0
  br i1 %78, label %if.then2, label %if.done3

if.then2:                                         ; preds = %if.else
  %79 = load ptr, ptr %2, align 8
  %80 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %79, i32 0, i32 4
  store i8 1, ptr %80, align 1
  br label %if.done3

if.done3:                                         ; preds = %if.then2, %if.else
  br label %if.done4

if.done4:                                         ; preds = %if.done3, %if.then1
  %81 = load i64, ptr %quo, align 8
  store i64 %81, ptr %n, align 8
  br label %for.post

for.post:                                         ; preds = %if.done4
  %82 = load i64, ptr %read_index, align 8
  %83 = sub i64 %82, 1
  store i64 %83, ptr %read_index, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  br label %for.loop5

for.loop5:                                        ; preds = %if.done13, %for.done
  %84 = load i64, ptr %n, align 8
  %85 = icmp ugt i64 %84, 0
  %86 = zext i1 %85 to i8
  %87 = icmp ne i8 %86, 0
  br i1 %87, label %for.body6, label %for.done14

for.body6:                                        ; preds = %for.loop5
  %88 = load i64, ptr %n, align 8
  %89 = udiv i64 %88, 10
  store i64 %89, ptr %quo7, align 8
  %90 = load i64, ptr %n, align 8
  %91 = load i64, ptr %quo7, align 8
  %92 = mul i64 10, %91
  %93 = sub i64 %90, %92
  store i64 %93, ptr %rem8, align 8
  %94 = load i64, ptr %write_index, align 8
  %95 = sub i64 %94, 1
  store i64 %95, ptr %write_index, align 8
  %96 = load i64, ptr %write_index, align 8
  %97 = icmp slt i64 %96, 384
  %98 = zext i1 %97 to i8
  %99 = icmp ne i8 %98, 0
  br i1 %99, label %if.then9, label %if.else10

if.then9:                                         ; preds = %for.body6
  %100 = load ptr, ptr %2, align 8
  %101 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %100, i32 0, i32 0
  %102 = load i64, ptr %write_index, align 8
  %103 = getelementptr [384 x i8], ptr %101, i64 0, i64 %102
  %104 = load i64, ptr %rem8, align 8
  %105 = add i64 48, %104
  %106 = trunc i64 %105 to i8
  store i8 %106, ptr %103, align 1
  br label %if.done13

if.else10:                                        ; preds = %for.body6
  %107 = load i64, ptr %rem8, align 8
  %108 = icmp ne i64 %107, 0
  %109 = zext i1 %108 to i8
  %110 = icmp ne i8 %109, 0
  br i1 %110, label %if.then11, label %if.done12

if.then11:                                        ; preds = %if.else10
  %111 = load ptr, ptr %2, align 8
  %112 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %111, i32 0, i32 4
  store i8 1, ptr %112, align 1
  br label %if.done12

if.done12:                                        ; preds = %if.then11, %if.else10
  br label %if.done13

if.done13:                                        ; preds = %if.done12, %if.then9
  %113 = load i64, ptr %quo7, align 8
  store i64 %113, ptr %n, align 8
  br label %for.loop5

for.done14:                                       ; preds = %for.loop5
  %114 = load ptr, ptr %2, align 8
  %115 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %114, i32 0, i32 2
  %116 = load i64, ptr %delta, align 8
  %117 = load i64, ptr %115, align 8
  %118 = add i64 %117, %116
  store i64 %118, ptr %115, align 8
  %119 = load ptr, ptr %2, align 8
  %120 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %119, i32 0, i32 1
  %121 = load ptr, ptr %2, align 8
  %122 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %121, i32 0, i32 1
  %123 = load i64, ptr %122, align 8
  %124 = load i64, ptr %delta, align 8
  %125 = add i64 %123, %124
  %126 = icmp sgt i64 %125, 0
  %127 = select i1 %126, i64 %125, i64 0
  %128 = icmp slt i64 %127, 384
  %129 = select i1 %128, i64 %127, i64 384
  store i64 %129, ptr %120, align 8
  call void @"strconv_decimal::trim"(ptr %0, ptr %__.context_ptr)
  ret void
}

define internal i32 @"io::write_string"({ i64, i64 } %0, %..string %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca %"io::Stream", align 16
  %5 = alloca %..string, align 8
  %6 = alloca ptr, align 8
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  %7 = alloca %..string, align 8
  %8 = alloca { i64, i64 }, align 16
  %9 = alloca i64, align 8
  %10 = alloca { i64, i32 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %4, align 8
  %11 = load %"io::Stream", ptr %4, align 8
  store %..string %1, ptr %5, align 8
  store ptr %2, ptr %6, align 8
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  store %..string %1, ptr %7, align 8
  %12 = load { ptr, i64 }, ptr %7, align 8
  store %"io::Stream" %11, ptr %8, align 8
  %13 = load { i64, i64 }, ptr %8, align 8
  store i64 0, ptr %9, align 8
  %14 = call i32 @"io::write"({ i64, i64 } %13, { ptr, i64 } %12, ptr %2, ptr %9, ptr %__.context_ptr)
  %15 = load i64, ptr %9, align 8
  %16 = load { i64, i32 }, ptr %10, align 8
  store i64 %15, ptr %n, align 8
  store i32 %14, ptr %err, align 4
  store i64 %15, ptr %3, align 8
  ret i32 %14
}

define internal void @"runtime::clear_dynamic_array:proc\22contextless\22(array:^[dynamic]main::Detected_Blob)"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %3 = icmp ne ptr %0, null
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store ptr %0, ptr %2, align 8
  %6 = load ptr, ptr %2, align 8
  %7 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %6, i32 0, i32 1
  store i64 0, ptr %7, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  ret void
}

define internal void @"runtime::arena_temp_begin"(ptr noalias sret(%"runtime::Arena_Temp") %agg.result, ptr %0, ptr %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %temp = alloca %"runtime::Arena_Temp", align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  call void @llvm.memset.inline.p0.i64(ptr %temp, i8 0, i64 24, i1 false)
  %3 = icmp ne ptr %0, null
  %4 = zext i1 %3 to i8
  %5 = load %"runtime::Source_Code_Location", ptr %1, align 8
  call void @"runtime::assert"(i8 %4, %..string { ptr @"csbs$byte_world$24b", i64 9 }, ptr %1, ptr %__.context_ptr)
  %6 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %temp, i32 0, i32 0
  store ptr %0, ptr %6, align 8
  %7 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %temp, i32 0, i32 1
  %8 = load ptr, ptr %2, align 8
  %9 = getelementptr inbounds nuw %"runtime::Arena", ptr %8, i32 0, i32 1
  %10 = load ptr, ptr %9, align 8
  store ptr %10, ptr %7, align 8
  %11 = load ptr, ptr %2, align 8
  %12 = getelementptr inbounds nuw %"runtime::Arena", ptr %11, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  %14 = icmp ne ptr %13, null
  %15 = zext i1 %14 to i8
  %16 = icmp ne i8 %15, 0
  br i1 %16, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %17 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %temp, i32 0, i32 2
  %18 = load ptr, ptr %2, align 8
  %19 = getelementptr inbounds nuw %"runtime::Arena", ptr %18, i32 0, i32 1
  %20 = load ptr, ptr %19, align 8
  %21 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %20, i32 0, i32 3
  %22 = load i64, ptr %21, align 8
  store i64 %22, ptr %17, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %entry
  %23 = load ptr, ptr %2, align 8
  %24 = getelementptr inbounds nuw %"runtime::Arena", ptr %23, i32 0, i32 5
  %25 = load i64, ptr %24, align 8
  %26 = add i64 %25, 1
  store i64 %26, ptr %24, align 8
  %27 = load %"runtime::Arena_Temp", ptr %temp, align 8
  store %"runtime::Arena_Temp" %27, ptr %temp, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %agg.result, ptr %temp, i64 24, i1 false)
  ret void
}

define internal i32 @"io::write_quoted_string16"({ i64, i64 } %0, %..string16 %1, i8 %2, ptr %3, i8 %4, ptr noalias nonnull %5, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %6 = alloca %"io::Stream", align 16
  %7 = alloca %..string16, align 8
  %8 = alloca i8, align 1
  %9 = alloca ptr, align 8
  %10 = alloca i8, align 1
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  %11 = alloca { i64, i64 }, align 16
  %width = alloca i64, align 8
  %s = alloca %..string16, align 8
  %r = alloca i32, align 4
  %12 = alloca i32, align 4
  %13 = alloca { i32, i64 }, align 8
  %14 = alloca { i64, i64 }, align 16
  %15 = alloca { i64, i64 }, align 16
  %16 = alloca { i64, i64 }, align 16
  %17 = alloca { i64, i64 }, align 16
  %18 = alloca { i64, i64 }, align 16
  %19 = alloca i64, align 8
  %20 = alloca { i64, i32 }, align 8
  %21 = alloca %..string16, align 8
  %22 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %6, align 8
  %23 = load %"io::Stream", ptr %6, align 8
  store %..string16 %1, ptr %7, align 8
  store i8 %2, ptr %8, align 1
  store ptr %3, ptr %9, align 8
  store i8 %4, ptr %10, align 1
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  store %"io::Stream" %23, ptr %11, align 8
  %24 = load { i64, i64 }, ptr %11, align 8
  %25 = call i32 @"io::write_byte"({ i64, i64 } %24, i8 %2, ptr %n, ptr %__.context_ptr)
  %26 = icmp eq i32 %25, 0
  br i1 %26, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %entry
  store i32 %25, ptr %err, align 4
  %27 = load i64, ptr %n, align 8
  %28 = load i32, ptr %err, align 4
  store i64 %27, ptr %n, align 8
  store i32 %28, ptr %err, align 4
  store i64 %27, ptr %5, align 8
  br label %defer

defer:                                            ; preds = %or_return.return
  %29 = icmp ne ptr %3, null
  %30 = zext i1 %29 to i8
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %if.then, label %if.done

if.then:                                          ; preds = %defer
  %32 = load i64, ptr %n, align 8
  %33 = load i64, ptr %3, align 8
  %34 = add i64 %33, %32
  store i64 %34, ptr %3, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %defer
  ret i32 %28

or_return.continue:                               ; preds = %entry
  br label %for.init

for.init:                                         ; preds = %or_return.continue
  store i64 0, ptr %width, align 8
  store %..string16 %1, ptr %s, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %for.init
  %35 = load %..string16, ptr %s, align 8
  %36 = getelementptr inbounds nuw %..string16, ptr %s, i32 0, i32 1
  %37 = load i64, ptr %36, align 8
  %38 = icmp sgt i64 %37, 0
  %39 = zext i1 %38 to i8
  %40 = icmp ne i8 %39, 0
  br i1 %40, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %41 = load %..string16, ptr %s, align 8
  %42 = getelementptr inbounds nuw %..string16, ptr %s, i32 0, i32 0
  %43 = load ptr, ptr %42, align 8
  %44 = getelementptr inbounds nuw %..string16, ptr %s, i32 0, i32 1
  %45 = load i64, ptr %44, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 290, i32 15, i64 0, i64 %45)
  %46 = getelementptr i16, ptr %43, i64 0
  %47 = load i16, ptr %46, align 2
  %48 = zext i16 %47 to i32
  store i32 %48, ptr %r, align 4
  store i64 1, ptr %width, align 8
  %49 = load i32, ptr %r, align 4
  %50 = icmp sge i32 %49, 128
  %51 = zext i1 %50 to i8
  %52 = icmp ne i8 %51, 0
  br i1 %52, label %if.then1, label %if.done2

if.then1:                                         ; preds = %for.body
  %53 = load %..string16, ptr %s, align 8
  store i32 0, ptr %12, align 4
  %54 = call i64 @"utf16::decode_rune_in_string"(%..string16 %53, ptr %12, ptr %__.context_ptr)
  %55 = load i32, ptr %12, align 4
  %56 = load { i32, i64 }, ptr %13, align 8
  store i32 %55, ptr %r, align 4
  store i64 %54, ptr %width, align 8
  br label %if.done2

if.done2:                                         ; preds = %if.then1, %for.body
  %57 = load i64, ptr %width, align 8
  %58 = icmp eq i64 %57, 1
  %59 = zext i1 %58 to i8
  %60 = icmp ne i8 %59, 0
  br i1 %60, label %cmp.and, label %if.done24

cmp.and:                                          ; preds = %if.done2
  %61 = load i32, ptr %r, align 4
  %62 = icmp eq i32 %61, 65533
  %63 = zext i1 %62 to i8
  %64 = icmp ne i8 %63, 0
  br i1 %64, label %if.then3, label %if.done24

if.then3:                                         ; preds = %cmp.and
  store %"io::Stream" %23, ptr %14, align 8
  %65 = load { i64, i64 }, ptr %14, align 8
  %66 = call i32 @"io::write_byte"({ i64, i64 } %65, i8 92, ptr %n, ptr %__.context_ptr)
  %67 = icmp eq i32 %66, 0
  br i1 %67, label %or_return.continue8, label %or_return.return4

or_return.return4:                                ; preds = %if.then3
  store i32 %66, ptr %err, align 4
  %68 = load i64, ptr %n, align 8
  %69 = load i32, ptr %err, align 4
  store i64 %68, ptr %n, align 8
  store i32 %69, ptr %err, align 4
  store i64 %68, ptr %5, align 8
  br label %defer5

defer5:                                           ; preds = %or_return.return4
  %70 = icmp ne ptr %3, null
  %71 = zext i1 %70 to i8
  %72 = icmp ne i8 %71, 0
  br i1 %72, label %if.then6, label %if.done7

if.then6:                                         ; preds = %defer5
  %73 = load i64, ptr %n, align 8
  %74 = load i64, ptr %3, align 8
  %75 = add i64 %74, %73
  store i64 %75, ptr %3, align 8
  br label %if.done7

if.done7:                                         ; preds = %if.then6, %defer5
  ret i32 %69

or_return.continue8:                              ; preds = %if.then3
  store %"io::Stream" %23, ptr %15, align 8
  %76 = load { i64, i64 }, ptr %15, align 8
  %77 = call i32 @"io::write_byte"({ i64, i64 } %76, i8 120, ptr %n, ptr %__.context_ptr)
  %78 = icmp eq i32 %77, 0
  br i1 %78, label %or_return.continue13, label %or_return.return9

or_return.return9:                                ; preds = %or_return.continue8
  store i32 %77, ptr %err, align 4
  %79 = load i64, ptr %n, align 8
  %80 = load i32, ptr %err, align 4
  store i64 %79, ptr %n, align 8
  store i32 %80, ptr %err, align 4
  store i64 %79, ptr %5, align 8
  br label %defer10

defer10:                                          ; preds = %or_return.return9
  %81 = icmp ne ptr %3, null
  %82 = zext i1 %81 to i8
  %83 = icmp ne i8 %82, 0
  br i1 %83, label %if.then11, label %if.done12

if.then11:                                        ; preds = %defer10
  %84 = load i64, ptr %n, align 8
  %85 = load i64, ptr %3, align 8
  %86 = add i64 %85, %84
  store i64 %86, ptr %3, align 8
  br label %if.done12

if.done12:                                        ; preds = %if.then11, %defer10
  ret i32 %80

or_return.continue13:                             ; preds = %or_return.continue8
  %87 = load %..string, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %88 = load ptr, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %89 = load i64, ptr getelementptr (%..string, ptr @"io::[util.odin]::DIGITS_LOWER", i64 0, i32 1), align 8
  %90 = load %..string16, ptr %s, align 8
  %91 = getelementptr inbounds nuw %..string16, ptr %s, i32 0, i32 0
  %92 = load ptr, ptr %91, align 8
  %93 = getelementptr inbounds nuw %..string16, ptr %s, i32 0, i32 1
  %94 = load i64, ptr %93, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 298, i32 33, i64 0, i64 %94)
  %95 = getelementptr i16, ptr %92, i64 0
  %96 = load i16, ptr %95, align 2
  %97 = lshr i16 %96, 4
  %98 = select i1 true, i16 %97, i16 0
  %99 = zext i16 %98 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 298, i32 31, i64 %99, i64 %89)
  %100 = getelementptr i8, ptr %88, i64 %99
  %101 = load i8, ptr %100, align 1
  store %"io::Stream" %23, ptr %16, align 8
  %102 = load { i64, i64 }, ptr %16, align 8
  %103 = call i32 @"io::write_byte"({ i64, i64 } %102, i8 %101, ptr %n, ptr %__.context_ptr)
  %104 = icmp eq i32 %103, 0
  br i1 %104, label %or_return.continue18, label %or_return.return14

or_return.return14:                               ; preds = %or_return.continue13
  store i32 %103, ptr %err, align 4
  %105 = load i64, ptr %n, align 8
  %106 = load i32, ptr %err, align 4
  store i64 %105, ptr %n, align 8
  store i32 %106, ptr %err, align 4
  store i64 %105, ptr %5, align 8
  br label %defer15

defer15:                                          ; preds = %or_return.return14
  %107 = icmp ne ptr %3, null
  %108 = zext i1 %107 to i8
  %109 = icmp ne i8 %108, 0
  br i1 %109, label %if.then16, label %if.done17

if.then16:                                        ; preds = %defer15
  %110 = load i64, ptr %n, align 8
  %111 = load i64, ptr %3, align 8
  %112 = add i64 %111, %110
  store i64 %112, ptr %3, align 8
  br label %if.done17

if.done17:                                        ; preds = %if.then16, %defer15
  ret i32 %106

or_return.continue18:                             ; preds = %or_return.continue13
  %113 = load %..string, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %114 = load ptr, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %115 = load i64, ptr getelementptr (%..string, ptr @"io::[util.odin]::DIGITS_LOWER", i64 0, i32 1), align 8
  %116 = load %..string16, ptr %s, align 8
  %117 = getelementptr inbounds nuw %..string16, ptr %s, i32 0, i32 0
  %118 = load ptr, ptr %117, align 8
  %119 = getelementptr inbounds nuw %..string16, ptr %s, i32 0, i32 1
  %120 = load i64, ptr %119, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 299, i32 33, i64 0, i64 %120)
  %121 = getelementptr i16, ptr %118, i64 0
  %122 = load i16, ptr %121, align 2
  %123 = and i16 %122, 15
  %124 = zext i16 %123 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 299, i32 31, i64 %124, i64 %115)
  %125 = getelementptr i8, ptr %114, i64 %124
  %126 = load i8, ptr %125, align 1
  store %"io::Stream" %23, ptr %17, align 8
  %127 = load { i64, i64 }, ptr %17, align 8
  %128 = call i32 @"io::write_byte"({ i64, i64 } %127, i8 %126, ptr %n, ptr %__.context_ptr)
  %129 = icmp eq i32 %128, 0
  br i1 %129, label %or_return.continue23, label %or_return.return19

or_return.return19:                               ; preds = %or_return.continue18
  store i32 %128, ptr %err, align 4
  %130 = load i64, ptr %n, align 8
  %131 = load i32, ptr %err, align 4
  store i64 %130, ptr %n, align 8
  store i32 %131, ptr %err, align 4
  store i64 %130, ptr %5, align 8
  br label %defer20

defer20:                                          ; preds = %or_return.return19
  %132 = icmp ne ptr %3, null
  %133 = zext i1 %132 to i8
  %134 = icmp ne i8 %133, 0
  br i1 %134, label %if.then21, label %if.done22

if.then21:                                        ; preds = %defer20
  %135 = load i64, ptr %n, align 8
  %136 = load i64, ptr %3, align 8
  %137 = add i64 %136, %135
  store i64 %137, ptr %3, align 8
  br label %if.done22

if.done22:                                        ; preds = %if.then21, %defer20
  ret i32 %131

or_return.continue23:                             ; preds = %or_return.continue18
  br label %for.post

unreachable:                                      ; No predecessors!
  br label %if.done24

if.done24:                                        ; preds = %unreachable, %cmp.and, %if.done2
  %138 = load i32, ptr %r, align 4
  store %"io::Stream" %23, ptr %18, align 8
  %139 = load { i64, i64 }, ptr %18, align 8
  store i64 0, ptr %19, align 8
  %140 = call i32 @"io::write_escaped_rune"({ i64, i64 } %139, i32 %138, i8 %2, i8 0, ptr null, i8 %4, ptr %19, ptr %__.context_ptr)
  %141 = load i64, ptr %19, align 8
  %142 = load { i64, i32 }, ptr %20, align 8
  %143 = call i32 @"io::n_wrapper"(i64 %141, i32 %140, ptr %n, ptr %__.context_ptr)
  %144 = icmp eq i32 %143, 0
  br i1 %144, label %or_return.continue29, label %or_return.return25

or_return.return25:                               ; preds = %if.done24
  store i32 %143, ptr %err, align 4
  %145 = load i64, ptr %n, align 8
  %146 = load i32, ptr %err, align 4
  store i64 %145, ptr %n, align 8
  store i32 %146, ptr %err, align 4
  store i64 %145, ptr %5, align 8
  br label %defer26

defer26:                                          ; preds = %or_return.return25
  %147 = icmp ne ptr %3, null
  %148 = zext i1 %147 to i8
  %149 = icmp ne i8 %148, 0
  br i1 %149, label %if.then27, label %if.done28

if.then27:                                        ; preds = %defer26
  %150 = load i64, ptr %n, align 8
  %151 = load i64, ptr %3, align 8
  %152 = add i64 %151, %150
  store i64 %152, ptr %3, align 8
  br label %if.done28

if.done28:                                        ; preds = %if.then27, %defer26
  ret i32 %146

or_return.continue29:                             ; preds = %if.done24
  br label %for.post

for.post:                                         ; preds = %or_return.continue29, %or_return.continue23
  %153 = load %..string16, ptr %s, align 8
  %154 = load i64, ptr %width, align 8
  %155 = getelementptr inbounds nuw %..string16, ptr %s, i32 0, i32 1
  %156 = load i64, ptr %155, align 8
  call void @"runtime::slice_expr_error_lo_hi"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 289, i32 43, i64 %154, i64 %156, i64 %156)
  %157 = getelementptr inbounds nuw %..string16, ptr %s, i32 0, i32 0
  %158 = load ptr, ptr %157, align 8
  %159 = getelementptr i16, ptr %158, i64 %154
  %160 = sub i64 %156, %154
  %161 = getelementptr inbounds nuw %..string16, ptr %21, i32 0, i32 0
  store ptr %159, ptr %161, align 8
  %162 = getelementptr inbounds nuw %..string16, ptr %21, i32 0, i32 1
  store i64 %160, ptr %162, align 8
  %163 = load %..string16, ptr %21, align 8
  store %..string16 %163, ptr %s, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  store %"io::Stream" %23, ptr %22, align 8
  %164 = load { i64, i64 }, ptr %22, align 8
  %165 = call i32 @"io::write_byte"({ i64, i64 } %164, i8 %2, ptr %n, ptr %__.context_ptr)
  %166 = icmp eq i32 %165, 0
  br i1 %166, label %or_return.continue34, label %or_return.return30

or_return.return30:                               ; preds = %for.done
  store i32 %165, ptr %err, align 4
  %167 = load i64, ptr %n, align 8
  %168 = load i32, ptr %err, align 4
  store i64 %167, ptr %n, align 8
  store i32 %168, ptr %err, align 4
  store i64 %167, ptr %5, align 8
  br label %defer31

defer31:                                          ; preds = %or_return.return30
  %169 = icmp ne ptr %3, null
  %170 = zext i1 %169 to i8
  %171 = icmp ne i8 %170, 0
  br i1 %171, label %if.then32, label %if.done33

if.then32:                                        ; preds = %defer31
  %172 = load i64, ptr %n, align 8
  %173 = load i64, ptr %3, align 8
  %174 = add i64 %173, %172
  store i64 %174, ptr %3, align 8
  br label %if.done33

if.done33:                                        ; preds = %if.then32, %defer31
  ret i32 %168

or_return.continue34:                             ; preds = %for.done
  %175 = load i64, ptr %n, align 8
  %176 = load i32, ptr %err, align 4
  store i64 %175, ptr %n, align 8
  store i32 %176, ptr %err, align 4
  store i64 %175, ptr %5, align 8
  br label %defer35

defer35:                                          ; preds = %or_return.continue34
  %177 = icmp ne ptr %3, null
  %178 = zext i1 %177 to i8
  %179 = icmp ne i8 %178, 0
  br i1 %179, label %if.then36, label %if.done37

if.then36:                                        ; preds = %defer35
  %180 = load i64, ptr %n, align 8
  %181 = load i64, ptr %3, align 8
  %182 = add i64 %181, %180
  store i64 %182, ptr %3, align 8
  br label %if.done37

if.done37:                                        ; preds = %if.then36, %defer35
  ret i32 %176
}

define internal i32 @"io::write_string16"({ i64, i64 } %0, %..string16 %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca %"io::Stream", align 16
  %5 = alloca %..string16, align 8
  %6 = alloca ptr, align 8
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  %i = alloca i64, align 8
  %r = alloca i32, align 4
  %c = alloca i16, align 2
  %w = alloca i64, align 8
  %7 = alloca { i64, i64 }, align 16
  %8 = alloca i64, align 8
  %9 = alloca { i64, i32 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %4, align 8
  %10 = load %"io::Stream", ptr %4, align 8
  store %..string16 %1, ptr %5, align 8
  store ptr %2, ptr %6, align 8
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  br label %for.init

for.init:                                         ; preds = %entry
  store i64 0, ptr %i, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %for.init
  %11 = load i64, ptr %i, align 8
  %12 = extractvalue %..string16 %1, 1
  %13 = icmp slt i64 %11, %12
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  store i32 65533, ptr %r, align 4
  %16 = extractvalue %..string16 %1, 0
  %17 = extractvalue %..string16 %1, 1
  %18 = load i64, ptr %i, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$ec", i64 29 }, i32 322, i32 19, i64 %18, i64 %17)
  %19 = getelementptr i16, ptr %16, i64 %18
  %20 = load i16, ptr %19, align 2
  store i16 %20, ptr %c, align 2
  %21 = load i16, ptr %c, align 2
  %22 = icmp ult i16 %21, -10240
  %23 = zext i1 %22 to i8
  %24 = icmp eq i8 1, %23
  br i1 %24, label %switch.case.body, label %switch.case.next

switch.case.next:                                 ; preds = %for.body
  %25 = load i16, ptr %c, align 2
  %26 = icmp ule i16 -8192, %25
  %27 = zext i1 %26 to i8
  %28 = icmp eq i8 1, %27
  br i1 %28, label %switch.case.body, label %switch.case.next1

switch.case.next1:                                ; preds = %switch.case.next
  %29 = load i16, ptr %c, align 2
  %30 = icmp ule i16 -10240, %29
  %31 = zext i1 %30 to i8
  %32 = icmp ne i8 %31, 0
  br i1 %32, label %cmp.and, label %logical.cmp.done

switch.case.body:                                 ; preds = %switch.case.next, %for.body
  %33 = load i16, ptr %c, align 2
  %34 = zext i16 %33 to i32
  store i32 %34, ptr %r, align 4
  br label %switch.done

cmp.and:                                          ; preds = %switch.case.next1
  %35 = load i16, ptr %c, align 2
  %36 = icmp ult i16 %35, -9216
  %37 = zext i1 %36 to i8
  %38 = icmp ne i8 %37, 0
  br i1 %38, label %cmp.and2, label %logical.cmp.done

cmp.and2:                                         ; preds = %cmp.and
  %39 = load i64, ptr %i, align 8
  %40 = add i64 %39, 1
  %41 = extractvalue %..string16 %1, 1
  %42 = icmp slt i64 %40, %41
  %43 = zext i1 %42 to i8
  %44 = icmp ne i8 %43, 0
  br i1 %44, label %cmp.and3, label %logical.cmp.done

cmp.and3:                                         ; preds = %cmp.and2
  %45 = extractvalue %..string16 %1, 0
  %46 = extractvalue %..string16 %1, 1
  %47 = load i64, ptr %i, align 8
  %48 = add i64 %47, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$ec", i64 29 }, i32 326, i32 28, i64 %48, i64 %46)
  %49 = getelementptr i16, ptr %45, i64 %48
  %50 = load i16, ptr %49, align 2
  %51 = icmp ule i16 -9216, %50
  %52 = zext i1 %51 to i8
  %53 = icmp ne i8 %52, 0
  br i1 %53, label %logical.cmp.rhs, label %logical.cmp.done

logical.cmp.rhs:                                  ; preds = %cmp.and3
  %54 = extractvalue %..string16 %1, 0
  %55 = extractvalue %..string16 %1, 1
  %56 = load i64, ptr %i, align 8
  %57 = add i64 %56, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$ec", i64 29 }, i32 326, i32 40, i64 %57, i64 %55)
  %58 = getelementptr i16, ptr %54, i64 %57
  %59 = load i16, ptr %58, align 2
  %60 = icmp ult i16 %59, -8192
  %61 = zext i1 %60 to i8
  %62 = icmp ne i8 %61, 0
  br label %logical.cmp.done

logical.cmp.done:                                 ; preds = %logical.cmp.rhs, %cmp.and3, %cmp.and2, %cmp.and, %switch.case.next1
  %63 = phi i1 [ false, %switch.case.next1 ], [ false, %cmp.and ], [ false, %cmp.and2 ], [ false, %cmp.and3 ], [ %62, %logical.cmp.rhs ]
  %64 = zext i1 %63 to i8
  %65 = icmp eq i8 1, %64
  br i1 %65, label %switch.case.body5, label %switch.case.next4

switch.case.next4:                                ; preds = %logical.cmp.done
  br label %switch.done

switch.case.body5:                                ; preds = %logical.cmp.done
  %66 = load i16, ptr %c, align 2
  %67 = zext i16 %66 to i32
  %68 = extractvalue %..string16 %1, 0
  %69 = extractvalue %..string16 %1, 1
  %70 = load i64, ptr %i, align 8
  %71 = add i64 %70, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$ec", i64 29 }, i32 327, i32 54, i64 %71, i64 %69)
  %72 = getelementptr i16, ptr %68, i64 %71
  %73 = load i16, ptr %72, align 2
  %74 = zext i16 %73 to i32
  %75 = call i32 @"utf16::decode_surrogate_pair"(i32 %67, i32 %74, ptr %__.context_ptr)
  store i32 %75, ptr %r, align 4
  %76 = load i64, ptr %i, align 8
  %77 = add i64 %76, 1
  store i64 %77, ptr %i, align 8
  br label %switch.done

switch.done:                                      ; preds = %switch.case.next4, %switch.case.body5, %switch.case.body
  store i64 0, ptr %w, align 8
  %78 = load i32, ptr %r, align 4
  store %"io::Stream" %10, ptr %7, align 8
  %79 = load { i64, i64 }, ptr %7, align 8
  store i64 0, ptr %8, align 8
  %80 = call i32 @"io::write_rune"({ i64, i64 } %79, i32 %78, ptr %2, ptr %8, ptr %__.context_ptr)
  %81 = load i64, ptr %8, align 8
  %82 = load { i64, i32 }, ptr %9, align 8
  store i64 %81, ptr %w, align 8
  store i32 %80, ptr %err, align 4
  %83 = load i64, ptr %w, align 8
  %84 = load i64, ptr %n, align 8
  %85 = add i64 %84, %83
  store i64 %85, ptr %n, align 8
  %86 = load i32, ptr %err, align 4
  %87 = icmp ne i32 %86, 0
  %88 = zext i1 %87 to i8
  %89 = icmp ne i8 %88, 0
  br i1 %89, label %if.then, label %if.done

if.then:                                          ; preds = %switch.done
  %90 = load i64, ptr %n, align 8
  %91 = load i32, ptr %err, align 4
  store i64 %90, ptr %n, align 8
  store i32 %91, ptr %err, align 4
  store i64 %90, ptr %3, align 8
  ret i32 %91

if.done:                                          ; preds = %switch.done
  br label %for.post

for.post:                                         ; preds = %if.done
  %92 = load i64, ptr %i, align 8
  %93 = add i64 %92, 1
  store i64 %93, ptr %i, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %94 = load i64, ptr %n, align 8
  %95 = load i32, ptr %err, align 4
  store i64 %94, ptr %n, align 8
  store i32 %95, ptr %err, align 4
  store i64 %94, ptr %3, align 8
  ret i32 %95
}

; Function Attrs: alwaysinline
define internal i64 @"runtime::map_cap"(ptr %0) #3 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %1 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %0, i32 0, i32 0
  %2 = load i64, ptr %1, align 8
  %3 = icmp eq i64 %2, 0
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.done

if.else:                                          ; preds = %entry
  %6 = load %"runtime::Raw_Map", ptr %0, align 8
  %7 = call i64 @"runtime::map_log2_cap"(ptr %0)
  %8 = icmp ult i64 %7, 64
  %9 = shl i64 1, %7
  %10 = select i1 %8, i64 %9, i64 0
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then
  %11 = phi i64 [ 0, %if.then ], [ %10, %if.else ]
  ret i64 %11
}

define internal void @"runtime::arena_temp_end"(ptr %0, ptr %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %arena = alloca ptr, align 8
  %memory_block_found = alloca i8, align 1
  %block = alloca ptr, align 8
  %block9 = alloca ptr, align 8
  %amount_to_zero = alloca i64, align 8
  %2 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  %3 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 0
  %4 = load ptr, ptr %3, align 8
  %5 = icmp eq ptr %4, null
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %8 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 1
  %9 = load ptr, ptr %8, align 8
  %10 = icmp eq ptr %9, null
  %11 = zext i1 %10 to i8
  %12 = load %"runtime::Source_Code_Location", ptr @"scl$[arena_temp_end8497]", align 8
  call void @"runtime::assert"(i8 %11, %..string { ptr @"csbs$byte_world$24c", i64 17 }, ptr @"scl$[arena_temp_end8497]", ptr %__.context_ptr)
  %13 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 2
  %14 = load i64, ptr %13, align 8
  %15 = icmp eq i64 %14, 0
  %16 = zext i1 %15 to i8
  %17 = load %"runtime::Source_Code_Location", ptr @"scl$[arena_temp_end8525]", align 8
  call void @"runtime::assert"(i8 %16, %..string { ptr @"csbs$byte_world$24e", i64 14 }, ptr @"scl$[arena_temp_end8525]", ptr %__.context_ptr)
  ret void

if.done:                                          ; preds = %entry
  %18 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 0
  %19 = load ptr, ptr %18, align 8
  store ptr %19, ptr %arena, align 8
  %20 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 1
  %21 = load ptr, ptr %20, align 8
  %22 = icmp ne ptr %21, null
  %23 = zext i1 %22 to i8
  %24 = icmp ne i8 %23, 0
  br i1 %24, label %if.then1, label %if.done12

if.then1:                                         ; preds = %if.done
  store i8 0, ptr %memory_block_found, align 1
  br label %for.init

for.init:                                         ; preds = %if.then1
  %25 = load ptr, ptr %arena, align 8
  %26 = getelementptr inbounds nuw %"runtime::Arena", ptr %25, i32 0, i32 1
  %27 = load ptr, ptr %26, align 8
  store ptr %27, ptr %block, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %for.init
  %28 = load ptr, ptr %block, align 8
  %29 = icmp ne ptr %28, null
  %30 = zext i1 %29 to i8
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %32 = load ptr, ptr %block, align 8
  %33 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 1
  %34 = load ptr, ptr %33, align 8
  %35 = icmp eq ptr %32, %34
  %36 = zext i1 %35 to i8
  %37 = icmp ne i8 %36, 0
  br i1 %37, label %if.then2, label %if.done3

if.then2:                                         ; preds = %for.body
  store i8 1, ptr %memory_block_found, align 1
  br label %for.done

unreachable:                                      ; No predecessors!
  br label %if.done3

if.done3:                                         ; preds = %unreachable, %for.body
  br label %for.post

for.post:                                         ; preds = %if.done3
  %38 = load ptr, ptr %block, align 8
  %39 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %38, i32 0, i32 0
  %40 = load ptr, ptr %39, align 8
  store ptr %40, ptr %block, align 8
  br label %for.loop

for.done:                                         ; preds = %if.then2, %for.loop
  %41 = load i8, ptr %memory_block_found, align 1
  %42 = icmp ne i8 %41, 0
  br i1 %42, label %if.done5, label %if.then4

if.then4:                                         ; preds = %for.done
  %43 = load ptr, ptr %arena, align 8
  %44 = getelementptr inbounds nuw %"runtime::Arena", ptr %43, i32 0, i32 1
  %45 = load ptr, ptr %44, align 8
  %46 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 1
  %47 = load ptr, ptr %46, align 8
  %48 = icmp eq ptr %45, %47
  %49 = zext i1 %48 to i8
  %50 = load %"runtime::Source_Code_Location", ptr %1, align 8
  call void @"runtime::assert"(i8 %49, %..string { ptr @"csbs$byte_world$24f", i64 56 }, ptr %1, ptr %__.context_ptr)
  br label %if.done5

if.done5:                                         ; preds = %if.then4, %for.done
  br label %for.loop6

for.loop6:                                        ; preds = %for.body7, %if.done5
  %51 = load ptr, ptr %arena, align 8
  %52 = getelementptr inbounds nuw %"runtime::Arena", ptr %51, i32 0, i32 1
  %53 = load ptr, ptr %52, align 8
  %54 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 1
  %55 = load ptr, ptr %54, align 8
  %56 = icmp ne ptr %53, %55
  %57 = zext i1 %56 to i8
  %58 = icmp ne i8 %57, 0
  br i1 %58, label %for.body7, label %for.done8

for.body7:                                        ; preds = %for.loop6
  %59 = load ptr, ptr %arena, align 8
  %60 = load %"runtime::Source_Code_Location", ptr @"scl$[arena_temp_end8962]", align 8
  call void @"runtime::arena_free_last_memory_block"(ptr %59, ptr @"scl$[arena_temp_end8962]", ptr %__.context_ptr)
  br label %for.loop6

for.done8:                                        ; preds = %for.loop6
  br label %if.init

if.init:                                          ; preds = %for.done8
  %61 = load ptr, ptr %arena, align 8
  %62 = getelementptr inbounds nuw %"runtime::Arena", ptr %61, i32 0, i32 1
  %63 = load ptr, ptr %62, align 8
  store ptr %63, ptr %block9, align 8
  %64 = load ptr, ptr %block9, align 8
  %65 = icmp ne ptr %64, null
  %66 = zext i1 %65 to i8
  %67 = icmp ne i8 %66, 0
  br i1 %67, label %if.then10, label %if.done11

if.then10:                                        ; preds = %if.init
  %68 = load ptr, ptr %block9, align 8
  %69 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %68, i32 0, i32 3
  %70 = load i64, ptr %69, align 8
  %71 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 2
  %72 = load i64, ptr %71, align 8
  %73 = icmp uge i64 %70, %72
  %74 = zext i1 %73 to i8
  %75 = load %"runtime::Source_Code_Location", ptr %1, align 8
  call void @"runtime::assert"(i8 %74, %..string { ptr @"csbs$byte_world$250", i64 34 }, ptr %1, ptr %__.context_ptr)
  %76 = load ptr, ptr %block9, align 8
  %77 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %76, i32 0, i32 3
  %78 = load i64, ptr %77, align 8
  %79 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 2
  %80 = load i64, ptr %79, align 8
  %81 = sub i64 %78, %80
  store i64 %81, ptr %amount_to_zero, align 8
  %82 = load ptr, ptr %block9, align 8
  %83 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %82, i32 0, i32 2
  %84 = load ptr, ptr %83, align 8
  %85 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 2
  %86 = load i64, ptr %85, align 8
  %87 = getelementptr i8, ptr %84, i64 %86
  store ptr %87, ptr %2, align 8
  %88 = load ptr, ptr %2, align 8
  %89 = load i64, ptr %amount_to_zero, align 8
  call void @llvm.memset.p0.i64(ptr %88, i8 0, i64 %89, i1 false)
  %90 = load ptr, ptr %block9, align 8
  %91 = getelementptr inbounds nuw %"runtime::Memory_Block", ptr %90, i32 0, i32 3
  %92 = getelementptr inbounds nuw %"runtime::Arena_Temp", ptr %0, i32 0, i32 2
  %93 = load i64, ptr %92, align 8
  store i64 %93, ptr %91, align 8
  %94 = load ptr, ptr %arena, align 8
  %95 = getelementptr inbounds nuw %"runtime::Arena", ptr %94, i32 0, i32 2
  %96 = load i64, ptr %amount_to_zero, align 8
  %97 = load i64, ptr %95, align 8
  %98 = sub i64 %97, %96
  store i64 %98, ptr %95, align 8
  br label %if.done11

if.done11:                                        ; preds = %if.then10, %if.init
  br label %if.done12

if.done12:                                        ; preds = %if.done11, %if.done
  %99 = load ptr, ptr %arena, align 8
  %100 = getelementptr inbounds nuw %"runtime::Arena", ptr %99, i32 0, i32 5
  %101 = load i64, ptr %100, align 8
  %102 = icmp ugt i64 %101, 0
  %103 = zext i1 %102 to i8
  %104 = load %"runtime::Source_Code_Location", ptr %1, align 8
  call void @"runtime::assert"(i8 %103, %..string { ptr @"csbs$byte_world$251", i64 28 }, ptr %1, ptr %__.context_ptr)
  %105 = load ptr, ptr %arena, align 8
  %106 = getelementptr inbounds nuw %"runtime::Arena", ptr %105, i32 0, i32 5
  %107 = load i64, ptr %106, align 8
  %108 = sub i64 %107, 1
  store i64 %108, ptr %106, align 8
  ret void
}

define internal float @"main::abs"(float %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca float, align 4
  br label %entry

entry:                                            ; preds = %decls
  store float %0, ptr %1, align 4
  %2 = fcmp oge float %0, 0.000000e+00
  %3 = zext i1 %2 to i8
  %4 = icmp ne i8 %3, 0
  br i1 %4, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.done

if.else:                                          ; preds = %entry
  %5 = fneg float %0
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then
  %6 = phi float [ %0, %if.then ], [ %5, %if.else ]
  ret float %6
}

define internal i64 @"main::abs_int"(i64 %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = icmp sge i64 %0, 0
  %3 = zext i1 %2 to i8
  %4 = icmp ne i8 %3, 0
  br i1 %4, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.done

if.else:                                          ; preds = %entry
  %5 = sub i64 0, %0
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then
  %6 = phi i64 [ %0, %if.then ], [ %5, %if.else ]
  ret i64 %6
}

define internal i8 @"runtime::make_slice:proc(T:$[]u32,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]u32,err:runtime::Allocator_Error)"(i64 %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca i64, align 8
  %5 = alloca %"runtime::Allocator", align 16
  %res = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %6 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %4, align 8
  store { i64, i64 } %1, ptr %5, align 8
  %7 = load %"runtime::Allocator", ptr %5, align 8
  call void @llvm.memset.inline.p0.i64(ptr %res, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %8 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %7, ptr %6, align 8
  %9 = load { i64, i64 }, ptr %6, align 8
  %10 = call i8 @"runtime::_make_aligned_type_erased"(ptr %res, i64 4, i64 %0, i64 4, { i64, i64 } %9, ptr %2, ptr %__.context_ptr)
  store i8 %10, ptr %err, align 1
  %11 = load { ptr, i64 }, ptr %res, align 8
  %12 = load i8, ptr %err, align 1
  store { ptr, i64 } %11, ptr %res, align 8
  store i8 %12, ptr %err, align 1
  store { ptr, i64 } %11, ptr %3, align 8
  ret i8 %12
}

define internal i8 @"runtime::make_slice:proc(T:$[]f32,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]f32,err:runtime::Allocator_Error)"(i64 %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca i64, align 8
  %5 = alloca %"runtime::Allocator", align 16
  %res = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %6 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %4, align 8
  store { i64, i64 } %1, ptr %5, align 8
  %7 = load %"runtime::Allocator", ptr %5, align 8
  call void @llvm.memset.inline.p0.i64(ptr %res, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %8 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %7, ptr %6, align 8
  %9 = load { i64, i64 }, ptr %6, align 8
  %10 = call i8 @"runtime::_make_aligned_type_erased"(ptr %res, i64 4, i64 %0, i64 4, { i64, i64 } %9, ptr %2, ptr %__.context_ptr)
  store i8 %10, ptr %err, align 1
  %11 = load { ptr, i64 }, ptr %res, align 8
  %12 = load i8, ptr %err, align 1
  store { ptr, i64 } %11, ptr %res, align 8
  store i8 %12, ptr %err, align 1
  store { ptr, i64 } %11, ptr %3, align 8
  ret i8 %12
}

define internal i8 @"runtime::make_slice:proc(T:$[]string,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]string,err:runtime::Allocator_Error)"(i64 %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca i64, align 8
  %5 = alloca %"runtime::Allocator", align 16
  %res = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %6 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %4, align 8
  store { i64, i64 } %1, ptr %5, align 8
  %7 = load %"runtime::Allocator", ptr %5, align 8
  call void @llvm.memset.inline.p0.i64(ptr %res, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %8 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %7, ptr %6, align 8
  %9 = load { i64, i64 }, ptr %6, align 8
  %10 = call i8 @"runtime::_make_aligned_type_erased"(ptr %res, i64 16, i64 %0, i64 8, { i64, i64 } %9, ptr %2, ptr %__.context_ptr)
  store i8 %10, ptr %err, align 1
  %11 = load { ptr, i64 }, ptr %res, align 8
  %12 = load i8, ptr %err, align 1
  store { ptr, i64 } %11, ptr %res, align 8
  store i8 %12, ptr %err, align 1
  store { ptr, i64 } %11, ptr %3, align 8
  ret i8 %12
}

define internal i8 @"runtime::make_slice:proc(T:$[]u8,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]u8,err:runtime::Allocator_Error)"(i64 %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca i64, align 8
  %5 = alloca %"runtime::Allocator", align 16
  %res = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %6 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %4, align 8
  store { i64, i64 } %1, ptr %5, align 8
  %7 = load %"runtime::Allocator", ptr %5, align 8
  call void @llvm.memset.inline.p0.i64(ptr %res, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %8 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %7, ptr %6, align 8
  %9 = load { i64, i64 }, ptr %6, align 8
  %10 = call i8 @"runtime::_make_aligned_type_erased"(ptr %res, i64 1, i64 %0, i64 1, { i64, i64 } %9, ptr %2, ptr %__.context_ptr)
  store i8 %10, ptr %err, align 1
  %11 = load { ptr, i64 }, ptr %res, align 8
  %12 = load i8, ptr %err, align 1
  store { ptr, i64 } %11, ptr %res, align 8
  store i8 %12, ptr %err, align 1
  store { ptr, i64 } %11, ptr %3, align 8
  ret i8 %12
}

define internal i8 @"runtime::make_slice:proc(T:$[]raylib::Color,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]raylib::Color,err:runtime::Allocator_Error)"(i64 %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca i64, align 8
  %5 = alloca %"runtime::Allocator", align 16
  %res = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %6 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %4, align 8
  store { i64, i64 } %1, ptr %5, align 8
  %7 = load %"runtime::Allocator", ptr %5, align 8
  call void @llvm.memset.inline.p0.i64(ptr %res, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %8 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %7, ptr %6, align 8
  %9 = load { i64, i64 }, ptr %6, align 8
  %10 = call i8 @"runtime::_make_aligned_type_erased"(ptr %res, i64 4, i64 %0, i64 1, { i64, i64 } %9, ptr %2, ptr %__.context_ptr)
  store i8 %10, ptr %err, align 1
  %11 = load { ptr, i64 }, ptr %res, align 8
  %12 = load i8, ptr %err, align 1
  store { ptr, i64 } %11, ptr %res, align 8
  store i8 %12, ptr %err, align 1
  store { ptr, i64 } %11, ptr %3, align 8
  ret i8 %12
}

define internal i8 @"runtime::make_slice:proc(T:$[]main::Thread_Work,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]main::Thread_Work,err:runtime::Allocator_Error)"(i64 %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca i64, align 8
  %5 = alloca %"runtime::Allocator", align 16
  %res = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %6 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %4, align 8
  store { i64, i64 } %1, ptr %5, align 8
  %7 = load %"runtime::Allocator", ptr %5, align 8
  call void @llvm.memset.inline.p0.i64(ptr %res, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %8 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %7, ptr %6, align 8
  %9 = load { i64, i64 }, ptr %6, align 8
  %10 = call i8 @"runtime::_make_aligned_type_erased"(ptr %res, i64 40, i64 %0, i64 8, { i64, i64 } %9, ptr %2, ptr %__.context_ptr)
  store i8 %10, ptr %err, align 1
  %11 = load { ptr, i64 }, ptr %res, align 8
  %12 = load i8, ptr %err, align 1
  store { ptr, i64 } %11, ptr %res, align 8
  store i8 %12, ptr %err, align 1
  store { ptr, i64 } %11, ptr %3, align 8
  ret i8 %12
}

define internal i8 @"runtime::make_slice:proc(T:$[]^thread::Thread,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]^thread::Thread,err:runtime::Allocator_Error)"(i64 %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca i64, align 8
  %5 = alloca %"runtime::Allocator", align 16
  %res = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %6 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %4, align 8
  store { i64, i64 } %1, ptr %5, align 8
  %7 = load %"runtime::Allocator", ptr %5, align 8
  call void @llvm.memset.inline.p0.i64(ptr %res, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %8 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %7, ptr %6, align 8
  %9 = load { i64, i64 }, ptr %6, align 8
  %10 = call i8 @"runtime::_make_aligned_type_erased"(ptr %res, i64 8, i64 %0, i64 8, { i64, i64 } %9, ptr %2, ptr %__.context_ptr)
  store i8 %10, ptr %err, align 1
  %11 = load { ptr, i64 }, ptr %res, align 8
  %12 = load i8, ptr %err, align 1
  store { ptr, i64 } %11, ptr %res, align 8
  store i8 %12, ptr %err, align 1
  store { ptr, i64 } %11, ptr %3, align 8
  ret i8 %12
}

define internal i8 @"runtime::make_slice:proc(T:$[]main::Spark,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]main::Spark,err:runtime::Allocator_Error)"(i64 %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca i64, align 8
  %5 = alloca %"runtime::Allocator", align 16
  %res = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %6 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %4, align 8
  store { i64, i64 } %1, ptr %5, align 8
  %7 = load %"runtime::Allocator", ptr %5, align 8
  call void @llvm.memset.inline.p0.i64(ptr %res, i8 0, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %8 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %7, ptr %6, align 8
  %9 = load { i64, i64 }, ptr %6, align 8
  %10 = call i8 @"runtime::_make_aligned_type_erased"(ptr %res, i64 64, i64 %0, i64 8, { i64, i64 } %9, ptr %2, ptr %__.context_ptr)
  store i8 %10, ptr %err, align 1
  %11 = load { ptr, i64 }, ptr %res, align 8
  %12 = load i8, ptr %err, align 1
  store { ptr, i64 } %11, ptr %res, align 8
  store i8 %12, ptr %err, align 1
  store { ptr, i64 } %11, ptr %3, align 8
  ret i8 %12
}

define internal i64 @"main::wrap_i"(i64 %0, i64 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %r = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %4 = icmp sgt i64 %1, 0
  %5 = zext i1 %4 to i8
  %6 = load %"runtime::Source_Code_Location", ptr @"scl$[wrap_i8657]", align 8
  call void @"runtime::assert"(i8 %5, %..string { ptr @"csbs$byte_world$252", i64 5 }, ptr @"scl$[wrap_i8657]", ptr %__.context_ptr)
  %7 = icmp ne i64 %1, 0
  br i1 %7, label %mod.safe, label %mod.edge

mod.safe:                                         ; preds = %entry
  %8 = srem i64 %0, %1
  br label %mod.done

mod.edge:                                         ; preds = %entry
  call void @llvm.trap()
  unreachable

mod.done:                                         ; preds = %mod.safe
  store i64 %8, ptr %r, align 8
  %9 = load i64, ptr %r, align 8
  %10 = icmp slt i64 %9, 0
  %11 = zext i1 %10 to i8
  %12 = icmp ne i8 %11, 0
  br i1 %12, label %if.then, label %if.done

if.then:                                          ; preds = %mod.done
  %13 = load i64, ptr %r, align 8
  %14 = add i64 %13, %1
  store i64 %14, ptr %r, align 8
  br label %if.done

if.done:                                          ; preds = %if.then, %mod.done
  %15 = load i64, ptr %r, align 8
  ret i64 %15
}

define internal i64 @"main::idx_of"(i64 %0, i64 %1, i64 %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %3, align 8
  store i64 %1, ptr %4, align 8
  store i64 %2, ptr %5, align 8
  %6 = mul i64 %2, %0
  %7 = add i64 %6, %1
  ret i64 %7
}

define internal i32 @"io::write_rune"({ i64, i64 } %0, i32 %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca %"io::Stream", align 16
  %5 = alloca i32, align 4
  %6 = alloca ptr, align 8
  %size = alloca i64, align 8
  %err = alloca i32, align 4
  %7 = alloca { i64, i64 }, align 16
  %8 = alloca [4 x i8], align 1
  %9 = alloca { [4 x i8], i64 }, align 8
  %buf = alloca [4 x i8], align 1
  %w = alloca i64, align 8
  %10 = alloca { ptr, i64 }, align 8
  %11 = alloca { i64, i64 }, align 16
  %12 = alloca i64, align 8
  %13 = alloca { i64, i32 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %4, align 8
  %14 = load %"io::Stream", ptr %4, align 8
  store i32 %1, ptr %5, align 4
  store ptr %2, ptr %6, align 8
  store i64 0, ptr %size, align 8
  store i32 0, ptr %err, align 4
  %15 = icmp slt i32 %1, 128
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %if.then, label %if.done4

if.then:                                          ; preds = %entry
  %18 = trunc i32 %1 to i8
  store %"io::Stream" %14, ptr %7, align 8
  %19 = load { i64, i64 }, ptr %7, align 8
  %20 = call i32 @"io::write_byte"({ i64, i64 } %19, i8 %18, ptr null, ptr %__.context_ptr)
  store i32 %20, ptr %err, align 4
  %21 = load i32, ptr %err, align 4
  %22 = icmp eq i32 %21, 0
  %23 = zext i1 %22 to i8
  %24 = icmp ne i8 %23, 0
  br i1 %24, label %if.then1, label %if.done

if.then1:                                         ; preds = %if.then
  store i64 1, ptr %size, align 8
  br label %if.done

if.done:                                          ; preds = %if.then1, %if.then
  %25 = load i64, ptr %size, align 8
  %26 = load i32, ptr %err, align 4
  store i64 %25, ptr %size, align 8
  store i32 %26, ptr %err, align 4
  store i64 %25, ptr %3, align 8
  br label %defer

defer:                                            ; preds = %if.done
  %27 = load i32, ptr %err, align 4
  %28 = icmp eq i32 %27, 0
  %29 = zext i1 %28 to i8
  %30 = icmp ne i8 %29, 0
  br i1 %30, label %cmp.and, label %if.done3

cmp.and:                                          ; preds = %defer
  %31 = icmp ne ptr %2, null
  %32 = zext i1 %31 to i8
  %33 = icmp ne i8 %32, 0
  br i1 %33, label %if.then2, label %if.done3

if.then2:                                         ; preds = %cmp.and
  %34 = load i64, ptr %size, align 8
  %35 = load i64, ptr %2, align 8
  %36 = add i64 %35, %34
  store i64 %36, ptr %2, align 8
  br label %if.done3

if.done3:                                         ; preds = %if.then2, %cmp.and, %defer
  ret i32 %26

if.done4:                                         ; preds = %entry
  call void @llvm.memset.inline.p0.i64(ptr %8, i8 0, i64 4, i1 false)
  %37 = call i64 @"utf8::encode_rune"(i32 %1, ptr %8)
  %38 = load [4 x i8], ptr %8, align 1
  %39 = load { [4 x i8], i64 }, ptr %9, align 8
  store [4 x i8] %38, ptr %buf, align 1
  store i64 %37, ptr %w, align 8
  %40 = load [4 x i8], ptr %buf, align 1
  %41 = load i64, ptr %w, align 8
  call void @"runtime::slice_expr_error_hi"(%..string { ptr @"csbs$byte_world$ec", i64 29 }, i32 354, i32 21, i64 %41, i64 4)
  %42 = getelementptr [4 x i8], ptr %buf, i64 0, i64 0
  %43 = getelementptr i8, ptr %42, i64 0
  %44 = sub i64 %41, 0
  %45 = getelementptr inbounds nuw { ptr, i64 }, ptr %10, i32 0, i32 0
  store ptr %43, ptr %45, align 8
  %46 = getelementptr inbounds nuw { ptr, i64 }, ptr %10, i32 0, i32 1
  store i64 %44, ptr %46, align 8
  %47 = load { ptr, i64 }, ptr %10, align 8
  store %"io::Stream" %14, ptr %11, align 8
  %48 = load { i64, i64 }, ptr %11, align 8
  store i64 0, ptr %12, align 8
  %49 = call i32 @"io::write"({ i64, i64 } %48, { ptr, i64 } %47, ptr null, ptr %12, ptr %__.context_ptr)
  %50 = load i64, ptr %12, align 8
  %51 = load { i64, i32 }, ptr %13, align 8
  store i64 %50, ptr %size, align 8
  store i32 %49, ptr %err, align 4
  store i64 %50, ptr %3, align 8
  br label %defer5

defer5:                                           ; preds = %if.done4
  %52 = load i32, ptr %err, align 4
  %53 = icmp eq i32 %52, 0
  %54 = zext i1 %53 to i8
  %55 = icmp ne i8 %54, 0
  br i1 %55, label %cmp.and6, label %if.done8

cmp.and6:                                         ; preds = %defer5
  %56 = icmp ne ptr %2, null
  %57 = zext i1 %56 to i8
  %58 = icmp ne i8 %57, 0
  br i1 %58, label %if.then7, label %if.done8

if.then7:                                         ; preds = %cmp.and6
  %59 = load i64, ptr %size, align 8
  %60 = load i64, ptr %2, align 8
  %61 = add i64 %60, %59
  store i64 %61, ptr %2, align 8
  br label %if.done8

if.done8:                                         ; preds = %if.then7, %cmp.and6, %defer5
  ret i32 %49
}

define internal %..string @"fmt::bprintf"({ ptr, i64 } %0, %..string %1, { ptr, i64 } %2, i8 %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca { ptr, i64 }, align 8
  %5 = alloca %..string, align 8
  %6 = alloca { ptr, i64 }, align 8
  %7 = alloca i8, align 1
  %8 = alloca %"strings::Builder", align 8
  %sb = alloca %"strings::Builder", align 8
  %9 = alloca %..string, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %4, align 8
  store %..string %1, ptr %5, align 8
  store { ptr, i64 } %2, ptr %6, align 8
  store i8 %3, ptr %7, align 1
  call void @llvm.memset.p0.i64(ptr %8, i8 0, i64 40, i1 false)
  call void @"strings::builder_from_bytes"(ptr sret(ptr) %8, { ptr, i64 } %0, ptr %__.context_ptr)
  %10 = load %"strings::Builder", ptr %8, align 8
  store %"strings::Builder" %10, ptr %sb, align 8
  %11 = call %..string @"fmt::sbprintf"(ptr %sb, %..string %1, { ptr, i64 } %2, i8 %3, ptr %__.context_ptr)
  store %..string %11, ptr %9, align 8
  %12 = load %..string, ptr %9, align 8
  ret %..string %12
}

define internal i32 @"main::rng_next_u32"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %x = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = load i32, ptr %0, align 4
  store i32 %2, ptr %x, align 4
  %3 = load i32, ptr %x, align 4
  %4 = shl i32 %3, 13
  %5 = select i1 true, i32 %4, i32 0
  %6 = load i32, ptr %x, align 4
  %7 = xor i32 %6, %5
  store i32 %7, ptr %x, align 4
  %8 = load i32, ptr %x, align 4
  %9 = lshr i32 %8, 17
  %10 = select i1 true, i32 %9, i32 0
  %11 = load i32, ptr %x, align 4
  %12 = xor i32 %11, %10
  store i32 %12, ptr %x, align 4
  %13 = load i32, ptr %x, align 4
  %14 = shl i32 %13, 5
  %15 = select i1 true, i32 %14, i32 0
  %16 = load i32, ptr %x, align 4
  %17 = xor i32 %16, %15
  store i32 %17, ptr %x, align 4
  %18 = load i32, ptr %x, align 4
  store i32 %18, ptr %0, align 4
  %19 = load i32, ptr %x, align 4
  ret i32 %19
}

define internal i64 @"io::write_quoted_rune"({ i64, i64 } %0, i32 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca %"io::Stream", align 16
  %3 = alloca i32, align 4
  %n = alloca i64, align 8
  %quote = alloca i8, align 1
  %4 = alloca { i64, i64 }, align 16
  %5 = alloca [4 x i8], align 1
  %6 = alloca { [4 x i8], i64 }, align 8
  %buf = alloca [4 x i8], align 1
  %width = alloca i64, align 8
  %7 = alloca { i64, i64 }, align 16
  %8 = alloca { i64, i64 }, align 16
  %9 = alloca { i64, i64 }, align 16
  %10 = alloca { i64, i64 }, align 16
  %11 = alloca { i64, i64 }, align 16
  %12 = alloca i64, align 8
  %13 = alloca { i64, i32 }, align 8
  %i = alloca i64, align 8
  %14 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %2, align 8
  %15 = load %"io::Stream", ptr %2, align 8
  store i32 %1, ptr %3, align 4
  store i64 0, ptr %n, align 8
  store i8 39, ptr %quote, align 1
  %16 = load i8, ptr %quote, align 1
  store %"io::Stream" %15, ptr %4, align 8
  %17 = load { i64, i64 }, ptr %4, align 8
  %18 = call i64 @"io::write_quoted_rune._write_byte-0"({ i64, i64 } %17, i8 %16, ptr %__.context_ptr)
  %19 = load i64, ptr %n, align 8
  %20 = add i64 %19, %18
  store i64 %20, ptr %n, align 8
  call void @llvm.memset.inline.p0.i64(ptr %5, i8 0, i64 4, i1 false)
  %21 = call i64 @"utf8::encode_rune"(i32 %1, ptr %5)
  %22 = load [4 x i8], ptr %5, align 1
  %23 = load { [4 x i8], i64 }, ptr %6, align 8
  store [4 x i8] %22, ptr %buf, align 1
  store i64 %21, ptr %width, align 8
  %24 = load i64, ptr %width, align 8
  %25 = icmp eq i64 %24, 1
  %26 = zext i1 %25 to i8
  %27 = icmp ne i8 %26, 0
  br i1 %27, label %cmp.and, label %if.else

cmp.and:                                          ; preds = %entry
  %28 = icmp eq i32 %1, 65533
  %29 = zext i1 %28 to i8
  %30 = icmp ne i8 %29, 0
  br i1 %30, label %if.then, label %if.else

if.then:                                          ; preds = %cmp.and
  store %"io::Stream" %15, ptr %7, align 8
  %31 = load { i64, i64 }, ptr %7, align 8
  %32 = call i64 @"io::write_quoted_rune._write_byte-0"({ i64, i64 } %31, i8 92, ptr %__.context_ptr)
  %33 = load i64, ptr %n, align 8
  %34 = add i64 %33, %32
  store i64 %34, ptr %n, align 8
  store %"io::Stream" %15, ptr %8, align 8
  %35 = load { i64, i64 }, ptr %8, align 8
  %36 = call i64 @"io::write_quoted_rune._write_byte-0"({ i64, i64 } %35, i8 120, ptr %__.context_ptr)
  %37 = load i64, ptr %n, align 8
  %38 = add i64 %37, %36
  store i64 %38, ptr %n, align 8
  %39 = load %..string, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %40 = load ptr, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %41 = load i64, ptr getelementptr (%..string, ptr @"io::[util.odin]::DIGITS_LOWER", i64 0, i32 1), align 8
  %42 = getelementptr [4 x i8], ptr %buf, i64 0, i64 0
  %43 = load i8, ptr %42, align 1
  %44 = lshr i8 %43, 4
  %45 = select i1 true, i8 %44, i8 0
  %46 = zext i8 %45 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 324, i32 36, i64 %46, i64 %41)
  %47 = getelementptr i8, ptr %40, i64 %46
  %48 = load i8, ptr %47, align 1
  store %"io::Stream" %15, ptr %9, align 8
  %49 = load { i64, i64 }, ptr %9, align 8
  %50 = call i64 @"io::write_quoted_rune._write_byte-0"({ i64, i64 } %49, i8 %48, ptr %__.context_ptr)
  %51 = load i64, ptr %n, align 8
  %52 = add i64 %51, %50
  store i64 %52, ptr %n, align 8
  %53 = load %..string, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %54 = load ptr, ptr @"io::[util.odin]::DIGITS_LOWER", align 8
  %55 = load i64, ptr getelementptr (%..string, ptr @"io::[util.odin]::DIGITS_LOWER", i64 0, i32 1), align 8
  %56 = getelementptr [4 x i8], ptr %buf, i64 0, i64 0
  %57 = load i8, ptr %56, align 1
  %58 = and i8 %57, 15
  %59 = zext i8 %58 to i64
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20f", i64 31 }, i32 325, i32 36, i64 %59, i64 %55)
  %60 = getelementptr i8, ptr %54, i64 %59
  %61 = load i8, ptr %60, align 1
  store %"io::Stream" %15, ptr %10, align 8
  %62 = load { i64, i64 }, ptr %10, align 8
  %63 = call i64 @"io::write_quoted_rune._write_byte-0"({ i64, i64 } %62, i8 %61, ptr %__.context_ptr)
  %64 = load i64, ptr %n, align 8
  %65 = add i64 %64, %63
  store i64 %65, ptr %n, align 8
  br label %if.done

if.else:                                          ; preds = %cmp.and, %entry
  %66 = load i8, ptr %quote, align 1
  store %"io::Stream" %15, ptr %11, align 8
  %67 = load { i64, i64 }, ptr %11, align 8
  store i64 0, ptr %12, align 8
  %68 = call i32 @"io::write_escaped_rune"({ i64, i64 } %67, i32 %1, i8 %66, i8 0, ptr null, i8 0, ptr %12, ptr %__.context_ptr)
  %69 = load i64, ptr %12, align 8
  %70 = load { i64, i32 }, ptr %13, align 8
  store i64 %69, ptr %i, align 8
  %71 = load i64, ptr %i, align 8
  %72 = load i64, ptr %n, align 8
  %73 = add i64 %72, %71
  store i64 %73, ptr %n, align 8
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then
  %74 = load i8, ptr %quote, align 1
  store %"io::Stream" %15, ptr %14, align 8
  %75 = load { i64, i64 }, ptr %14, align 8
  %76 = call i64 @"io::write_quoted_rune._write_byte-0"({ i64, i64 } %75, i8 %74, ptr %__.context_ptr)
  %77 = load i64, ptr %n, align 8
  %78 = add i64 %77, %76
  store i64 %78, ptr %n, align 8
  %79 = load i64, ptr %n, align 8
  store i64 %79, ptr %n, align 8
  ret i64 %79
}

define internal i8 @"mem::check_zero_ptr"(ptr %0, i64 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %4 = alloca i16, align 2
  %5 = alloca i32, align 4
  %6 = alloca i64, align 8
  %start = alloca i64, align 8
  %start_aligned = alloca i64, align 8
  %end = alloca i64, align 8
  %end_aligned = alloca i64, align 8
  %b = alloca i64, align 8
  %7 = alloca i64, align 8
  %b8 = alloca i64, align 8
  %b9 = alloca i64, align 8
  %b12 = alloca i64, align 8
  %8 = alloca i64, align 8
  %b15 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %9 = icmp sle i64 %1, 0
  %10 = zext i1 %9 to i8
  %11 = icmp eq i8 1, %10
  br i1 %11, label %switch.case.body, label %switch.case.next

switch.case.next:                                 ; preds = %entry
  %12 = icmp eq ptr %0, null
  %13 = zext i1 %12 to i8
  %14 = icmp eq i8 1, %13
  br i1 %14, label %switch.case.body2, label %switch.case.next1

switch.case.body:                                 ; preds = %entry
  ret i8 1

switch.case.next1:                                ; preds = %switch.case.next
  br label %switch.done

switch.case.body2:                                ; preds = %switch.case.next
  ret i8 1

switch.done:                                      ; preds = %switch.case.next1
  switch i64 %1, label %switch.done7 [
    i64 1, label %switch.case.body3
    i64 2, label %switch.case.body4
    i64 4, label %switch.case.body5
    i64 8, label %switch.case.body6
  ]

switch.case.body3:                                ; preds = %switch.done
  %15 = load i8, ptr %0, align 1
  %16 = icmp eq i8 %15, 0
  %17 = zext i1 %16 to i8
  ret i8 %17

switch.case.body4:                                ; preds = %switch.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %0, i64 2, i1 false)
  %18 = load i16, ptr %4, align 2
  %19 = icmp eq i16 %18, 0
  %20 = zext i1 %19 to i8
  ret i8 %20

switch.case.body5:                                ; preds = %switch.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %5, ptr %0, i64 4, i1 false)
  %21 = load i32, ptr %5, align 4
  %22 = icmp eq i32 %21, 0
  %23 = zext i1 %22 to i8
  ret i8 %23

switch.case.body6:                                ; preds = %switch.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %6, ptr %0, i64 8, i1 false)
  %24 = load i64, ptr %6, align 8
  %25 = icmp eq i64 %24, 0
  %26 = zext i1 %25 to i8
  ret i8 %26

switch.done7:                                     ; preds = %switch.done
  %27 = ptrtoint ptr %0 to i64
  store i64 %27, ptr %start, align 8
  %28 = load i64, ptr %start, align 8
  %29 = call i64 @"mem::align_forward_uintptr"(i64 %28, i64 8, ptr %__.context_ptr)
  store i64 %29, ptr %start_aligned, align 8
  %30 = load i64, ptr %start, align 8
  %31 = add i64 %30, %1
  store i64 %31, ptr %end, align 8
  %32 = load i64, ptr %end, align 8
  %33 = call i64 @"mem::align_backward_uintptr"(i64 %32, i64 8, ptr %__.context_ptr)
  store i64 %33, ptr %end_aligned, align 8
  %34 = load i64, ptr %start, align 8
  store i64 %34, ptr %b, align 8
  store i64 0, ptr %7, align 8
  br label %for.interval.loop

for.interval.loop:                                ; preds = %for.interval.post, %switch.done7
  %35 = load i64, ptr %start_aligned, align 8
  %36 = load i64, ptr %b, align 8
  %37 = icmp ult i64 %36, %35
  br i1 %37, label %for.interval.body, label %for.interval.done

for.interval.body:                                ; preds = %for.interval.loop
  %38 = load i64, ptr %b, align 8
  %39 = load i64, ptr %7, align 8
  store i64 %38, ptr %b8, align 8
  %40 = load i64, ptr %b8, align 8
  %41 = inttoptr i64 %40 to ptr
  %42 = load i8, ptr %41, align 1
  %43 = icmp ne i8 %42, 0
  %44 = zext i1 %43 to i8
  %45 = icmp ne i8 %44, 0
  br i1 %45, label %if.then, label %if.done

if.then:                                          ; preds = %for.interval.body
  ret i8 0

if.done:                                          ; preds = %for.interval.body
  br label %for.interval.post

for.interval.post:                                ; preds = %if.done
  %46 = load i64, ptr %b, align 8
  %47 = add i64 %46, 1
  store i64 %47, ptr %b, align 8
  %48 = load i64, ptr %7, align 8
  %49 = add i64 %48, 1
  store i64 %49, ptr %7, align 8
  br label %for.interval.loop

for.interval.done:                                ; preds = %for.interval.loop
  br label %for.init

for.init:                                         ; preds = %for.interval.done
  %50 = load i64, ptr %start_aligned, align 8
  store i64 %50, ptr %b9, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %for.init
  %51 = load i64, ptr %b9, align 8
  %52 = load i64, ptr %end_aligned, align 8
  %53 = icmp ult i64 %51, %52
  %54 = zext i1 %53 to i8
  %55 = icmp ne i8 %54, 0
  br i1 %55, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %56 = load i64, ptr %b9, align 8
  %57 = inttoptr i64 %56 to ptr
  %58 = load i64, ptr %57, align 8
  %59 = icmp ne i64 %58, 0
  %60 = zext i1 %59 to i8
  %61 = icmp ne i8 %60, 0
  br i1 %61, label %if.then10, label %if.done11

if.then10:                                        ; preds = %for.body
  ret i8 0

if.done11:                                        ; preds = %for.body
  br label %for.post

for.post:                                         ; preds = %if.done11
  %62 = load i64, ptr %b9, align 8
  %63 = add i64 %62, 8
  store i64 %63, ptr %b9, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %64 = load i64, ptr %end_aligned, align 8
  store i64 %64, ptr %b12, align 8
  store i64 0, ptr %8, align 8
  br label %for.interval.loop13

for.interval.loop13:                              ; preds = %for.interval.post18, %for.done
  %65 = load i64, ptr %end, align 8
  %66 = load i64, ptr %b12, align 8
  %67 = icmp ult i64 %66, %65
  br i1 %67, label %for.interval.body14, label %for.interval.done19

for.interval.body14:                              ; preds = %for.interval.loop13
  %68 = load i64, ptr %b12, align 8
  %69 = load i64, ptr %8, align 8
  store i64 %68, ptr %b15, align 8
  %70 = load i64, ptr %b15, align 8
  %71 = inttoptr i64 %70 to ptr
  %72 = load i8, ptr %71, align 1
  %73 = icmp ne i8 %72, 0
  %74 = zext i1 %73 to i8
  %75 = icmp ne i8 %74, 0
  br i1 %75, label %if.then16, label %if.done17

if.then16:                                        ; preds = %for.interval.body14
  ret i8 0

if.done17:                                        ; preds = %for.interval.body14
  br label %for.interval.post18

for.interval.post18:                              ; preds = %if.done17
  %76 = load i64, ptr %b12, align 8
  %77 = add i64 %76, 1
  store i64 %77, ptr %b12, align 8
  %78 = load i64, ptr %8, align 8
  %79 = add i64 %78, 1
  store i64 %79, ptr %8, align 8
  br label %for.interval.loop13

for.interval.done19:                              ; preds = %for.interval.loop13
  ret i8 1
}

define internal i32 @"main::rng_u32_bounded"(ptr %0, i32 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i32 %1, ptr %3, align 4
  %4 = icmp eq i32 %1, 0
  %5 = zext i1 %4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i32 0

if.done:                                          ; preds = %entry
  %7 = call i32 @"main::rng_next_u32"(ptr %0, ptr %__.context_ptr)
  %8 = icmp ne i32 %1, 0
  br i1 %8, label %mod.safe, label %mod.edge

mod.safe:                                         ; preds = %if.done
  %9 = urem i32 %7, %1
  br label %mod.done

mod.edge:                                         ; preds = %if.done
  call void @llvm.trap()
  unreachable

mod.done:                                         ; preds = %mod.safe
  ret i32 %9
}

; Function Attrs: alwaysinline
define internal i64 @"runtime::map_load_factor"(i64 %0) #3 {
decls:
  %1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = icmp ult i64 %0, 64
  %3 = shl i64 1, %0
  %4 = select i1 %2, i64 %3, i64 0
  %5 = mul i64 %4, 75
  %6 = udiv i64 %5, 100
  ret i64 %6
}

define internal i64 @"main::rng_int_inclusive"(ptr %0, i64 %1, i64 %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %span = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store i64 %1, ptr %4, align 8
  store i64 %2, ptr %5, align 8
  %6 = icmp sle i64 %2, %1
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i64 %1

if.done:                                          ; preds = %entry
  %9 = sub i64 %2, %1
  %10 = add i64 %9, 1
  %11 = trunc i64 %10 to i32
  store i32 %11, ptr %span, align 4
  %12 = load i32, ptr %span, align 4
  %13 = call i32 @"main::rng_u32_bounded"(ptr %0, i32 %12, ptr %__.context_ptr)
  %14 = zext i32 %13 to i64
  %15 = add i64 %1, %14
  ret i64 %15
}

define internal void @"strconv_decimal::shift"(ptr %0, i64 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %k = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  store i64 %1, ptr %k, align 8
  %4 = load ptr, ptr %2, align 8
  %5 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %4, i32 0, i32 1
  %6 = load i64, ptr %5, align 8
  %7 = icmp eq i64 %6, 0
  %8 = zext i1 %7 to i8
  %9 = icmp eq i8 1, %8
  br i1 %9, label %switch.case.body, label %switch.case.next

switch.case.next:                                 ; preds = %entry
  %10 = load i64, ptr %k, align 8
  %11 = icmp sgt i64 %10, 0
  %12 = zext i1 %11 to i8
  %13 = icmp eq i8 1, %12
  br i1 %13, label %switch.case.body2, label %switch.case.next1

switch.case.body:                                 ; preds = %entry
  br label %switch.done

switch.case.next1:                                ; preds = %switch.case.next
  %14 = load i64, ptr %k, align 8
  %15 = icmp slt i64 %14, 0
  %16 = zext i1 %15 to i8
  %17 = icmp eq i8 1, %16
  br i1 %17, label %switch.case.body4, label %switch.case.next3

switch.case.body2:                                ; preds = %switch.case.next
  br label %for.loop

for.loop:                                         ; preds = %for.body, %switch.case.body2
  %18 = load i64, ptr %k, align 8
  %19 = icmp sgt i64 %18, 60
  %20 = zext i1 %19 to i8
  %21 = icmp ne i8 %20, 0
  br i1 %21, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  call void @"strconv_decimal::shift_left"(ptr %0, i64 60, ptr %__.context_ptr)
  %22 = load i64, ptr %k, align 8
  %23 = sub i64 %22, 60
  store i64 %23, ptr %k, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %24 = load i64, ptr %k, align 8
  call void @"strconv_decimal::shift_left"(ptr %0, i64 %24, ptr %__.context_ptr)
  br label %switch.done

switch.case.next3:                                ; preds = %switch.case.next1
  br label %switch.done

switch.case.body4:                                ; preds = %switch.case.next1
  br label %for.loop5

for.loop5:                                        ; preds = %for.body6, %switch.case.body4
  %25 = load i64, ptr %k, align 8
  %26 = icmp slt i64 %25, -60
  %27 = zext i1 %26 to i8
  %28 = icmp ne i8 %27, 0
  br i1 %28, label %for.body6, label %for.done7

for.body6:                                        ; preds = %for.loop5
  call void @"strconv_decimal::shift_right"(ptr %0, i64 60, ptr %__.context_ptr)
  %29 = load i64, ptr %k, align 8
  %30 = add i64 %29, 60
  store i64 %30, ptr %k, align 8
  br label %for.loop5

for.done7:                                        ; preds = %for.loop5
  %31 = load i64, ptr %k, align 8
  %32 = sub i64 0, %31
  call void @"strconv_decimal::shift_right"(ptr %0, i64 %32, ptr %__.context_ptr)
  br label %switch.done

switch.done:                                      ; preds = %switch.case.next3, %for.done7, %for.done, %switch.case.body
  ret void
}

; Function Attrs: alwaysinline
define internal i64 @"runtime::map_resize_threshold"(ptr %0) #3 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %1 = load %"runtime::Raw_Map", ptr %0, align 8
  %2 = call i64 @"runtime::map_log2_cap"(ptr %0)
  %3 = call i64 @"runtime::map_load_factor"(i64 %2)
  ret i64 %3
}

define internal i64 @"main::rng_choice_dir_3"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %r = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = call i32 @"main::rng_u32_bounded"(ptr %0, i32 3, ptr %__.context_ptr)
  store i32 %2, ptr %r, align 4
  %3 = load i32, ptr %r, align 4
  switch i32 %3, label %switch.done [
    i32 0, label %switch.case.body
    i32 1, label %switch.case.body1
    i32 2, label %switch.case.body2
  ]

switch.case.body:                                 ; preds = %entry
  ret i64 -1

switch.case.body1:                                ; preds = %entry
  ret i64 0

switch.case.body2:                                ; preds = %entry
  ret i64 1

switch.done:                                      ; preds = %entry
  ret i64 0
}

define internal i8 @"runtime::memory_equal"(ptr %0, ptr %1, i64 %2) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  %a = alloca ptr, align 8
  %b = alloca ptr, align 8
  %n = alloca i64, align 8
  %i = alloca i64, align 8
  %m = alloca i64, align 8
  %load_a = alloca <16 x i8>, align 16
  %load_b = alloca <16 x i8>, align 16
  %ne = alloca <16 x i8>, align 16
  %6 = alloca i64, align 8
  %7 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store ptr %1, ptr %4, align 8
  store i64 %2, ptr %5, align 8
  %8 = icmp eq i64 %2, 0
  %9 = zext i1 %8 to i8
  %10 = icmp eq i8 1, %9
  br i1 %10, label %switch.case.body, label %switch.case.next

switch.case.next:                                 ; preds = %entry
  %11 = icmp eq ptr %0, %1
  %12 = zext i1 %11 to i8
  %13 = icmp eq i8 1, %12
  br i1 %13, label %switch.case.body2, label %switch.case.next1

switch.case.body:                                 ; preds = %entry
  ret i8 1

switch.case.next1:                                ; preds = %switch.case.next
  br label %switch.done

switch.case.body2:                                ; preds = %switch.case.next
  ret i8 1

switch.done:                                      ; preds = %switch.case.next1
  store ptr %0, ptr %a, align 8
  store ptr %1, ptr %b, align 8
  store i64 %2, ptr %n, align 8
  store i64 0, ptr %i, align 8
  store i64 0, ptr %m, align 8
  %14 = load i64, ptr %n, align 8
  %15 = icmp uge i64 %14, 8
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %if.then, label %if.done10

if.then:                                          ; preds = %switch.done
  %18 = load i64, ptr %n, align 8
  %19 = load i64, ptr %i, align 8
  %20 = sub i64 %18, %19
  %21 = lshr i64 %20, 4
  %22 = mul i64 %21, 16
  store i64 %22, ptr %m, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %if.then
  %23 = load i64, ptr %i, align 8
  %24 = load i64, ptr %m, align 8
  %25 = icmp ult i64 %23, %24
  %26 = zext i1 %25 to i8
  %27 = icmp ne i8 %26, 0
  br i1 %27, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %28 = load ptr, ptr %a, align 8
  %29 = load i64, ptr %i, align 8
  %30 = getelementptr i8, ptr %28, i64 %29
  %31 = load <16 x i8>, ptr %30, align 1
  store <16 x i8> %31, ptr %load_a, align 16
  %32 = load ptr, ptr %b, align 8
  %33 = load i64, ptr %i, align 8
  %34 = getelementptr i8, ptr %32, i64 %33
  %35 = load <16 x i8>, ptr %34, align 1
  store <16 x i8> %35, ptr %load_b, align 16
  %36 = load <16 x i8>, ptr %load_a, align 16
  %37 = load <16 x i8>, ptr %load_b, align 16
  %38 = icmp ne <16 x i8> %36, %37
  %39 = sext <16 x i1> %38 to <16 x i8>
  store <16 x i8> %39, ptr %ne, align 16
  %40 = load <16 x i8>, ptr %ne, align 16
  %41 = call i8 @llvm.vector.reduce.or.v16i8(<16 x i8> %40)
  %42 = icmp ne i8 %41, 0
  %43 = zext i1 %42 to i8
  %44 = icmp ne i8 %43, 0
  br i1 %44, label %if.then3, label %if.done

if.then3:                                         ; preds = %for.body
  ret i8 0

if.done:                                          ; preds = %for.body
  br label %for.post

for.post:                                         ; preds = %if.done
  %45 = load i64, ptr %i, align 8
  %46 = add i64 %45, 16
  store i64 %46, ptr %i, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %47 = load i64, ptr %n, align 8
  %48 = load i64, ptr %i, align 8
  %49 = sub i64 %47, %48
  %50 = lshr i64 %49, 3
  %51 = mul i64 %50, 8
  store i64 %51, ptr %m, align 8
  br label %for.loop4

for.loop4:                                        ; preds = %for.post8, %for.done
  %52 = load i64, ptr %i, align 8
  %53 = load i64, ptr %m, align 8
  %54 = icmp ult i64 %52, %53
  %55 = zext i1 %54 to i8
  %56 = icmp ne i8 %55, 0
  br i1 %56, label %for.body5, label %for.done9

for.body5:                                        ; preds = %for.loop4
  %57 = load ptr, ptr %a, align 8
  %58 = load i64, ptr %i, align 8
  %59 = getelementptr i8, ptr %57, i64 %58
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %6, ptr %59, i64 8, i1 false)
  %60 = load i64, ptr %6, align 8
  %61 = load ptr, ptr %b, align 8
  %62 = load i64, ptr %i, align 8
  %63 = getelementptr i8, ptr %61, i64 %62
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %7, ptr %63, i64 8, i1 false)
  %64 = load i64, ptr %7, align 8
  %65 = icmp ne i64 %60, %64
  %66 = zext i1 %65 to i8
  %67 = icmp ne i8 %66, 0
  br i1 %67, label %if.then6, label %if.done7

if.then6:                                         ; preds = %for.body5
  ret i8 0

if.done7:                                         ; preds = %for.body5
  br label %for.post8

for.post8:                                        ; preds = %if.done7
  %68 = load i64, ptr %i, align 8
  %69 = add i64 %68, 8
  store i64 %69, ptr %i, align 8
  br label %for.loop4

for.done9:                                        ; preds = %for.loop4
  br label %if.done10

if.done10:                                        ; preds = %for.done9, %switch.done
  br label %for.loop11

for.loop11:                                       ; preds = %for.post15, %if.done10
  %70 = load i64, ptr %i, align 8
  %71 = load i64, ptr %n, align 8
  %72 = icmp ult i64 %70, %71
  %73 = zext i1 %72 to i8
  %74 = icmp ne i8 %73, 0
  br i1 %74, label %for.body12, label %for.done16

for.body12:                                       ; preds = %for.loop11
  %75 = load ptr, ptr %a, align 8
  %76 = load i64, ptr %i, align 8
  %77 = getelementptr i8, ptr %75, i64 %76
  %78 = load i8, ptr %77, align 1
  %79 = load ptr, ptr %b, align 8
  %80 = load i64, ptr %i, align 8
  %81 = getelementptr i8, ptr %79, i64 %80
  %82 = load i8, ptr %81, align 1
  %83 = icmp ne i8 %78, %82
  %84 = zext i1 %83 to i8
  %85 = icmp ne i8 %84, 0
  br i1 %85, label %if.then13, label %if.done14

if.then13:                                        ; preds = %for.body12
  ret i8 0

if.done14:                                        ; preds = %for.body12
  br label %for.post15

for.post15:                                       ; preds = %if.done14
  %86 = load i64, ptr %i, align 8
  %87 = add i64 %86, 1
  store i64 %87, ptr %i, align 8
  br label %for.loop11

for.done16:                                       ; preds = %for.loop11
  ret i8 1
}

define internal void @"main::shuffle_sparks"({ ptr, i64 } %0, ptr %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca ptr, align 8
  %i = alloca i64, align 8
  %j = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %2, align 8
  store ptr %1, ptr %3, align 8
  %4 = extractvalue { ptr, i64 } %0, 1
  %5 = icmp sle i64 %4, 1
  %6 = zext i1 %5 to i8
  %7 = icmp ne i8 %6, 0
  br i1 %7, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret void

if.done:                                          ; preds = %entry
  br label %for.init

for.init:                                         ; preds = %if.done
  %8 = extractvalue { ptr, i64 } %0, 1
  %9 = sub i64 %8, 1
  store i64 %9, ptr %i, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %for.init
  %10 = load i64, ptr %i, align 8
  %11 = icmp sgt i64 %10, 0
  %12 = zext i1 %11 to i8
  %13 = icmp ne i8 %12, 0
  br i1 %13, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %14 = load i64, ptr %i, align 8
  %15 = call i64 @"main::rng_int_inclusive"(ptr %1, i64 0, i64 %14, ptr %__.context_ptr)
  store i64 %15, ptr %j, align 8
  %16 = extractvalue { ptr, i64 } %0, 0
  %17 = load i64, ptr %i, align 8
  %18 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 386, i32 10, i64 %17, i64 %18)
  %19 = getelementptr %"main::Spark", ptr %16, i64 %17
  %20 = extractvalue { ptr, i64 } %0, 0
  %21 = load i64, ptr %j, align 8
  %22 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 386, i32 21, i64 %21, i64 %22)
  %23 = getelementptr %"main::Spark", ptr %20, i64 %21
  %24 = extractvalue { ptr, i64 } %0, 0
  %25 = load i64, ptr %j, align 8
  %26 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 386, i32 33, i64 %25, i64 %26)
  %27 = getelementptr %"main::Spark", ptr %24, i64 %25
  %28 = load %"main::Spark", ptr %27, align 8
  %29 = extractvalue { ptr, i64 } %0, 0
  %30 = load i64, ptr %i, align 8
  %31 = extractvalue { ptr, i64 } %0, 1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 386, i32 44, i64 %30, i64 %31)
  %32 = getelementptr %"main::Spark", ptr %29, i64 %30
  %33 = load %"main::Spark", ptr %32, align 8
  store %"main::Spark" %28, ptr %19, align 8
  store %"main::Spark" %33, ptr %23, align 8
  br label %for.post

for.post:                                         ; preds = %for.body
  %34 = load i64, ptr %i, align 8
  %35 = sub i64 %34, 1
  store i64 %35, ptr %i, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  ret void
}

define internal i8 @"reflect::is_pointer_internally"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca [2 x i8], align 1
  %v = alloca { [9 x i64], i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %3 = icmp eq ptr %0, null
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  %6 = load ptr, ptr %1, align 8
  %7 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %6, i32 0, i32 5
  %8 = load { [9 x i64], i64 }, ptr %7, align 8
  %9 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %7, i32 0, i32 1
  %10 = load i64, ptr %9, align 8
  switch i64 %10, label %typeswitch.done [
    i64 11, label %typeswitch.body
    i64 12, label %typeswitch.body
    i64 13, label %typeswitch.body
    i64 7, label %typeswitch.body1
  ]

typeswitch.body:                                  ; preds = %if.done, %if.done, %if.done
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %v, ptr align 1 %7, i64 80, i1 false)
  ret i8 1

typeswitch.body1:                                 ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %7, i64 2, i1 false)
  %11 = getelementptr inbounds nuw %"runtime::Type_Info_String", ptr %2, i32 0, i32 0
  %12 = load i8, ptr %11, align 1
  ret i8 %12

typeswitch.done:                                  ; preds = %if.done
  ret i8 0
}

; Function Attrs: alwaysinline
define internal i64 @"runtime::map_log2_cap"(ptr %0) #3 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %1 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %0, i32 0, i32 0
  %2 = load i64, ptr %1, align 8
  %3 = and i64 %2, 63
  ret i64 %3
}

define internal i8 @"strconv_decimal::can_round_up"(ptr %0, i64 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %4 = icmp slt i64 %1, 0
  %5 = zext i1 %4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %entry
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %7, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %10 = icmp sge i64 %1, %9
  %11 = zext i1 %10 to i8
  %12 = icmp ne i8 %11, 0
  br i1 %12, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %entry
  ret i8 0

if.done:                                          ; preds = %cmp.or
  %13 = load ptr, ptr %2, align 8
  %14 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %13, i32 0, i32 0
  %15 = getelementptr [384 x i8], ptr %14, i64 0, i64 %1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20a", i64 47 }, i32 447, i32 14, i64 %1, i64 384)
  %16 = load i8, ptr %15, align 1
  %17 = icmp eq i8 %16, 53
  %18 = zext i1 %17 to i8
  %19 = icmp ne i8 %18, 0
  br i1 %19, label %cmp.and, label %if.done4

cmp.and:                                          ; preds = %if.done
  %20 = add i64 %1, 1
  %21 = load ptr, ptr %2, align 8
  %22 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %21, i32 0, i32 1
  %23 = load i64, ptr %22, align 8
  %24 = icmp eq i64 %20, %23
  %25 = zext i1 %24 to i8
  %26 = icmp ne i8 %25, 0
  br i1 %26, label %if.then1, label %if.done4

if.then1:                                         ; preds = %cmp.and
  %27 = load ptr, ptr %2, align 8
  %28 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %27, i32 0, i32 4
  %29 = load i8, ptr %28, align 1
  %30 = icmp ne i8 %29, 0
  br i1 %30, label %if.then2, label %if.done3

if.then2:                                         ; preds = %if.then1
  ret i8 1

if.done3:                                         ; preds = %if.then1
  %31 = icmp sgt i64 %1, 0
  %32 = zext i1 %31 to i8
  %33 = icmp ne i8 %32, 0
  br i1 %33, label %logical.cmp.rhs, label %logical.cmp.done

logical.cmp.rhs:                                  ; preds = %if.done3
  %34 = load ptr, ptr %2, align 8
  %35 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %34, i32 0, i32 0
  %36 = sub i64 %1, 1
  %37 = getelementptr [384 x i8], ptr %35, i64 0, i64 %36
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20a", i64 47 }, i32 451, i32 30, i64 %36, i64 384)
  %38 = load i8, ptr %37, align 1
  %39 = sub i8 %38, 48
  %40 = urem i8 %39, 2
  %41 = icmp ne i8 %40, 0
  %42 = zext i1 %41 to i8
  %43 = icmp ne i8 %42, 0
  br label %logical.cmp.done

logical.cmp.done:                                 ; preds = %logical.cmp.rhs, %if.done3
  %44 = phi i1 [ false, %if.done3 ], [ %43, %logical.cmp.rhs ]
  %45 = zext i1 %44 to i8
  ret i8 %45

if.done4:                                         ; preds = %cmp.and, %if.done
  %46 = load ptr, ptr %2, align 8
  %47 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %46, i32 0, i32 0
  %48 = getelementptr [384 x i8], ptr %47, i64 0, i64 %1
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20a", i64 47 }, i32 454, i32 18, i64 %1, i64 384)
  %49 = load i8, ptr %48, align 1
  %50 = icmp uge i8 %49, 53
  %51 = zext i1 %50 to i8
  ret i8 %51
}

define internal void @"main::spark_buf_clear"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %2 = load ptr, ptr %1, align 8
  %3 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %2, i32 0, i32 1
  store i64 0, ptr %3, align 8
  ret void
}

; Function Attrs: alwaysinline
define internal i64 @"runtime::map_data"(ptr %0) #3 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %1 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %0, i32 0, i32 0
  %2 = load i64, ptr %1, align 8
  %3 = and i64 %2, -64
  ret i64 %3
}

define internal void @"sync::atomic_sema_post"(ptr %0, i64 %1) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %4 = load ptr, ptr %2, align 8
  %5 = getelementptr inbounds nuw %"sync::Atomic_Sema", ptr %4, i32 0, i32 0
  %6 = trunc i64 %1 to i32
  %7 = atomicrmw volatile add ptr %5, i32 %6 release, align 4
  %8 = icmp eq i64 %1, 1
  %9 = zext i1 %8 to i8
  %10 = icmp ne i8 %9, 0
  br i1 %10, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load ptr, ptr %2, align 8
  %12 = getelementptr inbounds nuw %"sync::Atomic_Sema", ptr %11, i32 0, i32 0
  call void @"sync::futex_signal"(ptr %12)
  br label %if.done

if.else:                                          ; preds = %entry
  %13 = load ptr, ptr %2, align 8
  %14 = getelementptr inbounds nuw %"sync::Atomic_Sema", ptr %13, i32 0, i32 0
  call void @"sync::futex_broadcast"(ptr %14)
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then
  ret void
}

define internal { ptr, i64 } @"main::spark_buf_slice"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca { ptr, i64 }, align 8
  %3 = alloca { ptr, i64 }, align 8
  %4 = alloca { ptr, i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %5 = load ptr, ptr %1, align 8
  %6 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %5, i32 0, i32 1
  %7 = load i64, ptr %6, align 8
  %8 = icmp sle i64 %7, 0
  %9 = zext i1 %8 to i8
  %10 = icmp ne i8 %9, 0
  br i1 %10, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %11 = load ptr, ptr %1, align 8
  %12 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %11, i32 0, i32 0
  %13 = load { ptr, i64 }, ptr %12, align 8
  %14 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  call void @"runtime::slice_expr_error_hi"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 395, i32 33, i64 0, i64 %15)
  %16 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = getelementptr %"main::Spark", ptr %17, i64 0
  %19 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 0
  store ptr %18, ptr %19, align 8
  %20 = getelementptr inbounds nuw { ptr, i64 }, ptr %2, i32 0, i32 1
  store i64 0, ptr %20, align 8
  %21 = load { ptr, i64 }, ptr %2, align 8
  store { ptr, i64 } %21, ptr %3, align 8
  %22 = load { ptr, i64 }, ptr %3, align 8
  ret { ptr, i64 } %22

if.done:                                          ; preds = %entry
  %23 = load ptr, ptr %1, align 8
  %24 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %23, i32 0, i32 0
  %25 = load { ptr, i64 }, ptr %24, align 8
  %26 = load ptr, ptr %1, align 8
  %27 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %26, i32 0, i32 1
  %28 = load i64, ptr %27, align 8
  %29 = getelementptr inbounds nuw { ptr, i64 }, ptr %24, i32 0, i32 1
  %30 = load i64, ptr %29, align 8
  call void @"runtime::slice_expr_error_hi"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 396, i32 15, i64 %28, i64 %30)
  %31 = getelementptr inbounds nuw { ptr, i64 }, ptr %24, i32 0, i32 0
  %32 = load ptr, ptr %31, align 8
  %33 = getelementptr %"main::Spark", ptr %32, i64 0
  %34 = sub i64 %28, 0
  %35 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 0
  store ptr %33, ptr %35, align 8
  %36 = getelementptr inbounds nuw { ptr, i64 }, ptr %4, i32 0, i32 1
  store i64 %34, ptr %36, align 8
  %37 = load { ptr, i64 }, ptr %4, align 8
  store { ptr, i64 } %37, ptr %3, align 8
  %38 = load { ptr, i64 }, ptr %3, align 8
  ret { ptr, i64 } %38
}

define internal i8 @"main::spark_buf_append"(ptr %0, ptr %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %3, i32 0, i32 1
  %5 = load i64, ptr %4, align 8
  %6 = load ptr, ptr %2, align 8
  %7 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %6, i32 0, i32 0
  %8 = load { ptr, i64 }, ptr %7, align 8
  %9 = getelementptr inbounds nuw { ptr, i64 }, ptr %7, i32 0, i32 1
  %10 = load i64, ptr %9, align 8
  %11 = icmp sge i64 %5, %10
  %12 = zext i1 %11 to i8
  %13 = icmp ne i8 %12, 0
  br i1 %13, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  %14 = load ptr, ptr %2, align 8
  %15 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %14, i32 0, i32 0
  %16 = load { ptr, i64 }, ptr %15, align 8
  %17 = getelementptr inbounds nuw { ptr, i64 }, ptr %15, i32 0, i32 0
  %18 = load ptr, ptr %17, align 8
  %19 = load ptr, ptr %2, align 8
  %20 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %19, i32 0, i32 1
  %21 = load i64, ptr %20, align 8
  %22 = getelementptr inbounds nuw { ptr, i64 }, ptr %15, i32 0, i32 1
  %23 = load i64, ptr %22, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 403, i32 9, i64 %21, i64 %23)
  %24 = getelementptr %"main::Spark", ptr %18, i64 %21
  %25 = load %"main::Spark", ptr %1, align 8
  store %"main::Spark" %25, ptr %24, align 8
  %26 = load ptr, ptr %2, align 8
  %27 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %26, i32 0, i32 1
  %28 = load i64, ptr %27, align 8
  %29 = add i64 %28, 1
  store i64 %29, ptr %27, align 8
  ret i8 1
}

define internal void @"sync::atomic_sema_wait"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  %original_count = alloca i32, align 4
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  br label %for.body

for.body:                                         ; preds = %if.done, %entry
  %2 = load ptr, ptr %1, align 8
  %3 = getelementptr inbounds nuw %"sync::Atomic_Sema", ptr %2, i32 0, i32 0
  %4 = load atomic volatile i32, ptr %3 monotonic, align 4
  store i32 %4, ptr %original_count, align 4
  br label %for.loop

for.loop:                                         ; preds = %for.body1, %for.body
  %5 = load i32, ptr %original_count, align 4
  %6 = icmp eq i32 %5, 0
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %for.body1, label %for.done

for.body1:                                        ; preds = %for.loop
  %9 = load ptr, ptr %1, align 8
  %10 = getelementptr inbounds nuw %"sync::Atomic_Sema", ptr %9, i32 0, i32 0
  %11 = load i32, ptr %original_count, align 4
  call void @"sync::futex_wait"(ptr %10, i32 %11)
  %12 = load ptr, ptr %1, align 8
  %13 = getelementptr inbounds nuw %"sync::Atomic_Sema", ptr %12, i32 0, i32 0
  %14 = load atomic volatile i32, ptr %13 monotonic, align 4
  store i32 %14, ptr %original_count, align 4
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %15 = load i32, ptr %original_count, align 4
  %16 = load ptr, ptr %1, align 8
  %17 = getelementptr inbounds nuw %"sync::Atomic_Sema", ptr %16, i32 0, i32 0
  %18 = load i32, ptr %original_count, align 4
  %19 = load i32, ptr %original_count, align 4
  %20 = sub i32 %19, 1
  %21 = cmpxchg volatile ptr %17, i32 %18, i32 %20 acquire acquire, align 4
  %22 = extractvalue { i32, i1 } %21, 0
  %23 = icmp eq i32 %15, %22
  %24 = zext i1 %23 to i8
  %25 = icmp ne i8 %24, 0
  br i1 %25, label %if.then, label %if.done

if.then:                                          ; preds = %for.done
  ret void

if.done:                                          ; preds = %for.done
  br label %for.body

for.done2:                                        ; No predecessors!
  ret void
}

define internal void @"strconv_decimal::round"(ptr %0, i64 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %4 = icmp slt i64 %1, 0
  %5 = zext i1 %4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %entry
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %7, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %10 = icmp sge i64 %1, %9
  %11 = zext i1 %10 to i8
  %12 = icmp ne i8 %11, 0
  br i1 %12, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %entry
  ret void

if.done:                                          ; preds = %cmp.or
  %13 = call i8 @"strconv_decimal::can_round_up"(ptr %0, i64 %1, ptr %__.context_ptr)
  %14 = icmp ne i8 %13, 0
  br i1 %14, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.done
  call void @"strconv_decimal::round_up"(ptr %0, i64 %1, ptr %__.context_ptr)
  br label %if.done2

if.else:                                          ; preds = %if.done
  call void @"strconv_decimal::round_down"(ptr %0, i64 %1, ptr %__.context_ptr)
  br label %if.done2

if.done2:                                         ; preds = %if.else, %if.then1
  ret void
}

; Function Attrs: alwaysinline
define internal i8 @"runtime::map_hash_is_empty"(i64 %0) #3 {
decls:
  %1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = icmp eq i64 %0, 0
  %3 = zext i1 %2 to i8
  ret i8 %3
}

define internal i32 @"main::seed_from_system_time"(ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %0 = alloca %"time::Time", align 16
  %1 = alloca i64, align 16
  %nsec = alloca i64, align 8
  %cc = alloca i64, align 8
  %mixed = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  %2 = call i64 @"time::now"()
  store i64 %2, ptr %0, align 8
  %3 = load %"time::Time", ptr %0, align 8
  store %"time::Time" %3, ptr %1, align 8
  %4 = load i64, ptr %1, align 8
  %5 = call i64 @"time::time_to_unix_nano"(i64 %4)
  store i64 %5, ptr %nsec, align 8
  %6 = call i64 @"time::read_cycle_counter"()
  store i64 %6, ptr %cc, align 8
  %7 = load i64, ptr %nsec, align 8
  %8 = load i64, ptr %cc, align 8
  %9 = shl i64 %8, 1
  %10 = select i1 true, i64 %9, i64 0
  %11 = xor i64 %7, %10
  %12 = load i64, ptr %nsec, align 8
  %13 = lshr i64 %12, 23
  %14 = select i1 true, i64 %13, i64 0
  %15 = xor i64 %11, %14
  %16 = xor i64 %15, -6510615555426900571
  store i64 %16, ptr %mixed, align 8
  %17 = load i64, ptr %mixed, align 8
  %18 = load i64, ptr %mixed, align 8
  %19 = lshr i64 %18, 32
  %20 = select i1 true, i64 %19, i64 0
  %21 = xor i64 %17, %20
  %22 = trunc i64 %21 to i32
  ret i32 %22
}

; Function Attrs: noinline
define internal i8 @"runtime::map_hash_is_deleted"(i64 %0) #4 {
decls:
  %1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = and i64 %0, -9223372036854775808
  %3 = icmp ne i64 %2, 0
  %4 = zext i1 %3 to i8
  ret i8 %4
}

declare i32 @pthread_join(i64, ptr)

define internal i64 @"strings::write_bytes"(ptr %0, { ptr, i64 } %1, ptr %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca { ptr, i64 }, align 8
  %n = alloca i64, align 8
  %n0 = alloca i64, align 8
  %5 = alloca i64, align 8
  %6 = alloca { i64, i8 }, align 8
  %n1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store { ptr, i64 } %1, ptr %4, align 8
  store i64 0, ptr %n, align 8
  %7 = load ptr, ptr %3, align 8
  %8 = getelementptr inbounds nuw %"strings::Builder", ptr %7, i32 0, i32 0
  %9 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %8, align 8
  %10 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %8, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  store i64 %11, ptr %n0, align 8
  %12 = load ptr, ptr %3, align 8
  %13 = getelementptr inbounds nuw %"strings::Builder", ptr %12, i32 0, i32 0
  %14 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store i64 0, ptr %5, align 8
  %15 = call i8 @"runtime::append_elems:proc(array:^[dynamic]u8,args:..u8,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr %13, { ptr, i64 } %1, ptr %2, ptr %5, ptr %__.context_ptr)
  %16 = load i64, ptr %5, align 8
  %17 = load { i64, i8 }, ptr %6, align 8
  %18 = load ptr, ptr %3, align 8
  %19 = getelementptr inbounds nuw %"strings::Builder", ptr %18, i32 0, i32 0
  %20 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %19, align 8
  %21 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %19, i32 0, i32 1
  %22 = load i64, ptr %21, align 8
  store i64 %22, ptr %n1, align 8
  %23 = load i64, ptr %n1, align 8
  %24 = load i64, ptr %n0, align 8
  %25 = sub i64 %23, %24
  store i64 %25, ptr %n, align 8
  ret i64 %25
}

define internal void @"strconv_decimal::round_up"(ptr %0, i64 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %i = alloca i64, align 8
  %c = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %4 = icmp slt i64 %1, 0
  %5 = zext i1 %4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %entry
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %7, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %10 = icmp sge i64 %1, %9
  %11 = zext i1 %10 to i8
  %12 = icmp ne i8 %11, 0
  br i1 %12, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %entry
  ret void

if.done:                                          ; preds = %cmp.or
  br label %for.init

for.init:                                         ; preds = %if.done
  %13 = sub i64 %1, 1
  store i64 %13, ptr %i, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %for.init
  %14 = load i64, ptr %i, align 8
  %15 = icmp sge i64 %14, 0
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  br label %if.init

if.init:                                          ; preds = %for.body
  %18 = load ptr, ptr %2, align 8
  %19 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %18, i32 0, i32 0
  %20 = load i64, ptr %i, align 8
  %21 = getelementptr [384 x i8], ptr %19, i64 0, i64 %20
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20a", i64 47 }, i32 482, i32 20, i64 %20, i64 384)
  %22 = load i8, ptr %21, align 1
  store i8 %22, ptr %c, align 1
  %23 = load i8, ptr %c, align 1
  %24 = icmp ult i8 %23, 57
  %25 = zext i1 %24 to i8
  %26 = icmp ne i8 %25, 0
  br i1 %26, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.init
  %27 = load ptr, ptr %2, align 8
  %28 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %27, i32 0, i32 0
  %29 = load i64, ptr %i, align 8
  %30 = getelementptr [384 x i8], ptr %28, i64 0, i64 %29
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20a", i64 47 }, i32 483, i32 13, i64 %29, i64 384)
  %31 = load i8, ptr %30, align 1
  %32 = add i8 %31, 1
  store i8 %32, ptr %30, align 1
  %33 = load ptr, ptr %2, align 8
  %34 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %33, i32 0, i32 1
  %35 = load i64, ptr %i, align 8
  %36 = add i64 %35, 1
  store i64 %36, ptr %34, align 8
  ret void

if.done2:                                         ; preds = %if.init
  br label %for.post

for.post:                                         ; preds = %if.done2
  %37 = load i64, ptr %i, align 8
  %38 = sub i64 %37, 1
  store i64 %38, ptr %i, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %39 = load ptr, ptr %2, align 8
  %40 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %39, i32 0, i32 0
  %41 = getelementptr [384 x i8], ptr %40, i64 0, i64 0
  store i8 49, ptr %41, align 1
  %42 = load ptr, ptr %2, align 8
  %43 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %42, i32 0, i32 1
  store i64 1, ptr %43, align 8
  %44 = load ptr, ptr %2, align 8
  %45 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %44, i32 0, i32 2
  %46 = load i64, ptr %45, align 8
  %47 = add i64 %46, 1
  store i64 %47, ptr %45, align 8
  ret void
}

; Function Attrs: alwaysinline
define internal i8 @"runtime::map_hash_is_valid"(i64 %0) #3 {
decls:
  %1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = icmp ne i64 %0, 0
  %3 = zext i1 %2 to i8
  %4 = and i64 %0, -9223372036854775808
  %5 = icmp eq i64 %4, 0
  %6 = zext i1 %5 to i8
  %7 = and i8 %3, %6
  ret i8 %7
}

define internal void @"main::byte_world_make"(ptr noalias sret(%"main::Byte_World") %agg.result, i64 %0, i32 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca i64, align 8
  %3 = alloca i32, align 4
  %cell_count = alloca i64, align 8
  %4 = alloca { i64, i64 }, align 16
  %5 = alloca { ptr, i64 }, align 8
  %6 = alloca { { ptr, i64 }, i8 }, align 8
  %grid = alloca { ptr, i64 }, align 8
  %7 = alloca { i64, i64 }, align 16
  %8 = alloca { ptr, i64 }, align 8
  %9 = alloca { { ptr, i64 }, i8 }, align 8
  %alpha = alloca { ptr, i64 }, align 8
  %10 = alloca { i64, i64 }, align 16
  %11 = alloca { ptr, i64 }, align 8
  %12 = alloca { { ptr, i64 }, i8 }, align 8
  %occ_stamp = alloca { ptr, i64 }, align 8
  %13 = alloca %"main::Spark_Buffer", align 8
  %14 = alloca { i64, i64 }, align 16
  %15 = alloca { ptr, i64 }, align 8
  %16 = alloca { { ptr, i64 }, i8 }, align 8
  %sparks_a = alloca %"main::Spark_Buffer", align 8
  %17 = alloca %"main::Spark_Buffer", align 8
  %18 = alloca { i64, i64 }, align 16
  %19 = alloca { ptr, i64 }, align 8
  %20 = alloca { { ptr, i64 }, i8 }, align 8
  %sparks_b = alloca %"main::Spark_Buffer", align 8
  %21 = alloca %"main::Byte_World", align 8
  %w = alloca %"main::Byte_World", align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %2, align 8
  store i32 %1, ptr %3, align 4
  %22 = icmp sgt i64 %0, 0
  %23 = zext i1 %22 to i8
  %24 = load %"runtime::Source_Code_Location", ptr @"scl$[byte_world_make10720]", align 8
  call void @"runtime::assert"(i8 %23, %..string { ptr @"csbs$byte_world$254", i64 8 }, ptr @"scl$[byte_world_make10720]", ptr %__.context_ptr)
  %25 = mul i64 %0, %0
  store i64 %25, ptr %cell_count, align 8
  %26 = load i64, ptr %cell_count, align 8
  %27 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 0
  %28 = load %"runtime::Allocator", ptr %27, align 8
  %29 = load %"runtime::Source_Code_Location", ptr @"scl$[byte_world_make10831]", align 8
  store %"runtime::Allocator" %28, ptr %4, align 8
  %30 = load { i64, i64 }, ptr %4, align 8
  call void @llvm.memset.inline.p0.i64(ptr %5, i8 0, i64 16, i1 false)
  %31 = call i8 @"runtime::make_slice:proc(T:$[]u8,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]u8,err:runtime::Allocator_Error)"(i64 %26, { i64, i64 } %30, ptr @"scl$[byte_world_make10831]", ptr %5, ptr %__.context_ptr)
  %32 = load { ptr, i64 }, ptr %5, align 8
  %33 = load { { ptr, i64 }, i8 }, ptr %6, align 8
  store { ptr, i64 } %32, ptr %grid, align 8
  %34 = load i64, ptr %cell_count, align 8
  %35 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 0
  %36 = load %"runtime::Allocator", ptr %35, align 8
  %37 = load %"runtime::Source_Code_Location", ptr @"scl$[byte_world_make10864]", align 8
  store %"runtime::Allocator" %36, ptr %7, align 8
  %38 = load { i64, i64 }, ptr %7, align 8
  call void @llvm.memset.inline.p0.i64(ptr %8, i8 0, i64 16, i1 false)
  %39 = call i8 @"runtime::make_slice:proc(T:$[]f32,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]f32,err:runtime::Allocator_Error)"(i64 %34, { i64, i64 } %38, ptr @"scl$[byte_world_make10864]", ptr %8, ptr %__.context_ptr)
  %40 = load { ptr, i64 }, ptr %8, align 8
  %41 = load { { ptr, i64 }, i8 }, ptr %9, align 8
  store { ptr, i64 } %40, ptr %alpha, align 8
  %42 = load i64, ptr %cell_count, align 8
  %43 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 0
  %44 = load %"runtime::Allocator", ptr %43, align 8
  %45 = load %"runtime::Source_Code_Location", ptr @"scl$[byte_world_make10902]", align 8
  store %"runtime::Allocator" %44, ptr %10, align 8
  %46 = load { i64, i64 }, ptr %10, align 8
  call void @llvm.memset.inline.p0.i64(ptr %11, i8 0, i64 16, i1 false)
  %47 = call i8 @"runtime::make_slice:proc(T:$[]u32,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]u32,err:runtime::Allocator_Error)"(i64 %42, { i64, i64 } %46, ptr @"scl$[byte_world_make10902]", ptr %11, ptr %__.context_ptr)
  %48 = load { ptr, i64 }, ptr %11, align 8
  %49 = load { { ptr, i64 }, i8 }, ptr %12, align 8
  store { ptr, i64 } %48, ptr %occ_stamp, align 8
  call void @llvm.memset.inline.p0.i64(ptr %13, i8 0, i64 24, i1 false)
  store %"main::Spark_Buffer" zeroinitializer, ptr %13, align 8
  %50 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 0
  %51 = load %"runtime::Allocator", ptr %50, align 8
  %52 = load %"runtime::Source_Code_Location", ptr @"scl$[byte_world_make11028]", align 8
  store %"runtime::Allocator" %51, ptr %14, align 8
  %53 = load { i64, i64 }, ptr %14, align 8
  call void @llvm.memset.inline.p0.i64(ptr %15, i8 0, i64 16, i1 false)
  %54 = call i8 @"runtime::make_slice:proc(T:$[]main::Spark,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]main::Spark,err:runtime::Allocator_Error)"(i64 150000, { i64, i64 } %53, ptr @"scl$[byte_world_make11028]", ptr %15, ptr %__.context_ptr)
  %55 = load { ptr, i64 }, ptr %15, align 8
  %56 = load { { ptr, i64 }, i8 }, ptr %16, align 8
  %57 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %13, i32 0, i32 0
  store { ptr, i64 } %55, ptr %57, align 8
  %58 = load %"main::Spark_Buffer", ptr %13, align 8
  store %"main::Spark_Buffer" %58, ptr %sparks_a, align 8
  call void @llvm.memset.inline.p0.i64(ptr %17, i8 0, i64 24, i1 false)
  store %"main::Spark_Buffer" zeroinitializer, ptr %17, align 8
  %59 = getelementptr inbounds nuw %"runtime::Context", ptr %__.context_ptr, i32 0, i32 0
  %60 = load %"runtime::Allocator", ptr %59, align 8
  %61 = load %"runtime::Source_Code_Location", ptr @"scl$[byte_world_make11098]", align 8
  store %"runtime::Allocator" %60, ptr %18, align 8
  %62 = load { i64, i64 }, ptr %18, align 8
  call void @llvm.memset.inline.p0.i64(ptr %19, i8 0, i64 16, i1 false)
  %63 = call i8 @"runtime::make_slice:proc(T:$[]main::Spark,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]main::Spark,err:runtime::Allocator_Error)"(i64 150000, { i64, i64 } %62, ptr @"scl$[byte_world_make11098]", ptr %19, ptr %__.context_ptr)
  %64 = load { ptr, i64 }, ptr %19, align 8
  %65 = load { { ptr, i64 }, i8 }, ptr %20, align 8
  %66 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %17, i32 0, i32 0
  store { ptr, i64 } %64, ptr %66, align 8
  %67 = load %"main::Spark_Buffer", ptr %17, align 8
  store %"main::Spark_Buffer" %67, ptr %sparks_b, align 8
  call void @llvm.memset.p0.i64(ptr %21, i8 0, i64 136, i1 false)
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %21, ptr @"ggv$main::byte_world_make$1", i64 136, i1 false)
  %68 = getelementptr inbounds nuw %"main::Byte_World", ptr %21, i32 0, i32 0
  store i64 %0, ptr %68, align 8
  %69 = load { ptr, i64 }, ptr %grid, align 8
  %70 = getelementptr inbounds nuw %"main::Byte_World", ptr %21, i32 0, i32 2
  store { ptr, i64 } %69, ptr %70, align 8
  %71 = load { ptr, i64 }, ptr %alpha, align 8
  %72 = getelementptr inbounds nuw %"main::Byte_World", ptr %21, i32 0, i32 3
  store { ptr, i64 } %71, ptr %72, align 8
  %73 = load %"main::Spark_Buffer", ptr %sparks_a, align 8
  %74 = getelementptr inbounds nuw %"main::Byte_World", ptr %21, i32 0, i32 4
  store %"main::Spark_Buffer" %73, ptr %74, align 8
  %75 = load %"main::Spark_Buffer", ptr %sparks_b, align 8
  %76 = getelementptr inbounds nuw %"main::Byte_World", ptr %21, i32 0, i32 5
  store %"main::Spark_Buffer" %75, ptr %76, align 8
  %77 = load { ptr, i64 }, ptr %occ_stamp, align 8
  %78 = getelementptr inbounds nuw %"main::Byte_World", ptr %21, i32 0, i32 6
  store { ptr, i64 } %77, ptr %78, align 8
  %79 = getelementptr inbounds nuw %"main::Byte_World", ptr %21, i32 0, i32 8
  store i32 %1, ptr %79, align 4
  %80 = load %"main::Byte_World", ptr %21, align 8
  call void @llvm.memset.p0.i64(ptr %w, i8 0, i64 136, i1 false)
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %w, ptr align 8 %21, i64 136, i1 false)
  call void @"main::byte_world_reseed"(ptr %w, i32 %1, ptr %__.context_ptr)
  %81 = load %"main::Byte_World", ptr %w, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %agg.result, ptr %w, i64 136, i1 false)
  ret void
}

declare i64 @pthread_self()

; Function Attrs: alwaysinline
define internal i64 @"runtime::map_seed"(ptr %0) #3 {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %1 = load %"runtime::Raw_Map", ptr %0, align 8
  %2 = call i64 @"runtime::map_data"(ptr %0)
  %3 = call i64 @"runtime::map_seed_from_map_data"(i64 %2)
  ret i64 %3
}

; Function Attrs: alwaysinline
define internal i64 @"runtime::map_seed_from_map_data"(i64 %0) #3 {
decls:
  %1 = alloca i64, align 8
  %mix = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = add i64 %0, -7046029254386353131
  store i64 %2, ptr %mix, align 8
  %3 = load i64, ptr %mix, align 8
  %4 = load i64, ptr %mix, align 8
  %5 = lshr i64 %4, 30
  %6 = select i1 true, i64 %5, i64 0
  %7 = xor i64 %3, %6
  %8 = mul i64 %7, -4658895280553007687
  store i64 %8, ptr %mix, align 8
  %9 = load i64, ptr %mix, align 8
  %10 = load i64, ptr %mix, align 8
  %11 = lshr i64 %10, 27
  %12 = select i1 true, i64 %11, i64 0
  %13 = xor i64 %9, %12
  %14 = mul i64 %13, -7723592293110705685
  store i64 %14, ptr %mix, align 8
  %15 = load i64, ptr %mix, align 8
  %16 = load i64, ptr %mix, align 8
  %17 = lshr i64 %16, 31
  %18 = select i1 true, i64 %17, i64 0
  %19 = xor i64 %15, %18
  ret i64 %19
}

define internal i64 @"runtime::memory_compare"(ptr %0, ptr %1, i64 %2) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca ptr, align 8
  %5 = alloca i64, align 8
  %a = alloca ptr, align 8
  %b = alloca ptr, align 8
  %n = alloca i64, align 8
  %i = alloca i64, align 8
  %m = alloca i64, align 8
  %load_a = alloca <16 x i8>, align 16
  %load_b = alloca <16 x i8>, align 16
  %comparison = alloca <16 x i8>, align 16
  %sentinel = alloca <16 x i8>, align 16
  %indices = alloca <16 x i8>, align 16
  %index_select = alloca <16 x i8>, align 16
  %index_reduce = alloca i64, align 8
  %load_a9 = alloca <8 x i8>, align 8
  %load_b10 = alloca <8 x i8>, align 8
  %comparison11 = alloca <8 x i8>, align 8
  %sentinel13 = alloca <8 x i8>, align 8
  %indices14 = alloca <8 x i8>, align 8
  %index_select15 = alloca <8 x i8>, align 8
  %index_reduce16 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store ptr %1, ptr %4, align 8
  store i64 %2, ptr %5, align 8
  %6 = icmp eq ptr %0, %1
  %7 = zext i1 %6 to i8
  %8 = icmp eq i8 1, %7
  br i1 %8, label %switch.case.body, label %switch.case.next

switch.case.next:                                 ; preds = %entry
  %9 = icmp eq ptr %0, null
  %10 = zext i1 %9 to i8
  %11 = icmp eq i8 1, %10
  br i1 %11, label %switch.case.body2, label %switch.case.next1

switch.case.body:                                 ; preds = %entry
  ret i64 0

switch.case.next1:                                ; preds = %switch.case.next
  %12 = icmp eq ptr %1, null
  %13 = zext i1 %12 to i8
  %14 = icmp eq i8 1, %13
  br i1 %14, label %switch.case.body4, label %switch.case.next3

switch.case.body2:                                ; preds = %switch.case.next
  ret i64 -1

switch.case.next3:                                ; preds = %switch.case.next1
  br label %switch.done

switch.case.body4:                                ; preds = %switch.case.next1
  ret i64 1

switch.done:                                      ; preds = %switch.case.next3
  store ptr %0, ptr %a, align 8
  store ptr %1, ptr %b, align 8
  store i64 %2, ptr %n, align 8
  store i64 0, ptr %i, align 8
  store i64 0, ptr %m, align 8
  %15 = load i64, ptr %n, align 8
  %16 = load i64, ptr %i, align 8
  %17 = sub i64 %15, %16
  %18 = lshr i64 %17, 4
  %19 = mul i64 %18, 16
  store i64 %19, ptr %m, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %switch.done
  %20 = load i64, ptr %i, align 8
  %21 = load i64, ptr %m, align 8
  %22 = icmp ult i64 %20, %21
  %23 = zext i1 %22 to i8
  %24 = icmp ne i8 %23, 0
  br i1 %24, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %25 = load ptr, ptr %a, align 8
  %26 = load i64, ptr %i, align 8
  %27 = getelementptr i8, ptr %25, i64 %26
  %28 = load <16 x i8>, ptr %27, align 1
  store <16 x i8> %28, ptr %load_a, align 16
  %29 = load ptr, ptr %b, align 8
  %30 = load i64, ptr %i, align 8
  %31 = getelementptr i8, ptr %29, i64 %30
  %32 = load <16 x i8>, ptr %31, align 1
  store <16 x i8> %32, ptr %load_b, align 16
  %33 = load <16 x i8>, ptr %load_a, align 16
  %34 = load <16 x i8>, ptr %load_b, align 16
  %35 = icmp ne <16 x i8> %33, %34
  %36 = sext <16 x i1> %35 to <16 x i8>
  store <16 x i8> %36, ptr %comparison, align 16
  %37 = load <16 x i8>, ptr %comparison, align 16
  %38 = call i8 @llvm.vector.reduce.or.v16i8(<16 x i8> %37)
  %39 = icmp ne i8 %38, 0
  %40 = zext i1 %39 to i8
  %41 = icmp ne i8 %40, 0
  br i1 %41, label %if.then, label %if.done6

if.then:                                          ; preds = %for.body
  store <16 x i8> splat (i8 -1), ptr %sentinel, align 16
  store <16 x i8> <i8 0, i8 1, i8 2, i8 3, i8 4, i8 5, i8 6, i8 7, i8 8, i8 9, i8 10, i8 11, i8 12, i8 13, i8 14, i8 15>, ptr %indices, align 16
  %42 = load <16 x i8>, ptr %comparison, align 16
  %43 = load <16 x i8>, ptr %indices, align 16
  %44 = load <16 x i8>, ptr %sentinel, align 16
  %45 = load <16 x i8>, ptr %indices, align 16
  %46 = load <16 x i8>, ptr %sentinel, align 16
  %47 = icmp ne <16 x i8> %42, zeroinitializer
  %48 = select <16 x i1> %47, <16 x i8> %45, <16 x i8> %46
  store <16 x i8> %48, ptr %index_select, align 16
  %49 = load <16 x i8>, ptr %index_select, align 16
  %50 = call i8 @llvm.vector.reduce.umin.v16i8(<16 x i8> %49)
  %51 = zext i8 %50 to i64
  store i64 %51, ptr %index_reduce, align 8
  %52 = load ptr, ptr %a, align 8
  %53 = load i64, ptr %i, align 8
  %54 = load i64, ptr %index_reduce, align 8
  %55 = add i64 %53, %54
  %56 = getelementptr i8, ptr %52, i64 %55
  %57 = load i8, ptr %56, align 1
  %58 = load ptr, ptr %b, align 8
  %59 = load i64, ptr %i, align 8
  %60 = load i64, ptr %index_reduce, align 8
  %61 = add i64 %59, %60
  %62 = getelementptr i8, ptr %58, i64 %61
  %63 = load i8, ptr %62, align 1
  %64 = icmp ult i8 %57, %63
  %65 = zext i1 %64 to i8
  %66 = icmp ne i8 %65, 0
  br i1 %66, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then
  br label %if.done

if.else:                                          ; preds = %if.then
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then5
  %67 = phi i64 [ -1, %if.then5 ], [ 1, %if.else ]
  ret i64 %67

if.done6:                                         ; preds = %for.body
  br label %for.post

for.post:                                         ; preds = %if.done6
  %68 = load i64, ptr %i, align 8
  %69 = add i64 %68, 16
  store i64 %69, ptr %i, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %70 = load i64, ptr %n, align 8
  %71 = load i64, ptr %i, align 8
  %72 = sub i64 %70, %71
  %73 = lshr i64 %72, 3
  %74 = mul i64 %73, 8
  store i64 %74, ptr %m, align 8
  br label %for.loop7

for.loop7:                                        ; preds = %for.post21, %for.done
  %75 = load i64, ptr %i, align 8
  %76 = load i64, ptr %m, align 8
  %77 = icmp ult i64 %75, %76
  %78 = zext i1 %77 to i8
  %79 = icmp ne i8 %78, 0
  br i1 %79, label %for.body8, label %for.done22

for.body8:                                        ; preds = %for.loop7
  %80 = load ptr, ptr %a, align 8
  %81 = load i64, ptr %i, align 8
  %82 = getelementptr i8, ptr %80, i64 %81
  %83 = load <8 x i8>, ptr %82, align 1
  store <8 x i8> %83, ptr %load_a9, align 8
  %84 = load ptr, ptr %b, align 8
  %85 = load i64, ptr %i, align 8
  %86 = getelementptr i8, ptr %84, i64 %85
  %87 = load <8 x i8>, ptr %86, align 1
  store <8 x i8> %87, ptr %load_b10, align 8
  %88 = load <8 x i8>, ptr %load_a9, align 8
  %89 = load <8 x i8>, ptr %load_b10, align 8
  %90 = icmp ne <8 x i8> %88, %89
  %91 = sext <8 x i1> %90 to <8 x i8>
  store <8 x i8> %91, ptr %comparison11, align 8
  %92 = load <8 x i8>, ptr %comparison11, align 8
  %93 = call i8 @llvm.vector.reduce.or.v8i8(<8 x i8> %92)
  %94 = icmp ne i8 %93, 0
  %95 = zext i1 %94 to i8
  %96 = icmp ne i8 %95, 0
  br i1 %96, label %if.then12, label %if.done20

if.then12:                                        ; preds = %for.body8
  store <8 x i8> splat (i8 -1), ptr %sentinel13, align 8
  store <8 x i8> <i8 0, i8 1, i8 2, i8 3, i8 4, i8 5, i8 6, i8 7>, ptr %indices14, align 8
  %97 = load <8 x i8>, ptr %comparison11, align 8
  %98 = load <8 x i8>, ptr %indices14, align 8
  %99 = load <8 x i8>, ptr %sentinel13, align 8
  %100 = load <8 x i8>, ptr %indices14, align 8
  %101 = load <8 x i8>, ptr %sentinel13, align 8
  %102 = icmp ne <8 x i8> %97, zeroinitializer
  %103 = select <8 x i1> %102, <8 x i8> %100, <8 x i8> %101
  store <8 x i8> %103, ptr %index_select15, align 8
  %104 = load <8 x i8>, ptr %index_select15, align 8
  %105 = call i8 @llvm.vector.reduce.umin.v8i8(<8 x i8> %104)
  %106 = zext i8 %105 to i64
  store i64 %106, ptr %index_reduce16, align 8
  %107 = load ptr, ptr %a, align 8
  %108 = load i64, ptr %i, align 8
  %109 = load i64, ptr %index_reduce16, align 8
  %110 = add i64 %108, %109
  %111 = getelementptr i8, ptr %107, i64 %110
  %112 = load i8, ptr %111, align 1
  %113 = load ptr, ptr %b, align 8
  %114 = load i64, ptr %i, align 8
  %115 = load i64, ptr %index_reduce16, align 8
  %116 = add i64 %114, %115
  %117 = getelementptr i8, ptr %113, i64 %116
  %118 = load i8, ptr %117, align 1
  %119 = icmp ult i8 %112, %118
  %120 = zext i1 %119 to i8
  %121 = icmp ne i8 %120, 0
  br i1 %121, label %if.then17, label %if.else18

if.then17:                                        ; preds = %if.then12
  br label %if.done19

if.else18:                                        ; preds = %if.then12
  br label %if.done19

if.done19:                                        ; preds = %if.else18, %if.then17
  %122 = phi i64 [ -1, %if.then17 ], [ 1, %if.else18 ]
  ret i64 %122

if.done20:                                        ; preds = %for.body8
  br label %for.post21

for.post21:                                       ; preds = %if.done20
  %123 = load i64, ptr %i, align 8
  %124 = add i64 %123, 8
  store i64 %124, ptr %i, align 8
  br label %for.loop7

for.done22:                                       ; preds = %for.loop7
  br label %for.loop23

for.loop23:                                       ; preds = %for.post30, %for.done22
  %125 = load i64, ptr %i, align 8
  %126 = load i64, ptr %n, align 8
  %127 = icmp ult i64 %125, %126
  %128 = zext i1 %127 to i8
  %129 = icmp ne i8 %128, 0
  br i1 %129, label %for.body24, label %for.done31

for.body24:                                       ; preds = %for.loop23
  %130 = load ptr, ptr %a, align 8
  %131 = load i64, ptr %i, align 8
  %132 = getelementptr i8, ptr %130, i64 %131
  %133 = load i8, ptr %132, align 1
  %134 = load ptr, ptr %b, align 8
  %135 = load i64, ptr %i, align 8
  %136 = getelementptr i8, ptr %134, i64 %135
  %137 = load i8, ptr %136, align 1
  %138 = xor i8 %133, %137
  %139 = icmp ne i8 %138, 0
  %140 = zext i1 %139 to i8
  %141 = icmp ne i8 %140, 0
  br i1 %141, label %if.then25, label %if.done29

if.then25:                                        ; preds = %for.body24
  %142 = load ptr, ptr %a, align 8
  %143 = load i64, ptr %i, align 8
  %144 = getelementptr i8, ptr %142, i64 %143
  %145 = load i8, ptr %144, align 1
  %146 = zext i8 %145 to i64
  %147 = load ptr, ptr %b, align 8
  %148 = load i64, ptr %i, align 8
  %149 = getelementptr i8, ptr %147, i64 %148
  %150 = load i8, ptr %149, align 1
  %151 = zext i8 %150 to i64
  %152 = sub i64 %146, %151
  %153 = icmp slt i64 %152, 0
  %154 = zext i1 %153 to i8
  %155 = icmp ne i8 %154, 0
  br i1 %155, label %if.then26, label %if.else27

if.then26:                                        ; preds = %if.then25
  br label %if.done28

if.else27:                                        ; preds = %if.then25
  br label %if.done28

if.done28:                                        ; preds = %if.else27, %if.then26
  %156 = phi i64 [ -1, %if.then26 ], [ 1, %if.else27 ]
  ret i64 %156

if.done29:                                        ; preds = %for.body24
  br label %for.post30

for.post30:                                       ; preds = %if.done29
  %157 = load i64, ptr %i, align 8
  %158 = add i64 %157, 1
  store i64 %158, ptr %i, align 8
  br label %for.loop23

for.done31:                                       ; preds = %for.loop23
  ret i64 0
}

declare i32 @pthread_setcancelstate(i32, ptr)

declare i32 @pthread_setcanceltype(i32, ptr)

define internal i32 @"os::[errors.odin]::error_to_io_error"(i64 %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca %"os::Error", align 16
  %2 = alloca { i32, i8 }, align 4
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %3 = load %"os::Error", ptr %1, align 4
  %4 = getelementptr inbounds nuw %"os::Error", ptr %1, i32 0, i32 1
  %5 = load i32, ptr %4, align 4
  %6 = icmp eq i32 %5, 0
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i32 0

if.done:                                          ; preds = %entry
  call void @llvm.memset.inline.p0.i64(ptr %2, i8 0, i64 5, i1 false)
  %9 = getelementptr inbounds nuw { i32, i8 }, ptr %2, i32 0, i32 0
  %10 = getelementptr inbounds nuw { i32, i8 }, ptr %2, i32 0, i32 1
  %11 = getelementptr inbounds nuw %"os::Error", ptr %1, i32 0, i32 1
  %12 = load i32, ptr %11, align 4
  %13 = icmp eq i32 %12, 2
  br i1 %13, label %union_cast.ok, label %union_cast.end

union_cast.ok:                                    ; preds = %if.done
  %14 = load i32, ptr %1, align 4
  store i32 %14, ptr %9, align 4
  store i8 1, ptr %10, align 1
  br label %union_cast.end

union_cast.end:                                   ; preds = %union_cast.ok, %if.done
  %15 = load { i32, i8 }, ptr %2, align 4
  %16 = getelementptr inbounds nuw { i32, i8 }, ptr %2, i32 0, i32 0
  %17 = load i32, ptr %16, align 4
  %18 = getelementptr inbounds nuw { i32, i8 }, ptr %2, i32 0, i32 1
  %19 = load i8, ptr %18, align 1
  %20 = trunc i8 %19 to i1
  br i1 %20, label %or_else.then, label %or_else.else

or_else.then:                                     ; preds = %union_cast.end
  br label %or_else.done

or_else.else:                                     ; preds = %union_cast.end
  br label %or_else.done

or_else.done:                                     ; preds = %or_else.else, %or_else.then
  %21 = phi i32 [ %17, %or_else.then ], [ 14, %or_else.else ]
  ret i32 %21
}

define internal void @"strconv_decimal::round_down"(ptr %0, i64 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %4 = icmp slt i64 %1, 0
  %5 = zext i1 %4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %if.then, label %cmp.or

cmp.or:                                           ; preds = %entry
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %7, i32 0, i32 1
  %9 = load i64, ptr %8, align 8
  %10 = icmp sge i64 %1, %9
  %11 = zext i1 %10 to i8
  %12 = icmp ne i8 %11, 0
  br i1 %12, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.or, %entry
  ret void

if.done:                                          ; preds = %cmp.or
  %13 = load ptr, ptr %2, align 8
  %14 = getelementptr inbounds nuw %"strconv_decimal::Decimal", ptr %13, i32 0, i32 1
  store i64 %1, ptr %14, align 8
  call void @"strconv_decimal::trim"(ptr %0, ptr %__.context_ptr)
  ret void
}

define internal void @"main::byte_world_reseed"(ptr %0, i32 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i32, align 4
  %i = alloca i64, align 8
  %4 = alloca i64, align 8
  %i1 = alloca i64, align 8
  %i2 = alloca i64, align 8
  %5 = alloca i64, align 8
  %i5 = alloca i64, align 8
  %i8 = alloca i64, align 8
  %6 = alloca i64, align 8
  %i11 = alloca i64, align 8
  %r = alloca i32, align 4
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i32 %1, ptr %3, align 4
  %9 = load ptr, ptr %2, align 8
  %10 = getelementptr inbounds nuw %"main::Byte_World", ptr %9, i32 0, i32 1
  store i64 0, ptr %10, align 8
  %11 = load ptr, ptr %2, align 8
  %12 = getelementptr inbounds nuw %"main::Byte_World", ptr %11, i32 0, i32 8
  %13 = load ptr, ptr %2, align 8
  %14 = getelementptr inbounds nuw %"main::Byte_World", ptr %13, i32 0, i32 0
  %15 = load i64, ptr %14, align 8
  %16 = mul i64 %15, 73856093
  %17 = trunc i64 %16 to i32
  %18 = xor i32 %1, %17
  %19 = xor i32 %18, -1640531527
  store i32 %19, ptr %12, align 4
  %20 = load ptr, ptr %2, align 8
  %21 = getelementptr inbounds nuw %"main::Byte_World", ptr %20, i32 0, i32 4
  call void @"main::spark_buf_clear"(ptr %21, ptr %__.context_ptr)
  %22 = load ptr, ptr %2, align 8
  %23 = getelementptr inbounds nuw %"main::Byte_World", ptr %22, i32 0, i32 5
  call void @"main::spark_buf_clear"(ptr %23, ptr %__.context_ptr)
  store i64 0, ptr %i, align 8
  store i64 0, ptr %4, align 8
  br label %for.interval.loop

for.interval.loop:                                ; preds = %for.interval.post, %entry
  %24 = load ptr, ptr %2, align 8
  %25 = getelementptr inbounds nuw %"main::Byte_World", ptr %24, i32 0, i32 6
  %26 = load { ptr, i64 }, ptr %25, align 8
  %27 = getelementptr inbounds nuw { ptr, i64 }, ptr %25, i32 0, i32 1
  %28 = load i64, ptr %27, align 8
  %29 = load i64, ptr %i, align 8
  %30 = icmp slt i64 %29, %28
  br i1 %30, label %for.interval.body, label %for.interval.done

for.interval.body:                                ; preds = %for.interval.loop
  %31 = load i64, ptr %i, align 8
  %32 = load i64, ptr %4, align 8
  store i64 %31, ptr %i1, align 8
  %33 = load ptr, ptr %2, align 8
  %34 = getelementptr inbounds nuw %"main::Byte_World", ptr %33, i32 0, i32 6
  %35 = load { ptr, i64 }, ptr %34, align 8
  %36 = getelementptr inbounds nuw { ptr, i64 }, ptr %34, i32 0, i32 0
  %37 = load ptr, ptr %36, align 8
  %38 = load i64, ptr %i1, align 8
  %39 = getelementptr inbounds nuw { ptr, i64 }, ptr %34, i32 0, i32 1
  %40 = load i64, ptr %39, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 459, i32 15, i64 %38, i64 %40)
  %41 = getelementptr i32, ptr %37, i64 %38
  store i32 0, ptr %41, align 4
  br label %for.interval.post

for.interval.post:                                ; preds = %for.interval.body
  %42 = load i64, ptr %i, align 8
  %43 = add i64 %42, 1
  store i64 %43, ptr %i, align 8
  %44 = load i64, ptr %4, align 8
  %45 = add i64 %44, 1
  store i64 %45, ptr %4, align 8
  br label %for.interval.loop

for.interval.done:                                ; preds = %for.interval.loop
  %46 = load ptr, ptr %2, align 8
  %47 = getelementptr inbounds nuw %"main::Byte_World", ptr %46, i32 0, i32 7
  store i32 1, ptr %47, align 4
  store i64 0, ptr %i2, align 8
  store i64 0, ptr %5, align 8
  br label %for.interval.loop3

for.interval.loop3:                               ; preds = %for.interval.post6, %for.interval.done
  %48 = load ptr, ptr %2, align 8
  %49 = getelementptr inbounds nuw %"main::Byte_World", ptr %48, i32 0, i32 3
  %50 = load { ptr, i64 }, ptr %49, align 8
  %51 = getelementptr inbounds nuw { ptr, i64 }, ptr %49, i32 0, i32 1
  %52 = load i64, ptr %51, align 8
  %53 = load i64, ptr %i2, align 8
  %54 = icmp slt i64 %53, %52
  br i1 %54, label %for.interval.body4, label %for.interval.done7

for.interval.body4:                               ; preds = %for.interval.loop3
  %55 = load i64, ptr %i2, align 8
  %56 = load i64, ptr %5, align 8
  store i64 %55, ptr %i5, align 8
  %57 = load ptr, ptr %2, align 8
  %58 = getelementptr inbounds nuw %"main::Byte_World", ptr %57, i32 0, i32 3
  %59 = load { ptr, i64 }, ptr %58, align 8
  %60 = getelementptr inbounds nuw { ptr, i64 }, ptr %58, i32 0, i32 0
  %61 = load ptr, ptr %60, align 8
  %62 = load i64, ptr %i5, align 8
  %63 = getelementptr inbounds nuw { ptr, i64 }, ptr %58, i32 0, i32 1
  %64 = load i64, ptr %63, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 465, i32 11, i64 %62, i64 %64)
  %65 = getelementptr float, ptr %61, i64 %62
  store float 0x3FA99999A0000000, ptr %65, align 4
  br label %for.interval.post6

for.interval.post6:                               ; preds = %for.interval.body4
  %66 = load i64, ptr %i2, align 8
  %67 = add i64 %66, 1
  store i64 %67, ptr %i2, align 8
  %68 = load i64, ptr %5, align 8
  %69 = add i64 %68, 1
  store i64 %69, ptr %5, align 8
  br label %for.interval.loop3

for.interval.done7:                               ; preds = %for.interval.loop3
  store i64 0, ptr %i8, align 8
  store i64 0, ptr %6, align 8
  br label %for.interval.loop9

for.interval.loop9:                               ; preds = %for.interval.post18, %for.interval.done7
  %70 = load ptr, ptr %2, align 8
  %71 = getelementptr inbounds nuw %"main::Byte_World", ptr %70, i32 0, i32 2
  %72 = load { ptr, i64 }, ptr %71, align 8
  %73 = getelementptr inbounds nuw { ptr, i64 }, ptr %71, i32 0, i32 1
  %74 = load i64, ptr %73, align 8
  %75 = load i64, ptr %i8, align 8
  %76 = icmp slt i64 %75, %74
  br i1 %76, label %for.interval.body10, label %for.interval.done19

for.interval.body10:                              ; preds = %for.interval.loop9
  %77 = load i64, ptr %i8, align 8
  %78 = load i64, ptr %6, align 8
  store i64 %77, ptr %i11, align 8
  %79 = load ptr, ptr %2, align 8
  %80 = getelementptr inbounds nuw %"main::Byte_World", ptr %79, i32 0, i32 8
  %81 = call i32 @"main::rng_u32_bounded"(ptr %80, i32 100, ptr %__.context_ptr)
  store i32 %81, ptr %r, align 4
  %82 = load i32, ptr %r, align 4
  %83 = icmp ult i32 %82, 10
  %84 = zext i1 %83 to i8
  %85 = icmp ne i8 %84, 0
  br i1 %85, label %if.then, label %if.else

if.then:                                          ; preds = %for.interval.body10
  %86 = load ptr, ptr %2, align 8
  %87 = getelementptr inbounds nuw %"main::Byte_World", ptr %86, i32 0, i32 2
  %88 = load { ptr, i64 }, ptr %87, align 8
  %89 = getelementptr inbounds nuw { ptr, i64 }, ptr %87, i32 0, i32 0
  %90 = load ptr, ptr %89, align 8
  %91 = load i64, ptr %i11, align 8
  %92 = getelementptr inbounds nuw { ptr, i64 }, ptr %87, i32 0, i32 1
  %93 = load i64, ptr %92, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 473, i32 11, i64 %91, i64 %93)
  %94 = getelementptr i8, ptr %90, i64 %91
  %95 = load ptr, ptr %2, align 8
  %96 = getelementptr inbounds nuw %"main::Byte_World", ptr %95, i32 0, i32 8
  %97 = load i8, ptr @"main::RANGE_VOID_MAX", align 1
  %98 = zext i8 %97 to i32
  %99 = add i32 %98, 1
  %100 = call i32 @"main::rng_u32_bounded"(ptr %96, i32 %99, ptr %__.context_ptr)
  %101 = trunc i32 %100 to i8
  store i8 %101, ptr %94, align 1
  br label %if.done17

if.else:                                          ; preds = %for.interval.body10
  %102 = load i32, ptr %r, align 4
  %103 = icmp ult i32 %102, 15
  %104 = zext i1 %103 to i8
  %105 = icmp ne i8 %104, 0
  br i1 %105, label %if.then12, label %if.else13

if.then12:                                        ; preds = %if.else
  %106 = load ptr, ptr %2, align 8
  %107 = getelementptr inbounds nuw %"main::Byte_World", ptr %106, i32 0, i32 2
  %108 = load { ptr, i64 }, ptr %107, align 8
  %109 = getelementptr inbounds nuw { ptr, i64 }, ptr %107, i32 0, i32 0
  %110 = load ptr, ptr %109, align 8
  %111 = load i64, ptr %i11, align 8
  %112 = getelementptr inbounds nuw { ptr, i64 }, ptr %107, i32 0, i32 1
  %113 = load i64, ptr %112, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 476, i32 11, i64 %111, i64 %113)
  %114 = getelementptr i8, ptr %110, i64 %111
  %115 = load ptr, ptr %2, align 8
  %116 = getelementptr inbounds nuw %"main::Byte_World", ptr %115, i32 0, i32 8
  %117 = load i8, ptr @"main::RANGE_VOID_MAX", align 1
  %118 = zext i8 %117 to i64
  %119 = add i64 %118, 1
  %120 = load i8, ptr @"main::RANGE_WALL_MAX", align 1
  %121 = zext i8 %120 to i64
  %122 = call i64 @"main::rng_int_inclusive"(ptr %116, i64 %119, i64 %121, ptr %__.context_ptr)
  %123 = trunc i64 %122 to i8
  store i8 %123, ptr %114, align 1
  br label %if.done16

if.else13:                                        ; preds = %if.else
  %124 = load i32, ptr %r, align 4
  %125 = icmp ult i32 %124, 20
  %126 = zext i1 %125 to i8
  %127 = icmp ne i8 %126, 0
  br i1 %127, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else13
  %128 = load ptr, ptr %2, align 8
  %129 = getelementptr inbounds nuw %"main::Byte_World", ptr %128, i32 0, i32 2
  %130 = load { ptr, i64 }, ptr %129, align 8
  %131 = getelementptr inbounds nuw { ptr, i64 }, ptr %129, i32 0, i32 0
  %132 = load ptr, ptr %131, align 8
  %133 = load i64, ptr %i11, align 8
  %134 = getelementptr inbounds nuw { ptr, i64 }, ptr %129, i32 0, i32 1
  %135 = load i64, ptr %134, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 479, i32 11, i64 %133, i64 %135)
  %136 = getelementptr i8, ptr %132, i64 %133
  %137 = load ptr, ptr %2, align 8
  %138 = getelementptr inbounds nuw %"main::Byte_World", ptr %137, i32 0, i32 8
  %139 = load i8, ptr @"main::RANGE_WALL_MAX", align 1
  %140 = zext i8 %139 to i64
  %141 = add i64 %140, 1
  %142 = load i8, ptr @"main::RANGE_SOLAR_MAX", align 1
  %143 = zext i8 %142 to i64
  %144 = call i64 @"main::rng_int_inclusive"(ptr %138, i64 %141, i64 %143, ptr %__.context_ptr)
  %145 = trunc i64 %144 to i8
  store i8 %145, ptr %136, align 1
  br label %if.done

if.else15:                                        ; preds = %if.else13
  %146 = load ptr, ptr %2, align 8
  %147 = getelementptr inbounds nuw %"main::Byte_World", ptr %146, i32 0, i32 2
  %148 = load { ptr, i64 }, ptr %147, align 8
  %149 = getelementptr inbounds nuw { ptr, i64 }, ptr %147, i32 0, i32 0
  %150 = load ptr, ptr %149, align 8
  %151 = load i64, ptr %i11, align 8
  %152 = getelementptr inbounds nuw { ptr, i64 }, ptr %147, i32 0, i32 1
  %153 = load i64, ptr %152, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 482, i32 11, i64 %151, i64 %153)
  %154 = getelementptr i8, ptr %150, i64 %151
  %155 = load ptr, ptr %2, align 8
  %156 = getelementptr inbounds nuw %"main::Byte_World", ptr %155, i32 0, i32 8
  %157 = load i8, ptr @"main::RANGE_SOLAR_MAX", align 1
  %158 = zext i8 %157 to i64
  %159 = add i64 %158, 1
  %160 = call i64 @"main::rng_int_inclusive"(ptr %156, i64 %159, i64 255, ptr %__.context_ptr)
  %161 = trunc i64 %160 to i8
  store i8 %161, ptr %154, align 1
  br label %if.done

if.done:                                          ; preds = %if.else15, %if.then14
  br label %if.done16

if.done16:                                        ; preds = %if.done, %if.then12
  br label %if.done17

if.done17:                                        ; preds = %if.done16, %if.then
  br label %for.interval.post18

for.interval.post18:                              ; preds = %if.done17
  %162 = load i64, ptr %i8, align 8
  %163 = add i64 %162, 1
  store i64 %163, ptr %i8, align 8
  %164 = load i64, ptr %6, align 8
  %165 = add i64 %164, 1
  store i64 %165, ptr %6, align 8
  br label %for.interval.loop9

for.interval.done19:                              ; preds = %for.interval.loop9
  store i64 0, ptr %7, align 8
  store i64 0, ptr %8, align 8
  br label %for.interval.loop20

for.interval.loop20:                              ; preds = %for.interval.post24, %for.interval.done19
  %166 = load i64, ptr @"main::SPARK_COUNT_MIN", align 8
  %167 = load i64, ptr %7, align 8
  %168 = icmp slt i64 %167, %166
  br i1 %168, label %for.interval.body21, label %for.interval.done25

for.interval.body21:                              ; preds = %for.interval.loop20
  %169 = load i64, ptr %7, align 8
  %170 = load i64, ptr %8, align 8
  %171 = load ptr, ptr %2, align 8
  %172 = getelementptr inbounds nuw %"main::Byte_World", ptr %171, i32 0, i32 4
  %173 = call i8 @"main::spawn_spark_into_unique"(ptr %0, ptr %172, ptr %__.context_ptr)
  %174 = icmp ne i8 %173, 0
  br i1 %174, label %if.done23, label %if.then22

if.then22:                                        ; preds = %for.interval.body21
  br label %for.interval.done25

unreachable:                                      ; No predecessors!
  br label %if.done23

if.done23:                                        ; preds = %unreachable, %for.interval.body21
  br label %for.interval.post24

for.interval.post24:                              ; preds = %if.done23
  %175 = load i64, ptr %7, align 8
  %176 = add i64 %175, 1
  store i64 %176, ptr %7, align 8
  %177 = load i64, ptr %8, align 8
  %178 = add i64 %177, 1
  store i64 %178, ptr %8, align 8
  br label %for.interval.loop20

for.interval.done25:                              ; preds = %if.then22, %for.interval.loop20
  ret void
}

; Function Attrs: alwaysinline
define internal i64 @"runtime::map_desired_position"(ptr %0, i64 %1) #3 {
decls:
  %2 = alloca i64, align 8
  %capacity = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %1, ptr %2, align 8
  %3 = load %"runtime::Raw_Map", ptr %0, align 8
  %4 = call i64 @"runtime::map_log2_cap"(ptr %0)
  %5 = icmp ult i64 %4, 64
  %6 = shl i64 1, %4
  %7 = select i1 %5, i64 %6, i64 0
  store i64 %7, ptr %capacity, align 8
  %8 = load i64, ptr %capacity, align 8
  %9 = sub i64 %8, 1
  %10 = and i64 %1, %9
  ret i64 %10
}

; Function Attrs: alwaysinline
define internal i64 @"runtime::map_probe_distance"(ptr %0, i64 %1, i64 %2) #3 {
decls:
  %3 = alloca i64, align 8
  %4 = alloca i64, align 8
  %capacity = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %1, ptr %3, align 8
  store i64 %2, ptr %4, align 8
  %5 = load %"runtime::Raw_Map", ptr %0, align 8
  %6 = call i64 @"runtime::map_log2_cap"(ptr %0)
  %7 = icmp ult i64 %6, 64
  %8 = shl i64 1, %6
  %9 = select i1 %7, i64 %8, i64 0
  store i64 %9, ptr %capacity, align 8
  %10 = load i64, ptr %capacity, align 8
  %11 = add i64 %2, %10
  %12 = load %"runtime::Raw_Map", ptr %0, align 8
  %13 = call i64 @"runtime::map_desired_position"(ptr %0, i64 %1)
  %14 = sub i64 %11, %13
  %15 = load i64, ptr %capacity, align 8
  %16 = sub i64 %15, 1
  %17 = and i64 %14, %16
  ret i64 %17
}

define internal i8 @"runtime::delete_dynamic_array:proc(array:[dynamic]int,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  %3 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, align 8
  %4 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, align 8
  %7 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 2
  %8 = load i64, ptr %7, align 8
  %9 = mul i64 %8, 8
  %10 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 3
  %11 = load %"runtime::Allocator", ptr %10, align 8
  %12 = load %"runtime::Source_Code_Location", ptr %1, align 8
  store %"runtime::Allocator" %11, ptr %2, align 8
  %13 = load { i64, i64 }, ptr %2, align 8
  %14 = call i8 @"runtime::mem_free_with_size"(ptr %5, i64 %9, { i64, i64 } %13, ptr %1, ptr %__.context_ptr)
  ret i8 %14
}

define internal i8 @"runtime::delete_dynamic_array:proc(array:[dynamic]main::Pattern,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  %3 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, align 8
  %4 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, align 8
  %7 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 2
  %8 = load i64, ptr %7, align 8
  %9 = mul i64 %8, 72
  %10 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 3
  %11 = load %"runtime::Allocator", ptr %10, align 8
  %12 = load %"runtime::Source_Code_Location", ptr %1, align 8
  store %"runtime::Allocator" %11, ptr %2, align 8
  %13 = load { i64, i64 }, ptr %2, align 8
  %14 = call i8 @"runtime::mem_free_with_size"(ptr %5, i64 %9, { i64, i64 } %13, ptr %1, ptr %__.context_ptr)
  ret i8 %14
}

define internal i8 @"runtime::delete_dynamic_array:proc(array:[dynamic]main::Relative_Spark,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  %3 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, align 8
  %4 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, align 8
  %7 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 2
  %8 = load i64, ptr %7, align 8
  %9 = mul i64 %8, 10
  %10 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 3
  %11 = load %"runtime::Allocator", ptr %10, align 8
  %12 = load %"runtime::Source_Code_Location", ptr %1, align 8
  store %"runtime::Allocator" %11, ptr %2, align 8
  %13 = load { i64, i64 }, ptr %2, align 8
  %14 = call i8 @"runtime::mem_free_with_size"(ptr %5, i64 %9, { i64, i64 } %13, ptr %1, ptr %__.context_ptr)
  ret i8 %14
}

define internal i8 @"runtime::delete_dynamic_array:proc(array:[dynamic]u8,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"(ptr %0, ptr %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  %3 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, align 8
  %4 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 0
  %5 = load ptr, ptr %4, align 8
  %6 = load { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, align 8
  %7 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 2
  %8 = load i64, ptr %7, align 8
  %9 = mul i64 %8, 1
  %10 = getelementptr inbounds nuw { ptr, i64, i64, %"runtime::Allocator" }, ptr %0, i32 0, i32 3
  %11 = load %"runtime::Allocator", ptr %10, align 8
  %12 = load %"runtime::Source_Code_Location", ptr %1, align 8
  store %"runtime::Allocator" %11, ptr %2, align 8
  %13 = load { i64, i64 }, ptr %2, align 8
  %14 = call i8 @"runtime::mem_free_with_size"(ptr %5, i64 %9, { i64, i64 } %13, ptr %1, ptr %__.context_ptr)
  ret i8 %14
}

define internal i8 @"runtime::delete_slice:proc(array:[]u8,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"({ ptr, i64 } %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca { ptr, i64 }, align 8
  %4 = alloca %"runtime::Allocator", align 16
  %5 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %3, align 8
  store { i64, i64 } %1, ptr %4, align 8
  %6 = load %"runtime::Allocator", ptr %4, align 8
  %7 = extractvalue { ptr, i64 } %0, 0
  %8 = extractvalue { ptr, i64 } %0, 1
  %9 = mul i64 %8, 1
  %10 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %6, ptr %5, align 8
  %11 = load { i64, i64 }, ptr %5, align 8
  %12 = call i8 @"runtime::mem_free_with_size"(ptr %7, i64 %9, { i64, i64 } %11, ptr %2, ptr %__.context_ptr)
  ret i8 %12
}

define internal i8 @"runtime::delete_slice:proc(array:[]main::Thread_Work,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"({ ptr, i64 } %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca { ptr, i64 }, align 8
  %4 = alloca %"runtime::Allocator", align 16
  %5 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %3, align 8
  store { i64, i64 } %1, ptr %4, align 8
  %6 = load %"runtime::Allocator", ptr %4, align 8
  %7 = extractvalue { ptr, i64 } %0, 0
  %8 = extractvalue { ptr, i64 } %0, 1
  %9 = mul i64 %8, 40
  %10 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %6, ptr %5, align 8
  %11 = load { i64, i64 }, ptr %5, align 8
  %12 = call i8 @"runtime::mem_free_with_size"(ptr %7, i64 %9, { i64, i64 } %11, ptr %2, ptr %__.context_ptr)
  ret i8 %12
}

define internal i8 @"runtime::delete_slice:proc(array:[]^thread::Thread,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"({ ptr, i64 } %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca { ptr, i64 }, align 8
  %4 = alloca %"runtime::Allocator", align 16
  %5 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %3, align 8
  store { i64, i64 } %1, ptr %4, align 8
  %6 = load %"runtime::Allocator", ptr %4, align 8
  %7 = extractvalue { ptr, i64 } %0, 0
  %8 = extractvalue { ptr, i64 } %0, 1
  %9 = mul i64 %8, 8
  %10 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %6, ptr %5, align 8
  %11 = load { i64, i64 }, ptr %5, align 8
  %12 = call i8 @"runtime::mem_free_with_size"(ptr %7, i64 %9, { i64, i64 } %11, ptr %2, ptr %__.context_ptr)
  ret i8 %12
}

define internal i8 @"runtime::delete_slice:proc(array:[]bool,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"({ ptr, i64 } %0, { i64, i64 } %1, ptr %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca { ptr, i64 }, align 8
  %4 = alloca %"runtime::Allocator", align 16
  %5 = alloca { i64, i64 }, align 16
  br label %entry

entry:                                            ; preds = %decls
  store { ptr, i64 } %0, ptr %3, align 8
  store { i64, i64 } %1, ptr %4, align 8
  %6 = load %"runtime::Allocator", ptr %4, align 8
  %7 = extractvalue { ptr, i64 } %0, 0
  %8 = extractvalue { ptr, i64 } %0, 1
  %9 = mul i64 %8, 1
  %10 = load %"runtime::Source_Code_Location", ptr %2, align 8
  store %"runtime::Allocator" %6, ptr %5, align 8
  %11 = load { i64, i64 }, ptr %5, align 8
  %12 = call i8 @"runtime::mem_free_with_size"(ptr %7, i64 %9, { i64, i64 } %11, ptr %2, ptr %__.context_ptr)
  ret i8 %12
}

define internal i8 @"reflect::is_enum"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %2 = alloca ptr, align 8
  %3 = alloca { i8, i8 }, align 1
  %ok = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %4 = icmp eq ptr %0, null
  %5 = zext i1 %4 to i8
  %6 = icmp ne i8 %5, 0
  br i1 %6, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  %7 = call ptr @"runtime::type_info_base"(ptr %0)
  store ptr %7, ptr %2, align 8
  %8 = load ptr, ptr %2, align 8
  %9 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %8, i32 0, i32 5
  %10 = load { [9 x i64], i64 }, ptr %9, align 8
  %11 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %9, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  %13 = icmp eq i64 %12, 21
  %14 = getelementptr inbounds nuw { i8, i8 }, ptr %3, i32 0, i32 1
  %15 = zext i1 %13 to i8
  store i8 %15, ptr %14, align 1
  %16 = load { i8, i8 }, ptr %3, align 1
  %17 = getelementptr inbounds nuw { i8, i8 }, ptr %3, i32 0, i32 0
  %18 = load i8, ptr %17, align 1
  %19 = getelementptr inbounds nuw { i8, i8 }, ptr %3, i32 0, i32 1
  %20 = load i8, ptr %19, align 1
  store i8 %20, ptr %ok, align 1
  %21 = load i8, ptr %ok, align 1
  ret i8 %21
}

define internal i64 @"runtime::map_kvh_data_dynamic"(ptr %0, ptr noalias %1, ptr noalias nonnull %2, ptr noalias nonnull %3, ptr noalias nonnull %4, ptr noalias nonnull %5) {
decls:
  %6 = alloca ptr, align 8
  %ks = alloca i64, align 8
  %vs = alloca i64, align 8
  %hs = alloca ptr, align 8
  %sk = alloca i64, align 8
  %sv = alloca i64, align 8
  %INFO_HS = alloca ptr, align 8
  %capacity = alloca i64, align 8
  %hs_ = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %1, ptr %6, align 8
  store i64 0, ptr %ks, align 8
  store i64 0, ptr %vs, align 8
  store ptr null, ptr %hs, align 8
  store i64 0, ptr %sk, align 8
  store i64 0, ptr %sv, align 8
  store ptr @"ggv$map_cell_info-13197927915248882629", ptr %INFO_HS, align 8
  %7 = load %"runtime::Raw_Map", ptr %0, align 8
  %8 = call i64 @"runtime::map_log2_cap"(ptr %0)
  %9 = icmp ult i64 %8, 64
  %10 = shl i64 1, %8
  %11 = select i1 %9, i64 %10, i64 0
  store i64 %11, ptr %capacity, align 8
  %12 = load %"runtime::Raw_Map", ptr %0, align 8
  %13 = call i64 @"runtime::map_data"(ptr %0)
  store i64 %13, ptr %ks, align 8
  %14 = load i64, ptr %ks, align 8
  %15 = load ptr, ptr %6, align 8
  %16 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %15, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  %18 = load i64, ptr %capacity, align 8
  %19 = call i64 @"runtime::map_cell_index_dynamic"(i64 %14, ptr %17, i64 %18)
  store i64 %19, ptr %vs, align 8
  %20 = load i64, ptr %vs, align 8
  %21 = load ptr, ptr %6, align 8
  %22 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %21, i32 0, i32 1
  %23 = load ptr, ptr %22, align 8
  %24 = load i64, ptr %capacity, align 8
  %25 = call i64 @"runtime::map_cell_index_dynamic"(i64 %20, ptr %23, i64 %24)
  store i64 %25, ptr %hs_, align 8
  %26 = load i64, ptr %hs_, align 8
  %27 = load ptr, ptr %INFO_HS, align 8
  %28 = load i64, ptr %capacity, align 8
  %29 = call i64 @"runtime::map_cell_index_dynamic"(i64 %26, ptr %27, i64 %28)
  store i64 %29, ptr %sk, align 8
  %30 = load i64, ptr %sk, align 8
  %31 = load ptr, ptr %6, align 8
  %32 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %31, i32 0, i32 0
  %33 = load ptr, ptr %32, align 8
  %34 = call i64 @"runtime::map_cell_index_dynamic_const:proc\22contextless\22(base:uintptr,info:^runtime::Map_Cell_Info,INDEX:$$2)->(:uintptr)"(i64 %30, ptr %33)
  store i64 %34, ptr %sv, align 8
  %35 = load i64, ptr %hs_, align 8
  %36 = inttoptr i64 %35 to ptr
  store ptr %36, ptr %hs, align 8
  %37 = load i64, ptr %ks, align 8
  %38 = load i64, ptr %vs, align 8
  %39 = load ptr, ptr %hs, align 8
  %40 = load i64, ptr %sk, align 8
  %41 = load i64, ptr %sv, align 8
  store i64 %37, ptr %ks, align 8
  store i64 %38, ptr %vs, align 8
  store ptr %39, ptr %hs, align 8
  store i64 %40, ptr %sk, align 8
  store i64 %41, ptr %sv, align 8
  store i64 %37, ptr %2, align 8
  store i64 %38, ptr %3, align 8
  store ptr %39, ptr %4, align 8
  store i64 %40, ptr %5, align 8
  ret i64 %41
}

define internal i64 @"runtime::memory_compare_zero"(ptr %0, i64 %1) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %n = alloca i64, align 8
  %i = alloca i64, align 8
  %m = alloca i64, align 8
  %bytes = alloca ptr, align 8
  %scanner16 = alloca <16 x i8>, align 16
  %load = alloca <16 x i8>, align 16
  %ne = alloca <16 x i8>, align 16
  %4 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  store i64 %1, ptr %n, align 8
  store i64 0, ptr %i, align 8
  store i64 0, ptr %m, align 8
  store ptr %0, ptr %bytes, align 8
  %5 = load i64, ptr %n, align 8
  %6 = icmp uge i64 %5, 8
  %7 = zext i1 %6 to i8
  %8 = icmp ne i8 %7, 0
  br i1 %8, label %if.then, label %if.done8

if.then:                                          ; preds = %entry
  store <16 x i8> zeroinitializer, ptr %scanner16, align 16
  %9 = load i64, ptr %n, align 8
  %10 = load i64, ptr %i, align 8
  %11 = sub i64 %9, %10
  %12 = lshr i64 %11, 4
  %13 = mul i64 %12, 16
  store i64 %13, ptr %m, align 8
  br label %for.loop

for.loop:                                         ; preds = %for.post, %if.then
  %14 = load i64, ptr %i, align 8
  %15 = load i64, ptr %m, align 8
  %16 = icmp ult i64 %14, %15
  %17 = zext i1 %16 to i8
  %18 = icmp ne i8 %17, 0
  br i1 %18, label %for.body, label %for.done

for.body:                                         ; preds = %for.loop
  %19 = load ptr, ptr %bytes, align 8
  %20 = load i64, ptr %i, align 8
  %21 = getelementptr i8, ptr %19, i64 %20
  %22 = load <16 x i8>, ptr %21, align 1
  store <16 x i8> %22, ptr %load, align 16
  %23 = load <16 x i8>, ptr %scanner16, align 16
  %24 = load <16 x i8>, ptr %load, align 16
  %25 = icmp ne <16 x i8> %23, %24
  %26 = sext <16 x i1> %25 to <16 x i8>
  store <16 x i8> %26, ptr %ne, align 16
  %27 = load <16 x i8>, ptr %ne, align 16
  %28 = call i8 @llvm.vector.reduce.or.v16i8(<16 x i8> %27)
  %29 = icmp ne i8 %28, 0
  %30 = zext i1 %29 to i8
  %31 = icmp ne i8 %30, 0
  br i1 %31, label %if.then1, label %if.done

if.then1:                                         ; preds = %for.body
  ret i64 1

if.done:                                          ; preds = %for.body
  br label %for.post

for.post:                                         ; preds = %if.done
  %32 = load i64, ptr %i, align 8
  %33 = add i64 %32, 16
  store i64 %33, ptr %i, align 8
  br label %for.loop

for.done:                                         ; preds = %for.loop
  %34 = load i64, ptr %n, align 8
  %35 = load i64, ptr %i, align 8
  %36 = sub i64 %34, %35
  %37 = lshr i64 %36, 3
  %38 = mul i64 %37, 8
  store i64 %38, ptr %m, align 8
  br label %for.loop2

for.loop2:                                        ; preds = %for.post6, %for.done
  %39 = load i64, ptr %i, align 8
  %40 = load i64, ptr %m, align 8
  %41 = icmp ult i64 %39, %40
  %42 = zext i1 %41 to i8
  %43 = icmp ne i8 %42, 0
  br i1 %43, label %for.body3, label %for.done7

for.body3:                                        ; preds = %for.loop2
  %44 = load ptr, ptr %bytes, align 8
  %45 = load i64, ptr %i, align 8
  %46 = getelementptr i8, ptr %44, i64 %45
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %4, ptr %46, i64 8, i1 false)
  %47 = load i64, ptr %4, align 8
  %48 = icmp ne i64 %47, 0
  %49 = zext i1 %48 to i8
  %50 = icmp ne i8 %49, 0
  br i1 %50, label %if.then4, label %if.done5

if.then4:                                         ; preds = %for.body3
  ret i64 1

if.done5:                                         ; preds = %for.body3
  br label %for.post6

for.post6:                                        ; preds = %if.done5
  %51 = load i64, ptr %i, align 8
  %52 = add i64 %51, 8
  store i64 %52, ptr %i, align 8
  br label %for.loop2

for.done7:                                        ; preds = %for.loop2
  br label %if.done8

if.done8:                                         ; preds = %for.done7, %entry
  br label %for.loop9

for.loop9:                                        ; preds = %for.post13, %if.done8
  %53 = load i64, ptr %i, align 8
  %54 = load i64, ptr %n, align 8
  %55 = icmp ult i64 %53, %54
  %56 = zext i1 %55 to i8
  %57 = icmp ne i8 %56, 0
  br i1 %57, label %for.body10, label %for.done14

for.body10:                                       ; preds = %for.loop9
  %58 = load ptr, ptr %bytes, align 8
  %59 = load i64, ptr %i, align 8
  %60 = getelementptr i8, ptr %58, i64 %59
  %61 = load i8, ptr %60, align 1
  %62 = icmp ne i8 %61, 0
  %63 = zext i1 %62 to i8
  %64 = icmp ne i8 %63, 0
  br i1 %64, label %if.then11, label %if.done12

if.then11:                                        ; preds = %for.body10
  ret i64 1

if.done12:                                        ; preds = %for.body10
  br label %for.post13

for.post13:                                       ; preds = %if.done12
  %65 = load i64, ptr %i, align 8
  %66 = add i64 %65, 1
  store i64 %66, ptr %i, align 8
  br label %for.loop9

for.done14:                                       ; preds = %for.loop9
  ret i64 0
}

define internal i8 @"main::spawn_spark_into"(ptr %0, ptr %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca ptr, align 8
  %hue = alloca i32, align 4
  %4 = alloca [4 x i8], align 16
  %color = alloca [4 x i8], align 1
  %5 = alloca %"main::Spark", align 8
  %s = alloca %"main::Spark", align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store ptr %1, ptr %3, align 8
  %6 = load ptr, ptr %3, align 8
  %7 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %6, i32 0, i32 1
  %8 = load i64, ptr %7, align 8
  %9 = load ptr, ptr %3, align 8
  %10 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %9, i32 0, i32 0
  %11 = load { ptr, i64 }, ptr %10, align 8
  %12 = getelementptr inbounds nuw { ptr, i64 }, ptr %10, i32 0, i32 1
  %13 = load i64, ptr %12, align 8
  %14 = icmp sge i64 %8, %13
  %15 = zext i1 %14 to i8
  %16 = icmp ne i8 %15, 0
  br i1 %16, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  %17 = load ptr, ptr %2, align 8
  %18 = getelementptr inbounds nuw %"main::Byte_World", ptr %17, i32 0, i32 8
  %19 = call i32 @"main::rng_u32_bounded"(ptr %18, i32 360, ptr %__.context_ptr)
  store i32 %19, ptr %hue, align 4
  %20 = load i32, ptr %hue, align 4
  %21 = call i32 @"main::hsv_to_rgb"(i32 %20, float 0x3FE99999A0000000, float 1.000000e+00, ptr %__.context_ptr)
  store i32 %21, ptr %4, align 4
  %22 = load [4 x i8], ptr %4, align 1
  store [4 x i8] %22, ptr %color, align 1
  call void @llvm.memset.p0.i64(ptr %5, i8 0, i64 64, i1 false)
  call void @llvm.memset.p0.i64(ptr %5, i8 0, i64 64, i1 false)
  %23 = load ptr, ptr %2, align 8
  %24 = getelementptr inbounds nuw %"main::Byte_World", ptr %23, i32 0, i32 8
  %25 = load ptr, ptr %2, align 8
  %26 = getelementptr inbounds nuw %"main::Byte_World", ptr %25, i32 0, i32 0
  %27 = load i64, ptr %26, align 8
  %28 = sub i64 %27, 1
  %29 = call i64 @"main::rng_int_inclusive"(ptr %24, i64 0, i64 %28, ptr %__.context_ptr)
  %30 = getelementptr inbounds nuw %"main::Spark", ptr %5, i32 0, i32 0
  store i64 %29, ptr %30, align 8
  %31 = load ptr, ptr %2, align 8
  %32 = getelementptr inbounds nuw %"main::Byte_World", ptr %31, i32 0, i32 8
  %33 = load ptr, ptr %2, align 8
  %34 = getelementptr inbounds nuw %"main::Byte_World", ptr %33, i32 0, i32 0
  %35 = load i64, ptr %34, align 8
  %36 = sub i64 %35, 1
  %37 = call i64 @"main::rng_int_inclusive"(ptr %32, i64 0, i64 %36, ptr %__.context_ptr)
  %38 = getelementptr inbounds nuw %"main::Spark", ptr %5, i32 0, i32 1
  store i64 %37, ptr %38, align 8
  %39 = load ptr, ptr %2, align 8
  %40 = getelementptr inbounds nuw %"main::Byte_World", ptr %39, i32 0, i32 8
  %41 = call i64 @"main::rng_choice_dir_3"(ptr %40, ptr %__.context_ptr)
  %42 = getelementptr inbounds nuw %"main::Spark", ptr %5, i32 0, i32 2
  store i64 %41, ptr %42, align 8
  %43 = load ptr, ptr %2, align 8
  %44 = getelementptr inbounds nuw %"main::Byte_World", ptr %43, i32 0, i32 8
  %45 = call i64 @"main::rng_choice_dir_3"(ptr %44, ptr %__.context_ptr)
  %46 = getelementptr inbounds nuw %"main::Spark", ptr %5, i32 0, i32 3
  store i64 %45, ptr %46, align 8
  %47 = load ptr, ptr %2, align 8
  %48 = getelementptr inbounds nuw %"main::Byte_World", ptr %47, i32 0, i32 8
  %49 = call i64 @"main::rng_int_inclusive"(ptr %48, i64 50, i64 80, ptr %__.context_ptr)
  %50 = sitofp i64 %49 to float
  %51 = getelementptr inbounds nuw %"main::Spark", ptr %5, i32 0, i32 4
  store float %50, ptr %51, align 4
  %52 = load [4 x i8], ptr %color, align 1
  %53 = getelementptr inbounds nuw %"main::Spark", ptr %5, i32 0, i32 9
  store [4 x i8] %52, ptr %53, align 1
  %54 = load %"main::Spark", ptr %5, align 8
  call void @llvm.memset.p0.i64(ptr %s, i8 0, i64 64, i1 false)
  store %"main::Spark" %54, ptr %s, align 8
  %55 = getelementptr inbounds nuw %"main::Spark", ptr %s, i32 0, i32 2
  %56 = load i64, ptr %55, align 8
  %57 = icmp eq i64 %56, 0
  %58 = zext i1 %57 to i8
  %59 = icmp ne i8 %58, 0
  br i1 %59, label %cmp.and, label %if.done2

cmp.and:                                          ; preds = %if.done
  %60 = getelementptr inbounds nuw %"main::Spark", ptr %s, i32 0, i32 3
  %61 = load i64, ptr %60, align 8
  %62 = icmp eq i64 %61, 0
  %63 = zext i1 %62 to i8
  %64 = icmp ne i8 %63, 0
  br i1 %64, label %if.then1, label %if.done2

if.then1:                                         ; preds = %cmp.and
  %65 = getelementptr inbounds nuw %"main::Spark", ptr %s, i32 0, i32 2
  store i64 1, ptr %65, align 8
  br label %if.done2

if.done2:                                         ; preds = %if.then1, %cmp.and, %if.done
  %66 = load %"main::Spark", ptr %s, align 8
  %67 = call i8 @"main::spark_buf_append"(ptr %1, ptr %s, ptr %__.context_ptr)
  ret i8 %67
}

define internal i8 @"runtime::_make_aligned_type_erased"(ptr %0, i64 %1, i64 %2, i64 %3, { i64, i64 } %4, ptr %5, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %6 = alloca ptr, align 8
  %7 = alloca i64, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca %"runtime::Allocator", align 16
  %11 = alloca { i64, i64 }, align 16
  %12 = alloca { ptr, i64 }, align 8
  %13 = alloca { { ptr, i64 }, i8 }, align 8
  %data = alloca { ptr, i64 }, align 8
  %err = alloca i8, align 1
  %14 = alloca ptr, align 8
  %15 = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %6, align 8
  store i64 %1, ptr %7, align 8
  store i64 %2, ptr %8, align 8
  store i64 %3, ptr %9, align 8
  store { i64, i64 } %4, ptr %10, align 8
  %16 = load %"runtime::Allocator", ptr %10, align 8
  %17 = load %"runtime::Source_Code_Location", ptr %5, align 8
  call void @"runtime::make_slice_error_loc"(ptr %5, i64 %2)
  %18 = mul i64 %1, %2
  %19 = load %"runtime::Source_Code_Location", ptr %5, align 8
  store %"runtime::Allocator" %16, ptr %11, align 8
  %20 = load { i64, i64 }, ptr %11, align 8
  call void @llvm.memset.inline.p0.i64(ptr %12, i8 0, i64 16, i1 false)
  %21 = call i8 @"runtime::mem_alloc_bytes"(i64 %18, i64 %3, { i64, i64 } %20, ptr %5, ptr %12, ptr %__.context_ptr)
  %22 = load { ptr, i64 }, ptr %12, align 8
  %23 = load { { ptr, i64 }, i8 }, ptr %13, align 8
  store { ptr, i64 } %22, ptr %data, align 8
  store i8 %21, ptr %err, align 1
  %24 = load { ptr, i64 }, ptr %data, align 8
  %25 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  %27 = icmp eq ptr %26, null
  %28 = zext i1 %27 to i8
  %29 = icmp ne i8 %28, 0
  br i1 %29, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %entry
  %30 = icmp ne i64 %1, 0
  %31 = zext i1 %30 to i8
  %32 = icmp ne i8 %31, 0
  br i1 %32, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and
  %33 = load i8, ptr %err, align 1
  ret i8 %33

if.done:                                          ; preds = %cmp.and, %entry
  store ptr %0, ptr %14, align 8
  %34 = load ptr, ptr %14, align 8
  %35 = getelementptr inbounds nuw %"runtime::Raw_Slice", ptr %34, i32 0, i32 0
  %36 = load { ptr, i64 }, ptr %data, align 8
  %37 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %38 = load ptr, ptr %37, align 8
  store ptr %38, ptr %35, align 8
  store ptr %0, ptr %15, align 8
  %39 = load ptr, ptr %15, align 8
  %40 = getelementptr inbounds nuw %"runtime::Raw_Slice", ptr %39, i32 0, i32 1
  store i64 %2, ptr %40, align 8
  %41 = load i8, ptr %err, align 1
  ret i8 %41
}

define internal i8 @"reflect::is_endian_platform"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %info = alloca ptr, align 8
  %2 = alloca [32 x i8], align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %3 = icmp eq ptr %0, null
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  store ptr %0, ptr %info, align 8
  %6 = load ptr, ptr %info, align 8
  %7 = call ptr @"runtime::type_info_core"(ptr %6)
  store ptr %7, ptr %info, align 8
  %8 = load ptr, ptr %info, align 8
  %9 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %8, i32 0, i32 5
  %10 = load { [9 x i64], i64 }, ptr %9, align 8
  %11 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %9, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  switch i64 %12, label %typeswitch.done [
    i64 2, label %typeswitch.body
    i64 23, label %typeswitch.body1
    i64 11, label %typeswitch.body4
  ]

typeswitch.body:                                  ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 2, i1 false)
  %13 = getelementptr inbounds nuw %"runtime::Type_Info_Integer", ptr %2, i32 0, i32 1
  %14 = load i8, ptr %13, align 1
  %15 = icmp eq i8 %14, 0
  %16 = zext i1 %15 to i8
  ret i8 %16

typeswitch.body1:                                 ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 32, i1 false)
  %17 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 1
  %18 = load ptr, ptr %17, align 8
  %19 = icmp ne ptr %18, null
  %20 = zext i1 %19 to i8
  %21 = icmp ne i8 %20, 0
  br i1 %21, label %if.then2, label %if.done3

if.then2:                                         ; preds = %typeswitch.body1
  %22 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 1
  %23 = load ptr, ptr %22, align 8
  %24 = call i8 @"reflect::is_endian_platform"(ptr %23, ptr %__.context_ptr)
  ret i8 %24

if.done3:                                         ; preds = %typeswitch.body1
  ret i8 1

typeswitch.body4:                                 ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 8, i1 false)
  ret i8 1

typeswitch.done:                                  ; preds = %if.done
  ret i8 0
}

define internal i64 @"runtime::map_cell_index_dynamic_const:proc\22contextless\22(base:uintptr,info:^runtime::Map_Cell_Info,INDEX:$$2)->(:uintptr)"(i64 %0, ptr noalias %1) {
decls:
  %2 = alloca i64, align 8
  %3 = alloca ptr, align 8
  %elements_per_cell = alloca i64, align 8
  %size_of_cell = alloca i64, align 8
  %size_of_type = alloca i64, align 8
  %cell_index = alloca i64, align 8
  %data_index = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %2, align 8
  store ptr %1, ptr %3, align 8
  %4 = load ptr, ptr %3, align 8
  %5 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %4, i32 0, i32 3
  %6 = load i64, ptr %5, align 8
  store i64 %6, ptr %elements_per_cell, align 8
  %7 = load ptr, ptr %3, align 8
  %8 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %7, i32 0, i32 2
  %9 = load i64, ptr %8, align 8
  store i64 %9, ptr %size_of_cell, align 8
  %10 = load ptr, ptr %3, align 8
  %11 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %10, i32 0, i32 0
  %12 = load i64, ptr %11, align 8
  store i64 %12, ptr %size_of_type, align 8
  %13 = load i64, ptr %elements_per_cell, align 8
  %14 = icmp ne i64 %13, 0
  br i1 %14, label %div.safe, label %div.edge

div.safe:                                         ; preds = %entry
  %15 = udiv i64 2, %13
  br label %div.done

div.edge:                                         ; preds = %entry
  call void @llvm.trap()
  unreachable

div.done:                                         ; preds = %div.safe
  store i64 %15, ptr %cell_index, align 8
  %16 = load i64, ptr %elements_per_cell, align 8
  %17 = icmp ne i64 %16, 0
  br i1 %17, label %mod.safe, label %mod.edge

mod.safe:                                         ; preds = %div.done
  %18 = urem i64 2, %16
  br label %mod.done

mod.edge:                                         ; preds = %div.done
  call void @llvm.trap()
  unreachable

mod.done:                                         ; preds = %mod.safe
  store i64 %18, ptr %data_index, align 8
  %19 = load i64, ptr %cell_index, align 8
  %20 = load i64, ptr %size_of_cell, align 8
  %21 = mul i64 %19, %20
  %22 = add i64 %0, %21
  %23 = load i64, ptr %data_index, align 8
  %24 = load i64, ptr %size_of_type, align 8
  %25 = mul i64 %23, %24
  %26 = add i64 %22, %25
  ret i64 %26
}

define internal i8 @"main::spawn_spark_into_unique"(ptr %0, ptr %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca ptr, align 8
  %4 = alloca i64, align 8
  %5 = alloca i64, align 8
  %x = alloca i64, align 8
  %y = alloca i64, align 8
  %i = alloca i64, align 8
  %hue = alloca i32, align 4
  %6 = alloca [4 x i8], align 16
  %color = alloca [4 x i8], align 1
  %7 = alloca %"main::Spark", align 8
  %s = alloca %"main::Spark", align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store ptr %1, ptr %3, align 8
  %8 = load ptr, ptr %3, align 8
  %9 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %8, i32 0, i32 1
  %10 = load i64, ptr %9, align 8
  %11 = load ptr, ptr %3, align 8
  %12 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %11, i32 0, i32 0
  %13 = load { ptr, i64 }, ptr %12, align 8
  %14 = getelementptr inbounds nuw { ptr, i64 }, ptr %12, i32 0, i32 1
  %15 = load i64, ptr %14, align 8
  %16 = icmp sge i64 %10, %15
  %17 = zext i1 %16 to i8
  %18 = icmp ne i8 %17, 0
  br i1 %18, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  store i64 0, ptr %4, align 8
  store i64 0, ptr %5, align 8
  br label %for.interval.loop

for.interval.loop:                                ; preds = %for.interval.post, %if.done
  %19 = load i64, ptr %4, align 8
  %20 = icmp slt i64 %19, 16
  br i1 %20, label %for.interval.body, label %for.interval.done

for.interval.body:                                ; preds = %for.interval.loop
  %21 = load i64, ptr %4, align 8
  %22 = load i64, ptr %5, align 8
  %23 = load ptr, ptr %2, align 8
  %24 = getelementptr inbounds nuw %"main::Byte_World", ptr %23, i32 0, i32 8
  %25 = load ptr, ptr %2, align 8
  %26 = getelementptr inbounds nuw %"main::Byte_World", ptr %25, i32 0, i32 0
  %27 = load i64, ptr %26, align 8
  %28 = sub i64 %27, 1
  %29 = call i64 @"main::rng_int_inclusive"(ptr %24, i64 0, i64 %28, ptr %__.context_ptr)
  store i64 %29, ptr %x, align 8
  %30 = load ptr, ptr %2, align 8
  %31 = getelementptr inbounds nuw %"main::Byte_World", ptr %30, i32 0, i32 8
  %32 = load ptr, ptr %2, align 8
  %33 = getelementptr inbounds nuw %"main::Byte_World", ptr %32, i32 0, i32 0
  %34 = load i64, ptr %33, align 8
  %35 = sub i64 %34, 1
  %36 = call i64 @"main::rng_int_inclusive"(ptr %31, i64 0, i64 %35, ptr %__.context_ptr)
  store i64 %36, ptr %y, align 8
  %37 = load ptr, ptr %2, align 8
  %38 = getelementptr inbounds nuw %"main::Byte_World", ptr %37, i32 0, i32 0
  %39 = load i64, ptr %38, align 8
  %40 = load i64, ptr %x, align 8
  %41 = load i64, ptr %y, align 8
  %42 = call i64 @"main::idx_of"(i64 %39, i64 %40, i64 %41, ptr %__.context_ptr)
  store i64 %42, ptr %i, align 8
  %43 = load ptr, ptr %2, align 8
  %44 = getelementptr inbounds nuw %"main::Byte_World", ptr %43, i32 0, i32 6
  %45 = load { ptr, i64 }, ptr %44, align 8
  %46 = getelementptr inbounds nuw { ptr, i64 }, ptr %44, i32 0, i32 0
  %47 = load ptr, ptr %46, align 8
  %48 = load i64, ptr %i, align 8
  %49 = getelementptr inbounds nuw { ptr, i64 }, ptr %44, i32 0, i32 1
  %50 = load i64, ptr %49, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 553, i32 18, i64 %48, i64 %50)
  %51 = getelementptr i32, ptr %47, i64 %48
  %52 = load i32, ptr %51, align 4
  %53 = load ptr, ptr %2, align 8
  %54 = getelementptr inbounds nuw %"main::Byte_World", ptr %53, i32 0, i32 7
  %55 = load i32, ptr %54, align 4
  %56 = icmp eq i32 %52, %55
  %57 = zext i1 %56 to i8
  %58 = icmp ne i8 %57, 0
  br i1 %58, label %if.then1, label %if.done2

if.then1:                                         ; preds = %for.interval.body
  br label %for.interval.post

unreachable:                                      ; No predecessors!
  br label %if.done2

if.done2:                                         ; preds = %unreachable, %for.interval.body
  %59 = load ptr, ptr %2, align 8
  %60 = getelementptr inbounds nuw %"main::Byte_World", ptr %59, i32 0, i32 8
  %61 = call i32 @"main::rng_u32_bounded"(ptr %60, i32 360, ptr %__.context_ptr)
  store i32 %61, ptr %hue, align 4
  %62 = load i32, ptr %hue, align 4
  %63 = call i32 @"main::hsv_to_rgb"(i32 %62, float 0x3FE99999A0000000, float 1.000000e+00, ptr %__.context_ptr)
  store i32 %63, ptr %6, align 4
  %64 = load [4 x i8], ptr %6, align 1
  store [4 x i8] %64, ptr %color, align 1
  call void @llvm.memset.p0.i64(ptr %7, i8 0, i64 64, i1 false)
  call void @llvm.memset.p0.i64(ptr %7, i8 0, i64 64, i1 false)
  %65 = load i64, ptr %x, align 8
  %66 = getelementptr inbounds nuw %"main::Spark", ptr %7, i32 0, i32 0
  store i64 %65, ptr %66, align 8
  %67 = load i64, ptr %y, align 8
  %68 = getelementptr inbounds nuw %"main::Spark", ptr %7, i32 0, i32 1
  store i64 %67, ptr %68, align 8
  %69 = load ptr, ptr %2, align 8
  %70 = getelementptr inbounds nuw %"main::Byte_World", ptr %69, i32 0, i32 8
  %71 = call i64 @"main::rng_choice_dir_3"(ptr %70, ptr %__.context_ptr)
  %72 = getelementptr inbounds nuw %"main::Spark", ptr %7, i32 0, i32 2
  store i64 %71, ptr %72, align 8
  %73 = load ptr, ptr %2, align 8
  %74 = getelementptr inbounds nuw %"main::Byte_World", ptr %73, i32 0, i32 8
  %75 = call i64 @"main::rng_choice_dir_3"(ptr %74, ptr %__.context_ptr)
  %76 = getelementptr inbounds nuw %"main::Spark", ptr %7, i32 0, i32 3
  store i64 %75, ptr %76, align 8
  %77 = load ptr, ptr %2, align 8
  %78 = getelementptr inbounds nuw %"main::Byte_World", ptr %77, i32 0, i32 8
  %79 = call i64 @"main::rng_int_inclusive"(ptr %78, i64 50, i64 80, ptr %__.context_ptr)
  %80 = sitofp i64 %79 to float
  %81 = getelementptr inbounds nuw %"main::Spark", ptr %7, i32 0, i32 4
  store float %80, ptr %81, align 4
  %82 = load [4 x i8], ptr %color, align 1
  %83 = getelementptr inbounds nuw %"main::Spark", ptr %7, i32 0, i32 9
  store [4 x i8] %82, ptr %83, align 1
  %84 = load %"main::Spark", ptr %7, align 8
  call void @llvm.memset.p0.i64(ptr %s, i8 0, i64 64, i1 false)
  store %"main::Spark" %84, ptr %s, align 8
  %85 = getelementptr inbounds nuw %"main::Spark", ptr %s, i32 0, i32 2
  %86 = load i64, ptr %85, align 8
  %87 = icmp eq i64 %86, 0
  %88 = zext i1 %87 to i8
  %89 = icmp ne i8 %88, 0
  br i1 %89, label %cmp.and, label %if.done4

cmp.and:                                          ; preds = %if.done2
  %90 = getelementptr inbounds nuw %"main::Spark", ptr %s, i32 0, i32 3
  %91 = load i64, ptr %90, align 8
  %92 = icmp eq i64 %91, 0
  %93 = zext i1 %92 to i8
  %94 = icmp ne i8 %93, 0
  br i1 %94, label %if.then3, label %if.done4

if.then3:                                         ; preds = %cmp.and
  %95 = getelementptr inbounds nuw %"main::Spark", ptr %s, i32 0, i32 2
  store i64 1, ptr %95, align 8
  br label %if.done4

if.done4:                                         ; preds = %if.then3, %cmp.and, %if.done2
  %96 = load %"main::Spark", ptr %s, align 8
  %97 = call i8 @"main::spark_buf_append"(ptr %1, ptr %s, ptr %__.context_ptr)
  %98 = icmp ne i8 %97, 0
  br i1 %98, label %if.then5, label %if.done6

if.then5:                                         ; preds = %if.done4
  %99 = load ptr, ptr %2, align 8
  %100 = getelementptr inbounds nuw %"main::Byte_World", ptr %99, i32 0, i32 6
  %101 = load { ptr, i64 }, ptr %100, align 8
  %102 = getelementptr inbounds nuw { ptr, i64 }, ptr %100, i32 0, i32 0
  %103 = load ptr, ptr %102, align 8
  %104 = load i64, ptr %i, align 8
  %105 = getelementptr inbounds nuw { ptr, i64 }, ptr %100, i32 0, i32 1
  %106 = load i64, ptr %105, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 577, i32 16, i64 %104, i64 %106)
  %107 = getelementptr i32, ptr %103, i64 %104
  %108 = load ptr, ptr %2, align 8
  %109 = getelementptr inbounds nuw %"main::Byte_World", ptr %108, i32 0, i32 7
  %110 = load i32, ptr %109, align 4
  store i32 %110, ptr %107, align 4
  ret i8 1

if.done6:                                         ; preds = %if.done4
  ret i8 0

for.interval.post:                                ; preds = %if.then1
  %111 = load i64, ptr %4, align 8
  %112 = add i64 %111, 1
  store i64 %112, ptr %4, align 8
  %113 = load i64, ptr %5, align 8
  %114 = add i64 %113, 1
  store i64 %114, ptr %5, align 8
  br label %for.interval.loop

for.interval.done:                                ; preds = %for.interval.loop
  %115 = call i8 @"main::spawn_spark_into"(ptr %0, ptr %1, ptr %__.context_ptr)
  ret i8 %115
}

define internal i8 @"mem::is_power_of_two"(i64 %0) {
decls:
  %1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = icmp ule i64 %0, 0
  %3 = zext i1 %2 to i8
  %4 = icmp ne i8 %3, 0
  br i1 %4, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  %5 = sub i64 %0, 1
  %6 = and i64 %0, %5
  %7 = icmp eq i64 %6, 0
  %8 = zext i1 %7 to i8
  ret i8 %8
}

; Function Attrs: alwaysinline
define internal i64 @"runtime::map_total_allocation_size"(i64 %0, ptr %1) #3 {
decls:
  %2 = alloca i64, align 8
  %3 = alloca ptr, align 8
  %INFO_HS = alloca ptr, align 8
  %size = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %2, align 8
  store ptr %1, ptr %3, align 8
  store ptr @"ggv$map_cell_info-13197927915248882629", ptr %INFO_HS, align 8
  store i64 0, ptr %size, align 8
  %4 = load i64, ptr %size, align 8
  %5 = load ptr, ptr %3, align 8
  %6 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %5, i32 0, i32 0
  %7 = load ptr, ptr %6, align 8
  %8 = call i64 @"runtime::map_cell_index_dynamic"(i64 %4, ptr %7, i64 %0)
  %9 = call i64 @"runtime::map_total_allocation_size.round-0"(i64 %8)
  store i64 %9, ptr %size, align 8
  %10 = load i64, ptr %size, align 8
  %11 = load ptr, ptr %3, align 8
  %12 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %11, i32 0, i32 1
  %13 = load ptr, ptr %12, align 8
  %14 = call i64 @"runtime::map_cell_index_dynamic"(i64 %10, ptr %13, i64 %0)
  %15 = call i64 @"runtime::map_total_allocation_size.round-0"(i64 %14)
  store i64 %15, ptr %size, align 8
  %16 = load i64, ptr %size, align 8
  %17 = load ptr, ptr %INFO_HS, align 8
  %18 = call i64 @"runtime::map_cell_index_dynamic"(i64 %16, ptr %17, i64 %0)
  %19 = call i64 @"runtime::map_total_allocation_size.round-0"(i64 %18)
  store i64 %19, ptr %size, align 8
  %20 = load i64, ptr %size, align 8
  %21 = load ptr, ptr %3, align 8
  %22 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %21, i32 0, i32 0
  %23 = load ptr, ptr %22, align 8
  %24 = call i64 @"runtime::map_cell_index_dynamic"(i64 %20, ptr %23, i64 2)
  %25 = call i64 @"runtime::map_total_allocation_size.round-0"(i64 %24)
  store i64 %25, ptr %size, align 8
  %26 = load i64, ptr %size, align 8
  %27 = load ptr, ptr %3, align 8
  %28 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %27, i32 0, i32 1
  %29 = load ptr, ptr %28, align 8
  %30 = call i64 @"runtime::map_cell_index_dynamic"(i64 %26, ptr %29, i64 2)
  %31 = call i64 @"runtime::map_total_allocation_size.round-0"(i64 %30)
  store i64 %31, ptr %size, align 8
  %32 = load i64, ptr %size, align 8
  ret i64 %32
}

define internal i64 @"mem::align_forward_uintptr"(i64 %0, i64 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %4 = call i8 @"mem::is_power_of_two"(i64 %1)
  %5 = load %"runtime::Source_Code_Location", ptr @"scl$[align_forward_uintptr14911]", align 8
  call void @"runtime::assert"(i8 %4, %..string { ptr @"csbs$byte_world$256", i64 22 }, ptr @"scl$[align_forward_uintptr14911]", ptr %__.context_ptr)
  %6 = add i64 %0, %1
  %7 = sub i64 %6, 1
  %8 = sub i64 %1, 1
  %9 = xor i64 %8, -1
  %10 = and i64 %7, %9
  ret i64 %10
}

define internal ptr @"runtime::type_info_base"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  %base = alloca ptr, align 8
  %2 = alloca [48 x i8], align 8
  %i = alloca { [9 x i64], i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %3 = icmp eq ptr %0, null
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret ptr null

if.done:                                          ; preds = %entry
  store ptr %0, ptr %base, align 8
  br label %for.body

for.body:                                         ; preds = %typeswitch.done, %if.done
  %6 = load ptr, ptr %base, align 8
  %7 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %6, i32 0, i32 5
  %8 = load { [9 x i64], i64 }, ptr %7, align 8
  %9 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %7, i32 0, i32 1
  %10 = load i64, ptr %9, align 8
  switch i64 %10, label %typeswitch.default.body [
    i64 1, label %typeswitch.body
  ]

typeswitch.body:                                  ; preds = %for.body
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %7, i64 48, i1 false)
  %11 = getelementptr inbounds nuw %"runtime::Type_Info_Named", ptr %2, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %base, align 8
  br label %typeswitch.done

typeswitch.default.body:                          ; preds = %for.body
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %i, ptr align 1 %7, i64 80, i1 false)
  br label %for.done

unreachable:                                      ; No predecessors!
  br label %typeswitch.done

typeswitch.done:                                  ; preds = %unreachable, %typeswitch.body
  br label %for.body

for.done:                                         ; preds = %typeswitch.default.body
  %13 = load ptr, ptr %base, align 8
  ret ptr %13
}

define internal i8 @"main::is_permeable_for_spawn"(i8 %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store i8 %0, ptr %1, align 1
  %2 = load i8, ptr @"main::RANGE_VOID_MAX", align 1
  %3 = icmp ule i8 %0, %2
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %logical.cmp.done, label %logical.cmp.rhs

logical.cmp.rhs:                                  ; preds = %entry
  %6 = load i8, ptr @"main::RANGE_WALL_MAX", align 1
  %7 = icmp ugt i8 %0, %6
  %8 = zext i1 %7 to i8
  %9 = icmp ne i8 %8, 0
  br label %logical.cmp.done

logical.cmp.done:                                 ; preds = %logical.cmp.rhs, %entry
  %10 = phi i1 [ true, %entry ], [ %9, %logical.cmp.rhs ]
  %11 = zext i1 %10 to i8
  ret i8 %11
}

define internal i8 @"runtime::map_alloc_dynamic"(ptr %0, i64 %1, { i64, i64 } %2, ptr %3, ptr noalias nonnull %4, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %5 = alloca ptr, align 8
  %6 = alloca i64, align 8
  %7 = alloca %"runtime::Allocator", align 16
  %result = alloca %"runtime::Raw_Map", align 8
  %err = alloca i8, align 1
  %capacity = alloca i64, align 8
  %size = alloca i64, align 8
  %8 = alloca { i64, i64 }, align 16
  %9 = alloca { ptr, i64 }, align 8
  %10 = alloca { { ptr, i64 }, i8 }, align 8
  %data = alloca { ptr, i64 }, align 8
  %data_ptr = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %5, align 8
  store i64 %1, ptr %6, align 8
  store { i64, i64 } %2, ptr %7, align 8
  %11 = load %"runtime::Allocator", ptr %7, align 8
  call void @llvm.memset.inline.p0.i64(ptr %result, i8 0, i64 32, i1 false)
  store i8 0, ptr %err, align 1
  %12 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %result, i32 0, i32 2
  store %"runtime::Allocator" %11, ptr %12, align 8
  %13 = icmp eq i64 %1, 0
  %14 = zext i1 %13 to i8
  %15 = icmp ne i8 %14, 0
  br i1 %15, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %16 = load %"runtime::Raw_Map", ptr %result, align 8
  %17 = load i8, ptr %err, align 1
  store %"runtime::Raw_Map" %16, ptr %result, align 8
  store i8 %17, ptr %err, align 1
  store %"runtime::Raw_Map" %16, ptr %4, align 8
  ret i8 %17

if.done:                                          ; preds = %entry
  %18 = icmp uge i64 %1, 64
  %19 = zext i1 %18 to i8
  %20 = icmp ne i8 %19, 0
  br i1 %20, label %if.then1, label %if.done2

if.then1:                                         ; preds = %if.done
  store %"runtime::Raw_Map" zeroinitializer, ptr %result, align 8
  store i8 1, ptr %err, align 1
  store %"runtime::Raw_Map" zeroinitializer, ptr %4, align 8
  ret i8 1

if.done2:                                         ; preds = %if.done
  %21 = icmp ugt i64 %1, 3
  %22 = select i1 %21, i64 %1, i64 3
  %23 = icmp ult i64 %22, 64
  %24 = shl i64 1, %22
  %25 = select i1 %23, i64 %24, i64 0
  store i64 %25, ptr %capacity, align 8
  %26 = load i64, ptr %capacity, align 8
  %27 = call i64 @"runtime::map_total_allocation_size"(i64 %26, ptr %0)
  store i64 %27, ptr %size, align 8
  %28 = load i64, ptr %size, align 8
  %29 = load %"runtime::Source_Code_Location", ptr %3, align 8
  store %"runtime::Allocator" %11, ptr %8, align 8
  %30 = load { i64, i64 }, ptr %8, align 8
  call void @llvm.memset.inline.p0.i64(ptr %9, i8 0, i64 16, i1 false)
  %31 = call i8 @"runtime::mem_alloc_non_zeroed"(i64 %28, i64 64, { i64, i64 } %30, ptr %3, ptr %9, ptr %__.context_ptr)
  %32 = load { ptr, i64 }, ptr %9, align 8
  %33 = load { { ptr, i64 }, i8 }, ptr %10, align 8
  %34 = icmp eq i8 %31, 0
  br i1 %34, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %if.done2
  store i8 %31, ptr %err, align 1
  %35 = load %"runtime::Raw_Map", ptr %result, align 8
  %36 = load i8, ptr %err, align 1
  store %"runtime::Raw_Map" %35, ptr %result, align 8
  store i8 %36, ptr %err, align 1
  store %"runtime::Raw_Map" %35, ptr %4, align 8
  ret i8 %36

or_return.continue:                               ; preds = %if.done2
  store { ptr, i64 } %32, ptr %data, align 8
  %37 = load { ptr, i64 }, ptr %data, align 8
  %38 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %39 = load ptr, ptr %38, align 8
  %40 = ptrtoint ptr %39 to i64
  store i64 %40, ptr %data_ptr, align 8
  %41 = load i64, ptr %data_ptr, align 8
  %42 = icmp eq i64 %41, 0
  %43 = zext i1 %42 to i8
  %44 = icmp ne i8 %43, 0
  br i1 %44, label %if.then3, label %if.done4

if.then3:                                         ; preds = %or_return.continue
  store i8 1, ptr %err, align 1
  %45 = load %"runtime::Raw_Map", ptr %result, align 8
  %46 = load i8, ptr %err, align 1
  store %"runtime::Raw_Map" %45, ptr %result, align 8
  store i8 %46, ptr %err, align 1
  store %"runtime::Raw_Map" %45, ptr %4, align 8
  ret i8 %46

if.done4:                                         ; preds = %or_return.continue
  %47 = load i64, ptr %data_ptr, align 8
  %48 = and i64 %47, 63
  %49 = icmp ne i64 %48, 0
  %50 = zext i1 %49 to i8
  %51 = call i8 @llvm.expect.i8(i8 %50, i8 0)
  %52 = icmp ne i8 %51, 0
  br i1 %52, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.done4
  %53 = load %"runtime::Source_Code_Location", ptr %3, align 8
  call void @"runtime::panic"(%..string { ptr @"csbs$byte_world$259", i64 38 }, ptr %3, ptr %__.context_ptr)
  unreachable

if.else:                                          ; preds = %if.done4
  %54 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %result, i32 0, i32 0
  %55 = load i64, ptr %data_ptr, align 8
  %56 = or i64 %55, %1
  store i64 %56, ptr %54, align 8
  %57 = getelementptr inbounds nuw %"runtime::Raw_Map", ptr %result, i32 0, i32 1
  store i64 0, ptr %57, align 8
  call void @"runtime::map_clear_dynamic"(ptr %result, ptr %0)
  br label %if.done6

if.done6:                                         ; preds = %if.else
  %58 = load %"runtime::Raw_Map", ptr %result, align 8
  %59 = load i8, ptr %err, align 1
  store %"runtime::Raw_Map" %58, ptr %result, align 8
  store i8 %59, ptr %err, align 1
  store %"runtime::Raw_Map" %58, ptr %4, align 8
  ret i8 %59
}

define internal void @"main::occ_begin_step"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %i = alloca i64, align 8
  %2 = alloca i64, align 8
  %i1 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %3 = load ptr, ptr %1, align 8
  %4 = getelementptr inbounds nuw %"main::Byte_World", ptr %3, i32 0, i32 7
  %5 = load i32, ptr %4, align 4
  %6 = add i32 %5, 1
  store i32 %6, ptr %4, align 4
  %7 = load ptr, ptr %1, align 8
  %8 = getelementptr inbounds nuw %"main::Byte_World", ptr %7, i32 0, i32 7
  %9 = load i32, ptr %8, align 4
  %10 = icmp eq i32 %9, 0
  %11 = zext i1 %10 to i8
  %12 = icmp ne i8 %11, 0
  br i1 %12, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  store i64 0, ptr %i, align 8
  store i64 0, ptr %2, align 8
  br label %for.interval.loop

for.interval.loop:                                ; preds = %for.interval.post, %if.then
  %13 = load ptr, ptr %1, align 8
  %14 = getelementptr inbounds nuw %"main::Byte_World", ptr %13, i32 0, i32 6
  %15 = load { ptr, i64 }, ptr %14, align 8
  %16 = getelementptr inbounds nuw { ptr, i64 }, ptr %14, i32 0, i32 1
  %17 = load i64, ptr %16, align 8
  %18 = load i64, ptr %i, align 8
  %19 = icmp slt i64 %18, %17
  br i1 %19, label %for.interval.body, label %for.interval.done

for.interval.body:                                ; preds = %for.interval.loop
  %20 = load i64, ptr %i, align 8
  %21 = load i64, ptr %2, align 8
  store i64 %20, ptr %i1, align 8
  %22 = load ptr, ptr %1, align 8
  %23 = getelementptr inbounds nuw %"main::Byte_World", ptr %22, i32 0, i32 6
  %24 = load { ptr, i64 }, ptr %23, align 8
  %25 = getelementptr inbounds nuw { ptr, i64 }, ptr %23, i32 0, i32 0
  %26 = load ptr, ptr %25, align 8
  %27 = load i64, ptr %i1, align 8
  %28 = getelementptr inbounds nuw { ptr, i64 }, ptr %23, i32 0, i32 1
  %29 = load i64, ptr %28, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 600, i32 16, i64 %27, i64 %29)
  %30 = getelementptr i32, ptr %26, i64 %27
  store i32 0, ptr %30, align 4
  br label %for.interval.post

for.interval.post:                                ; preds = %for.interval.body
  %31 = load i64, ptr %i, align 8
  %32 = add i64 %31, 1
  store i64 %32, ptr %i, align 8
  %33 = load i64, ptr %2, align 8
  %34 = add i64 %33, 1
  store i64 %34, ptr %2, align 8
  br label %for.interval.loop

for.interval.done:                                ; preds = %for.interval.loop
  %35 = load ptr, ptr %1, align 8
  %36 = getelementptr inbounds nuw %"main::Byte_World", ptr %35, i32 0, i32 7
  store i32 1, ptr %36, align 4
  br label %if.done

if.done:                                          ; preds = %for.interval.done, %entry
  ret void
}

define internal i8 @"reflect::is_endian_big"(ptr %0, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %1 = alloca ptr, align 8
  %info = alloca ptr, align 8
  %2 = alloca [32 x i8], align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %3 = icmp eq ptr %0, null
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  store ptr %0, ptr %info, align 8
  %6 = load ptr, ptr %info, align 8
  %7 = call ptr @"runtime::type_info_core"(ptr %6)
  store ptr %7, ptr %info, align 8
  %8 = load ptr, ptr %info, align 8
  %9 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %8, i32 0, i32 5
  %10 = load { [9 x i64], i64 }, ptr %9, align 8
  %11 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %9, i32 0, i32 1
  %12 = load i64, ptr %11, align 8
  switch i64 %12, label %typeswitch.done [
    i64 2, label %typeswitch.body
    i64 23, label %typeswitch.body3
    i64 11, label %typeswitch.body6
  ]

typeswitch.body:                                  ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 2, i1 false)
  %13 = getelementptr inbounds nuw %"runtime::Type_Info_Integer", ptr %2, i32 0, i32 1
  %14 = load i8, ptr %13, align 1
  %15 = icmp eq i8 %14, 0
  %16 = zext i1 %15 to i8
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %if.then1, label %if.done2

if.then1:                                         ; preds = %typeswitch.body
  ret i8 0

if.done2:                                         ; preds = %typeswitch.body
  %18 = getelementptr inbounds nuw %"runtime::Type_Info_Integer", ptr %2, i32 0, i32 1
  %19 = load i8, ptr %18, align 1
  %20 = icmp eq i8 %19, 2
  %21 = zext i1 %20 to i8
  ret i8 %21

typeswitch.body3:                                 ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 32, i1 false)
  %22 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 1
  %23 = load ptr, ptr %22, align 8
  %24 = icmp ne ptr %23, null
  %25 = zext i1 %24 to i8
  %26 = icmp ne i8 %25, 0
  br i1 %26, label %if.then4, label %if.done5

if.then4:                                         ; preds = %typeswitch.body3
  %27 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Set", ptr %2, i32 0, i32 1
  %28 = load ptr, ptr %27, align 8
  %29 = call i8 @"reflect::is_endian_platform"(ptr %28, ptr %__.context_ptr)
  ret i8 %29

if.done5:                                         ; preds = %typeswitch.body3
  ret i8 0

typeswitch.body6:                                 ; preds = %if.done
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %2, ptr %9, i64 8, i1 false)
  ret i8 0

typeswitch.done:                                  ; preds = %if.done
  ret i8 0
}

define internal ptr @"runtime::type_info_core"(ptr %0) {
decls:
  %1 = alloca ptr, align 8
  %base = alloca ptr, align 8
  %2 = alloca [56 x i8], align 8
  %i = alloca { [9 x i64], i64 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %1, align 8
  %3 = icmp eq ptr %0, null
  %4 = zext i1 %3 to i8
  %5 = icmp ne i8 %4, 0
  br i1 %5, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret ptr null

if.done:                                          ; preds = %entry
  store ptr %0, ptr %base, align 8
  br label %for.body

for.body:                                         ; preds = %typeswitch.done, %if.done
  %6 = load ptr, ptr %base, align 8
  %7 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %6, i32 0, i32 5
  %8 = load { [9 x i64], i64 }, ptr %7, align 8
  %9 = getelementptr inbounds nuw { [9 x i64], i64 }, ptr %7, i32 0, i32 1
  %10 = load i64, ptr %9, align 8
  switch i64 %10, label %typeswitch.default.body [
    i64 1, label %typeswitch.body
    i64 21, label %typeswitch.body1
    i64 27, label %typeswitch.body2
  ]

typeswitch.body:                                  ; preds = %for.body
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %7, i64 48, i1 false)
  %11 = getelementptr inbounds nuw %"runtime::Type_Info_Named", ptr %2, i32 0, i32 1
  %12 = load ptr, ptr %11, align 8
  store ptr %12, ptr %base, align 8
  br label %typeswitch.done

typeswitch.body1:                                 ; preds = %for.body
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %7, i64 40, i1 false)
  %13 = getelementptr inbounds nuw %"runtime::Type_Info_Enum", ptr %2, i32 0, i32 0
  %14 = load ptr, ptr %13, align 8
  store ptr %14, ptr %base, align 8
  br label %typeswitch.done

typeswitch.body2:                                 ; preds = %for.body
  call void @llvm.memcpy.p0.p0.i64(ptr %2, ptr %7, i64 56, i1 false)
  %15 = getelementptr inbounds nuw %"runtime::Type_Info_Bit_Field", ptr %2, i32 0, i32 0
  %16 = load ptr, ptr %15, align 8
  store ptr %16, ptr %base, align 8
  br label %typeswitch.done

typeswitch.default.body:                          ; preds = %for.body
  call void @llvm.memmove.p0.p0.i64(ptr align 8 %i, ptr align 1 %7, i64 80, i1 false)
  br label %for.done

unreachable:                                      ; No predecessors!
  br label %typeswitch.done

typeswitch.done:                                  ; preds = %unreachable, %typeswitch.body2, %typeswitch.body1, %typeswitch.body
  br label %for.body

for.done:                                         ; preds = %typeswitch.default.body
  %17 = load ptr, ptr %base, align 8
  ret ptr %17
}

define internal i8 @"main::occ_try_claim"(ptr %0, i64 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %4 = load ptr, ptr %2, align 8
  %5 = getelementptr inbounds nuw %"main::Byte_World", ptr %4, i32 0, i32 6
  %6 = load { ptr, i64 }, ptr %5, align 8
  %7 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 0
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 1
  %10 = load i64, ptr %9, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 607, i32 17, i64 %1, i64 %10)
  %11 = getelementptr i32, ptr %8, i64 %1
  %12 = load i32, ptr %11, align 4
  %13 = load ptr, ptr %2, align 8
  %14 = getelementptr inbounds nuw %"main::Byte_World", ptr %13, i32 0, i32 7
  %15 = load i32, ptr %14, align 4
  %16 = icmp eq i32 %12, %15
  %17 = zext i1 %16 to i8
  %18 = icmp ne i8 %17, 0
  br i1 %18, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  %19 = load ptr, ptr %2, align 8
  %20 = getelementptr inbounds nuw %"main::Byte_World", ptr %19, i32 0, i32 6
  %21 = load { ptr, i64 }, ptr %20, align 8
  %22 = getelementptr inbounds nuw { ptr, i64 }, ptr %20, i32 0, i32 0
  %23 = load ptr, ptr %22, align 8
  %24 = getelementptr inbounds nuw { ptr, i64 }, ptr %20, i32 0, i32 1
  %25 = load i64, ptr %24, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 610, i32 14, i64 %1, i64 %25)
  %26 = getelementptr i32, ptr %23, i64 %1
  %27 = load ptr, ptr %2, align 8
  %28 = getelementptr inbounds nuw %"main::Byte_World", ptr %27, i32 0, i32 7
  %29 = load i32, ptr %28, align 4
  store i32 %29, ptr %26, align 4
  ret i8 1
}

define internal i8 @"main::occ_try_claim_atomic"(ptr %0, i64 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %3 = alloca i64, align 8
  %old_val = alloca i32, align 4
  %ok = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %4 = load ptr, ptr %2, align 8
  %5 = getelementptr inbounds nuw %"main::Byte_World", ptr %4, i32 0, i32 6
  %6 = load { ptr, i64 }, ptr %5, align 8
  %7 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 0
  %8 = load ptr, ptr %7, align 8
  %9 = getelementptr inbounds nuw { ptr, i64 }, ptr %5, i32 0, i32 1
  %10 = load i64, ptr %9, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 617, i32 49, i64 %1, i64 %10)
  %11 = getelementptr i32, ptr %8, i64 %1
  %12 = load atomic volatile i32, ptr %11 seq_cst, align 4
  store i32 %12, ptr %old_val, align 4
  %13 = load i32, ptr %old_val, align 4
  %14 = load ptr, ptr %2, align 8
  %15 = getelementptr inbounds nuw %"main::Byte_World", ptr %14, i32 0, i32 7
  %16 = load i32, ptr %15, align 4
  %17 = icmp eq i32 %13, %16
  %18 = zext i1 %17 to i8
  %19 = icmp ne i8 %18, 0
  br i1 %19, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  ret i8 0

if.done:                                          ; preds = %entry
  %20 = load ptr, ptr %2, align 8
  %21 = getelementptr inbounds nuw %"main::Byte_World", ptr %20, i32 0, i32 6
  %22 = load { ptr, i64 }, ptr %21, align 8
  %23 = getelementptr inbounds nuw { ptr, i64 }, ptr %21, i32 0, i32 0
  %24 = load ptr, ptr %23, align 8
  %25 = getelementptr inbounds nuw { ptr, i64 }, ptr %21, i32 0, i32 1
  %26 = load i64, ptr %25, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 622, i32 66, i64 %1, i64 %26)
  %27 = getelementptr i32, ptr %24, i64 %1
  %28 = load i32, ptr %old_val, align 4
  %29 = load ptr, ptr %2, align 8
  %30 = getelementptr inbounds nuw %"main::Byte_World", ptr %29, i32 0, i32 7
  %31 = load i32, ptr %30, align 4
  %32 = cmpxchg volatile ptr %27, i32 %28, i32 %31 seq_cst seq_cst, align 4
  %33 = extractvalue { i32, i1 } %32, 0
  %34 = extractvalue { i32, i1 } %32, 1
  %35 = zext i1 %34 to i8
  store i8 %35, ptr %ok, align 1
  %36 = load i8, ptr %ok, align 1
  ret i8 %36
}

define internal i64 @"time::read_cycle_counter"() {
decls:
  br label %entry

entry:                                            ; preds = %decls
  %0 = call i64 @llvm.readcyclecounter()
  ret i64 %0
}

define internal ptr @"runtime::__type_info_of"(i64 %0) {
decls:
  %1 = alloca i64, align 8
  %n = alloca i64, align 8
  %i = alloca i64, align 8
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  %ptr = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %4 = load { ptr, i64 }, ptr @"runtime::type_table", align 8
  %5 = load i64, ptr getelementptr ({ ptr, i64 }, ptr @"runtime::type_table", i64 0, i32 1), align 8
  store i64 %5, ptr %n, align 8
  %6 = load i64, ptr %n, align 8
  %7 = icmp ne i64 %6, 0
  br i1 %7, label %mod.safe, label %mod.edge

mod.safe:                                         ; preds = %entry
  %8 = urem i64 %0, %6
  br label %mod.done

mod.edge:                                         ; preds = %entry
  call void @llvm.trap()
  unreachable

mod.done:                                         ; preds = %mod.safe
  store i64 %8, ptr %i, align 8
  store i64 0, ptr %2, align 8
  store i64 0, ptr %3, align 8
  br label %for.interval.loop

for.interval.loop:                                ; preds = %for.interval.post, %mod.done
  %9 = load i64, ptr %n, align 8
  %10 = load i64, ptr %2, align 8
  %11 = icmp ult i64 %10, %9
  br i1 %11, label %for.interval.body, label %for.interval.done

for.interval.body:                                ; preds = %for.interval.loop
  %12 = load i64, ptr %2, align 8
  %13 = load i64, ptr %3, align 8
  %14 = load { ptr, i64 }, ptr @"runtime::type_table", align 8
  %15 = load ptr, ptr @"runtime::type_table", align 8
  %16 = load i64, ptr %i, align 8
  %17 = load i64, ptr getelementptr ({ ptr, i64 }, ptr @"runtime::type_table", i64 0, i32 1), align 8
  %18 = getelementptr ptr, ptr %15, i64 %16
  %19 = load ptr, ptr %18, align 8
  store ptr %19, ptr %ptr, align 8
  %20 = load ptr, ptr %ptr, align 8
  %21 = icmp ne ptr %20, null
  %22 = zext i1 %21 to i8
  %23 = icmp ne i8 %22, 0
  br i1 %23, label %cmp.and, label %if.done

cmp.and:                                          ; preds = %for.interval.body
  %24 = load ptr, ptr %ptr, align 8
  %25 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %24, i32 0, i32 4
  %26 = load i64, ptr %25, align 8
  %27 = icmp eq i64 %26, %0
  %28 = zext i1 %27 to i8
  %29 = icmp ne i8 %28, 0
  br i1 %29, label %if.then, label %if.done

if.then:                                          ; preds = %cmp.and
  %30 = load ptr, ptr %ptr, align 8
  ret ptr %30

if.done:                                          ; preds = %cmp.and, %for.interval.body
  %31 = load i64, ptr %i, align 8
  %32 = add i64 %31, 1
  %33 = load i64, ptr %n, align 8
  %34 = icmp ult i64 %32, %33
  %35 = zext i1 %34 to i8
  %36 = icmp ne i8 %35, 0
  br i1 %36, label %if.then1, label %if.else

if.then1:                                         ; preds = %if.done
  %37 = load i64, ptr %i, align 8
  %38 = add i64 %37, 1
  br label %if.done2

if.else:                                          ; preds = %if.done
  br label %if.done2

if.done2:                                         ; preds = %if.else, %if.then1
  %39 = phi i64 [ %38, %if.then1 ], [ 0, %if.else ]
  store i64 %39, ptr %i, align 8
  br label %for.interval.post

for.interval.post:                                ; preds = %if.done2
  %40 = load i64, ptr %2, align 8
  %41 = add i64 %40, 1
  store i64 %41, ptr %2, align 8
  %42 = load i64, ptr %3, align 8
  %43 = add i64 %42, 1
  store i64 %43, ptr %3, align 8
  br label %for.interval.loop

for.interval.done:                                ; preds = %for.interval.loop
  %44 = load { ptr, i64 }, ptr @"runtime::type_table", align 8
  %45 = load ptr, ptr @"runtime::type_table", align 8
  %46 = load i64, ptr getelementptr ({ ptr, i64 }, ptr @"runtime::type_table", i64 0, i32 1), align 8
  %47 = getelementptr ptr, ptr %45, i64 0
  %48 = load ptr, ptr %47, align 8
  ret ptr %48
}

define internal i8 @"main::spark_buf_append_atomic"(ptr %0, ptr %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca ptr, align 8
  %old_count = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %2, align 8
  %3 = load ptr, ptr %2, align 8
  %4 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %3, i32 0, i32 1
  %5 = atomicrmw volatile add ptr %4, i64 1 seq_cst, align 8
  store i64 %5, ptr %old_count, align 8
  %6 = load i64, ptr %old_count, align 8
  %7 = load ptr, ptr %2, align 8
  %8 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %7, i32 0, i32 0
  %9 = load { ptr, i64 }, ptr %8, align 8
  %10 = getelementptr inbounds nuw { ptr, i64 }, ptr %8, i32 0, i32 1
  %11 = load i64, ptr %10, align 8
  %12 = icmp sge i64 %6, %11
  %13 = zext i1 %12 to i8
  %14 = icmp ne i8 %13, 0
  br i1 %14, label %if.then, label %if.done

if.then:                                          ; preds = %entry
  %15 = load ptr, ptr %2, align 8
  %16 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %15, i32 0, i32 1
  %17 = atomicrmw volatile sub ptr %16, i64 1 seq_cst, align 8
  ret i8 0

if.done:                                          ; preds = %entry
  %18 = load ptr, ptr %2, align 8
  %19 = getelementptr inbounds nuw %"main::Spark_Buffer", ptr %18, i32 0, i32 0
  %20 = load { ptr, i64 }, ptr %19, align 8
  %21 = getelementptr inbounds nuw { ptr, i64 }, ptr %19, i32 0, i32 0
  %22 = load ptr, ptr %21, align 8
  %23 = load i64, ptr %old_count, align 8
  %24 = getelementptr inbounds nuw { ptr, i64 }, ptr %19, i32 0, i32 1
  %25 = load i64, ptr %24, align 8
  call void @"runtime::bounds_check_error"(%..string { ptr @"csbs$byte_world$20c", i64 56 }, i32 636, i32 9, i64 %23, i64 %25)
  %26 = getelementptr %"main::Spark", ptr %22, i64 %23
  %27 = load %"main::Spark", ptr %1, align 8
  store %"main::Spark" %27, ptr %26, align 8
  ret i8 1
}

define internal %..string @"fmt::sbprintf"(ptr %0, %..string %1, { ptr, i64 } %2, i8 %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca ptr, align 8
  %5 = alloca %..string, align 8
  %6 = alloca { ptr, i64 }, align 8
  %7 = alloca i8, align 1
  %8 = alloca %"io::Stream", align 16
  %9 = alloca { i64, i64 }, align 16
  %10 = alloca %..string, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %4, align 8
  store %..string %1, ptr %5, align 8
  store { ptr, i64 } %2, ptr %6, align 8
  store i8 %3, ptr %7, align 1
  %11 = call { i64, i64 } @"strings::to_writer"(ptr %0, ptr %__.context_ptr)
  store { i64, i64 } %11, ptr %8, align 8
  %12 = load %"io::Stream", ptr %8, align 8
  store %"io::Stream" %12, ptr %9, align 8
  %13 = load { i64, i64 }, ptr %9, align 8
  %14 = call i64 @"fmt::wprintf"({ i64, i64 } %13, %..string %1, { ptr, i64 } %2, i8 1, i8 %3, ptr %__.context_ptr)
  %15 = load %"strings::Builder", ptr %0, align 8
  %16 = call %..string @"strings::to_string"(ptr %0, ptr %__.context_ptr)
  store %..string %16, ptr %10, align 8
  %17 = load %..string, ptr %10, align 8
  ret %..string %17
}

define internal i32 @"reflect::write_typeid_writer"({ i64, i64 } %0, i64 %1, ptr %2, ptr noalias nonnull %3, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %4 = alloca %"io::Stream", align 16
  %5 = alloca i64, align 8
  %6 = alloca ptr, align 8
  %n = alloca i64, align 8
  %err = alloca i32, align 4
  %7 = alloca { i64, i64 }, align 16
  %8 = alloca i64, align 8
  %9 = alloca { i64, i32 }, align 8
  br label %entry

entry:                                            ; preds = %decls
  store { i64, i64 } %0, ptr %4, align 8
  %10 = load %"io::Stream", ptr %4, align 8
  store i64 %1, ptr %5, align 8
  store ptr %2, ptr %6, align 8
  store i64 0, ptr %n, align 8
  store i32 0, ptr %err, align 4
  %11 = call ptr @"runtime::__type_info_of"(i64 %1)
  store %"io::Stream" %10, ptr %7, align 8
  %12 = load { i64, i64 }, ptr %7, align 8
  store i64 0, ptr %8, align 8
  %13 = call i32 @"reflect::write_type_writer"({ i64, i64 } %12, ptr %11, ptr %2, ptr %8, ptr %__.context_ptr)
  %14 = load i64, ptr %8, align 8
  %15 = load { i64, i32 }, ptr %9, align 8
  store i64 %14, ptr %n, align 8
  store i32 %13, ptr %err, align 4
  store i64 %14, ptr %3, align 8
  ret i32 %13
}

define internal i8 @"runtime::_make_dynamic_array_len_cap"(ptr %0, i64 %1, i64 %2, i64 %3, i64 %4, ptr byval(%"runtime::Allocator") align 8 %5, ptr %6, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %7 = alloca ptr, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca %"runtime::Allocator", align 8
  %err = alloca i8, align 1
  %13 = alloca { i64, i64 }, align 16
  %14 = alloca { ptr, i64 }, align 8
  %15 = alloca { { ptr, i64 }, i8 }, align 8
  %data = alloca { ptr, i64 }, align 8
  %use_zero = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %7, align 8
  store i64 %1, ptr %8, align 8
  store i64 %2, ptr %9, align 8
  store i64 %3, ptr %10, align 8
  store i64 %4, ptr %11, align 8
  call void @llvm.memcpy.inline.p0.p0.i64(ptr %12, ptr %5, i64 16, i1 false)
  store i8 0, ptr %err, align 1
  %16 = load %"runtime::Source_Code_Location", ptr %6, align 8
  call void @"runtime::make_dynamic_array_error_loc"(ptr %6, i64 %3, i64 %4)
  %17 = load ptr, ptr %7, align 8
  %18 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %17, i32 0, i32 3
  %19 = load %"runtime::Allocator", ptr %12, align 8
  store %"runtime::Allocator" %19, ptr %18, align 8
  %20 = mul i64 %1, %4
  %21 = load %"runtime::Allocator", ptr %12, align 8
  %22 = load %"runtime::Source_Code_Location", ptr %6, align 8
  store %"runtime::Allocator" %21, ptr %13, align 8
  %23 = load { i64, i64 }, ptr %13, align 8
  call void @llvm.memset.inline.p0.i64(ptr %14, i8 0, i64 16, i1 false)
  %24 = call i8 @"runtime::mem_alloc_bytes"(i64 %20, i64 %2, { i64, i64 } %23, ptr %6, ptr %14, ptr %__.context_ptr)
  %25 = load { ptr, i64 }, ptr %14, align 8
  %26 = load { { ptr, i64 }, i8 }, ptr %15, align 8
  %27 = icmp eq i8 %24, 0
  br i1 %27, label %or_return.continue, label %or_return.return

or_return.return:                                 ; preds = %entry
  store i8 %24, ptr %err, align 1
  %28 = load i8, ptr %err, align 1
  store i8 %28, ptr %err, align 1
  ret i8 %28

or_return.continue:                               ; preds = %entry
  store { ptr, i64 } %25, ptr %data, align 8
  %29 = load { ptr, i64 }, ptr %data, align 8
  %30 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %31 = load ptr, ptr %30, align 8
  %32 = icmp eq ptr %31, null
  %33 = zext i1 %32 to i8
  %34 = icmp ne i8 %33, 0
  br i1 %34, label %logical.cmp.rhs, label %logical.cmp.done

logical.cmp.rhs:                                  ; preds = %or_return.continue
  %35 = icmp ne i64 %1, 0
  %36 = zext i1 %35 to i8
  %37 = icmp ne i8 %36, 0
  br label %logical.cmp.done

logical.cmp.done:                                 ; preds = %logical.cmp.rhs, %or_return.continue
  %38 = phi i1 [ false, %or_return.continue ], [ %37, %logical.cmp.rhs ]
  %39 = zext i1 %38 to i8
  store i8 %39, ptr %use_zero, align 1
  %40 = load ptr, ptr %7, align 8
  %41 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %40, i32 0, i32 0
  %42 = load { ptr, i64 }, ptr %data, align 8
  %43 = getelementptr inbounds nuw { ptr, i64 }, ptr %data, i32 0, i32 0
  %44 = load ptr, ptr %43, align 8
  store ptr %44, ptr %41, align 8
  %45 = load ptr, ptr %7, align 8
  %46 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %45, i32 0, i32 1
  %47 = load i8, ptr %use_zero, align 1
  %48 = icmp ne i8 %47, 0
  br i1 %48, label %if.then, label %if.else

if.then:                                          ; preds = %logical.cmp.done
  br label %if.done

if.else:                                          ; preds = %logical.cmp.done
  br label %if.done

if.done:                                          ; preds = %if.else, %if.then
  %49 = phi i64 [ 0, %if.then ], [ %3, %if.else ]
  store i64 %49, ptr %46, align 8
  %50 = load ptr, ptr %7, align 8
  %51 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %50, i32 0, i32 2
  %52 = load i8, ptr %use_zero, align 1
  %53 = icmp ne i8 %52, 0
  br i1 %53, label %if.then1, label %if.else2

if.then1:                                         ; preds = %if.done
  br label %if.done3

if.else2:                                         ; preds = %if.done
  br label %if.done3

if.done3:                                         ; preds = %if.else2, %if.then1
  %54 = phi i64 [ 0, %if.then1 ], [ %4, %if.else2 ]
  store i64 %54, ptr %51, align 8
  %55 = load ptr, ptr %7, align 8
  %56 = getelementptr inbounds nuw %"runtime::Raw_Dynamic_Array", ptr %55, i32 0, i32 3
  %57 = load %"runtime::Allocator", ptr %12, align 8
  store %"runtime::Allocator" %57, ptr %56, align 8
  %58 = load i8, ptr %err, align 1
  store i8 %58, ptr %err, align 1
  ret i8 %58
}

define internal i64 @"mem::align_backward_uintptr"(i64 %0, i64 %1, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %2 = alloca i64, align 8
  %3 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %2, align 8
  store i64 %1, ptr %3, align 8
  %4 = call i8 @"mem::is_power_of_two"(i64 %1)
  %5 = load %"runtime::Source_Code_Location", ptr @"scl$[align_backward_uintptr16529]", align 8
  call void @"runtime::assert"(i8 %4, %..string { ptr @"csbs$byte_world$256", i64 22 }, ptr @"scl$[align_backward_uintptr16529]", ptr %__.context_ptr)
  %6 = sub i64 %1, 1
  %7 = xor i64 %6, -1
  %8 = and i64 %0, %7
  ret i64 %8
}

define internal i64 @"runtime::typeid_base"(i64 %0) {
decls:
  %1 = alloca i64, align 8
  %ti = alloca ptr, align 8
  br label %entry

entry:                                            ; preds = %decls
  store i64 %0, ptr %1, align 8
  %2 = call ptr @"runtime::__type_info_of"(i64 %0)
  store ptr %2, ptr %ti, align 8
  %3 = load ptr, ptr %ti, align 8
  %4 = call ptr @"runtime::type_info_base"(ptr %3)
  store ptr %4, ptr %ti, align 8
  %5 = load ptr, ptr %ti, align 8
  %6 = getelementptr inbounds nuw %"runtime::Type_Info", ptr %5, i32 0, i32 4
  %7 = load i64, ptr %6, align 8
  ret i64 %7
}

define internal i64 @"runtime::map_insert_hash_dynamic_with_key"(ptr noalias %0, ptr noalias %1, i64 %2, i64 %3, i64 %4, ptr noalias nonnull %5, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %6 = alloca ptr, align 8
  %7 = alloca ptr, align 8
  %8 = alloca i64, align 8
  %9 = alloca i64, align 8
  %10 = alloca i64, align 8
  %key = alloca i64, align 8
  %result = alloca i64, align 8
  %h = alloca i64, align 8
  %pos = alloca i64, align 8
  %distance = alloca i64, align 8
  %mask = alloca i64, align 8
  %11 = alloca i64, align 8
  %12 = alloca i64, align 8
  %13 = alloca ptr, align 8
  %14 = alloca i64, align 8
  %15 = alloca { i64, i64, ptr, i64, i64 }, align 8
  %ks = alloca i64, align 8
  %vs = alloca i64, align 8
  %hs = alloca ptr, align 8
  %sk = alloca i64, align 8
  %sv = alloca i64, align 8
  %size_of_k = alloca i64, align 8
  %size_of_v = alloca i64, align 8
  %k = alloca i64, align 8
  %v = alloca i64, align 8
  %tk = alloca i64, align 8
  %tv = alloca i64, align 8
  %element_hash = alloca i64, align 8
  %k_dst = alloca i64, align 8
  %v_dst = alloca i64, align 8
  %probe_distance = alloca i64, align 8
  %kp = alloca i64, align 8
  %vp = alloca i64, align 8
  %th = alloca i64, align 8
  %look_ahead = alloca i64, align 8
  %la_pos = alloca i64, align 8
  %element_hash12 = alloca i64, align 8
  %k_dst16 = alloca i64, align 8
  %v_dst17 = alloca i64, align 8
  %k_src = alloca i64, align 8
  %v_src = alloca i64, align 8
  %probe_distance22 = alloca i64, align 8
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %6, align 8
  store ptr %1, ptr %7, align 8
  store i64 %2, ptr %8, align 8
  store i64 %3, ptr %9, align 8
  store i64 %4, ptr %10, align 8
  store i64 0, ptr %key, align 8
  store i64 0, ptr %result, align 8
  store i64 %2, ptr %h, align 8
  %16 = load %"runtime::Raw_Map", ptr %0, align 8
  %17 = load i64, ptr %h, align 8
  %18 = call i64 @"runtime::map_desired_position"(ptr %0, i64 %17)
  store i64 %18, ptr %pos, align 8
  store i64 0, ptr %distance, align 8
  %19 = load %"runtime::Raw_Map", ptr %0, align 8
  %20 = call i64 @"runtime::map_log2_cap"(ptr %0)
  %21 = icmp ult i64 %20, 64
  %22 = shl i64 1, %20
  %23 = select i1 %21, i64 %22, i64 0
  %24 = sub i64 %23, 1
  store i64 %24, ptr %mask, align 8
  %25 = load %"runtime::Raw_Map", ptr %0, align 8
  store i64 0, ptr %11, align 8
  store i64 0, ptr %12, align 8
  store ptr null, ptr %13, align 8
  store i64 0, ptr %14, align 8
  %26 = call i64 @"runtime::map_kvh_data_dynamic"(ptr %0, ptr %1, ptr %11, ptr %12, ptr %13, ptr %14)
  %27 = load i64, ptr %11, align 8
  %28 = load i64, ptr %12, align 8
  %29 = load ptr, ptr %13, align 8
  %30 = load i64, ptr %14, align 8
  %31 = load { i64, i64, ptr, i64, i64 }, ptr %15, align 8
  store i64 %27, ptr %ks, align 8
  store i64 %28, ptr %vs, align 8
  store ptr %29, ptr %hs, align 8
  store i64 %30, ptr %sk, align 8
  store i64 %26, ptr %sv, align 8
  %32 = load ptr, ptr %7, align 8
  %33 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %32, i32 0, i32 0
  %34 = load ptr, ptr %33, align 8
  %35 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %34, i32 0, i32 0
  %36 = load i64, ptr %35, align 8
  store i64 %36, ptr %size_of_k, align 8
  %37 = load ptr, ptr %7, align 8
  %38 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %37, i32 0, i32 1
  %39 = load ptr, ptr %38, align 8
  %40 = getelementptr inbounds nuw %"runtime::Map_Cell_Info", ptr %39, i32 0, i32 0
  %41 = load i64, ptr %40, align 8
  store i64 %41, ptr %size_of_v, align 8
  %42 = load i64, ptr %sk, align 8
  %43 = load ptr, ptr %7, align 8
  %44 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %43, i32 0, i32 0
  %45 = load ptr, ptr %44, align 8
  %46 = call i64 @"runtime::map_cell_index_dynamic"(i64 %42, ptr %45, i64 0)
  store i64 %46, ptr %k, align 8
  %47 = load i64, ptr %sv, align 8
  %48 = load ptr, ptr %7, align 8
  %49 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %48, i32 0, i32 1
  %50 = load ptr, ptr %49, align 8
  %51 = call i64 @"runtime::map_cell_index_dynamic"(i64 %47, ptr %50, i64 0)
  store i64 %51, ptr %v, align 8
  %52 = load i64, ptr %k, align 8
  %53 = inttoptr i64 %52 to ptr
  %54 = inttoptr i64 %3 to ptr
  %55 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %53, ptr %54, i64 %55, i1 false)
  %56 = load i64, ptr %v, align 8
  %57 = inttoptr i64 %56 to ptr
  %58 = inttoptr i64 %4 to ptr
  %59 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %57, ptr %58, i64 %59, i1 false)
  %60 = load i64, ptr %sk, align 8
  %61 = load ptr, ptr %7, align 8
  %62 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %61, i32 0, i32 0
  %63 = load ptr, ptr %62, align 8
  %64 = call i64 @"runtime::map_cell_index_dynamic"(i64 %60, ptr %63, i64 1)
  store i64 %64, ptr %tk, align 8
  %65 = load i64, ptr %sv, align 8
  %66 = load ptr, ptr %7, align 8
  %67 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %66, i32 0, i32 1
  %68 = load ptr, ptr %67, align 8
  %69 = call i64 @"runtime::map_cell_index_dynamic"(i64 %65, ptr %68, i64 1)
  store i64 %69, ptr %tv, align 8
  br label %for.body

for.body:                                         ; preds = %if.done10, %entry
  %70 = load i64, ptr %distance, align 8
  %71 = load i64, ptr %mask, align 8
  %72 = icmp ugt i64 %70, %71
  %73 = zext i1 %72 to i8
  %74 = icmp ne i8 %73, 0
  br i1 %74, label %if.then, label %if.done

if.then:                                          ; preds = %for.body
  %75 = load %"runtime::Source_Code_Location", ptr @"scl$[map_insert_hash_dynamic_with_key17600]", align 8
  call void @"runtime::panic"(%..string { ptr @"csbs$byte_world$25b", i64 27 }, ptr @"scl$[map_insert_hash_dynamic_with_key17600]", ptr %__.context_ptr)
  unreachable

if.done:                                          ; preds = %for.body
  %76 = load ptr, ptr %hs, align 8
  %77 = load i64, ptr %pos, align 8
  %78 = getelementptr i64, ptr %76, i64 %77
  %79 = load i64, ptr %78, align 8
  store i64 %79, ptr %element_hash, align 8
  %80 = load i64, ptr %element_hash, align 8
  %81 = call i8 @"runtime::map_hash_is_empty"(i64 %80)
  %82 = icmp ne i8 %81, 0
  br i1 %82, label %if.then1, label %if.done4

if.then1:                                         ; preds = %if.done
  %83 = load i64, ptr %ks, align 8
  %84 = load ptr, ptr %7, align 8
  %85 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %84, i32 0, i32 0
  %86 = load ptr, ptr %85, align 8
  %87 = load i64, ptr %pos, align 8
  %88 = call i64 @"runtime::map_cell_index_dynamic"(i64 %83, ptr %86, i64 %87)
  store i64 %88, ptr %k_dst, align 8
  %89 = load i64, ptr %vs, align 8
  %90 = load ptr, ptr %7, align 8
  %91 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %90, i32 0, i32 1
  %92 = load ptr, ptr %91, align 8
  %93 = load i64, ptr %pos, align 8
  %94 = call i64 @"runtime::map_cell_index_dynamic"(i64 %89, ptr %92, i64 %93)
  store i64 %94, ptr %v_dst, align 8
  %95 = load i64, ptr %k_dst, align 8
  %96 = inttoptr i64 %95 to ptr
  %97 = load i64, ptr %k, align 8
  %98 = inttoptr i64 %97 to ptr
  %99 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %96, ptr %98, i64 %99, i1 false)
  %100 = load i64, ptr %v_dst, align 8
  %101 = inttoptr i64 %100 to ptr
  %102 = load i64, ptr %v, align 8
  %103 = inttoptr i64 %102 to ptr
  %104 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %101, ptr %103, i64 %104, i1 false)
  %105 = load ptr, ptr %hs, align 8
  %106 = load i64, ptr %pos, align 8
  %107 = getelementptr i64, ptr %105, i64 %106
  %108 = load i64, ptr %h, align 8
  store i64 %108, ptr %107, align 8
  %109 = load i64, ptr %result, align 8
  %110 = icmp eq i64 %109, 0
  %111 = zext i1 %110 to i8
  %112 = icmp ne i8 %111, 0
  br i1 %112, label %if.then2, label %if.done3

if.then2:                                         ; preds = %if.then1
  %113 = load i64, ptr %k_dst, align 8
  store i64 %113, ptr %key, align 8
  %114 = load i64, ptr %v_dst, align 8
  store i64 %114, ptr %result, align 8
  br label %if.done3

if.done3:                                         ; preds = %if.then2, %if.then1
  %115 = load i64, ptr %key, align 8
  %116 = load i64, ptr %result, align 8
  store i64 %115, ptr %key, align 8
  store i64 %116, ptr %result, align 8
  store i64 %115, ptr %5, align 8
  ret i64 %116

if.done4:                                         ; preds = %if.done
  %117 = load i64, ptr %element_hash, align 8
  %118 = call i8 @"runtime::map_hash_is_deleted"(i64 %117)
  %119 = icmp ne i8 %118, 0
  br i1 %119, label %if.then5, label %if.done6

if.then5:                                         ; preds = %if.done4
  br label %for.done

unreachable:                                      ; No predecessors!
  br label %if.done6

if.done6:                                         ; preds = %unreachable, %if.done4
  br label %if.init

if.init:                                          ; preds = %if.done6
  %120 = load %"runtime::Raw_Map", ptr %0, align 8
  %121 = load i64, ptr %element_hash, align 8
  %122 = load i64, ptr %pos, align 8
  %123 = call i64 @"runtime::map_probe_distance"(ptr %0, i64 %121, i64 %122)
  store i64 %123, ptr %probe_distance, align 8
  %124 = load i64, ptr %distance, align 8
  %125 = load i64, ptr %probe_distance, align 8
  %126 = icmp ugt i64 %124, %125
  %127 = zext i1 %126 to i8
  %128 = icmp ne i8 %127, 0
  br i1 %128, label %if.then7, label %if.done10

if.then7:                                         ; preds = %if.init
  %129 = load i64, ptr %ks, align 8
  %130 = load ptr, ptr %7, align 8
  %131 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %130, i32 0, i32 0
  %132 = load ptr, ptr %131, align 8
  %133 = load i64, ptr %pos, align 8
  %134 = call i64 @"runtime::map_cell_index_dynamic"(i64 %129, ptr %132, i64 %133)
  store i64 %134, ptr %kp, align 8
  %135 = load i64, ptr %vs, align 8
  %136 = load ptr, ptr %7, align 8
  %137 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %136, i32 0, i32 1
  %138 = load ptr, ptr %137, align 8
  %139 = load i64, ptr %pos, align 8
  %140 = call i64 @"runtime::map_cell_index_dynamic"(i64 %135, ptr %138, i64 %139)
  store i64 %140, ptr %vp, align 8
  %141 = load i64, ptr %result, align 8
  %142 = icmp eq i64 %141, 0
  %143 = zext i1 %142 to i8
  %144 = icmp ne i8 %143, 0
  br i1 %144, label %if.then8, label %if.done9

if.then8:                                         ; preds = %if.then7
  %145 = load i64, ptr %kp, align 8
  store i64 %145, ptr %key, align 8
  %146 = load i64, ptr %vp, align 8
  store i64 %146, ptr %result, align 8
  br label %if.done9

if.done9:                                         ; preds = %if.then8, %if.then7
  %147 = load i64, ptr %tk, align 8
  %148 = inttoptr i64 %147 to ptr
  %149 = load i64, ptr %k, align 8
  %150 = inttoptr i64 %149 to ptr
  %151 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %148, ptr %150, i64 %151, i1 false)
  %152 = load i64, ptr %k, align 8
  %153 = inttoptr i64 %152 to ptr
  %154 = load i64, ptr %kp, align 8
  %155 = inttoptr i64 %154 to ptr
  %156 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %153, ptr %155, i64 %156, i1 false)
  %157 = load i64, ptr %kp, align 8
  %158 = inttoptr i64 %157 to ptr
  %159 = load i64, ptr %tk, align 8
  %160 = inttoptr i64 %159 to ptr
  %161 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %158, ptr %160, i64 %161, i1 false)
  %162 = load i64, ptr %tv, align 8
  %163 = inttoptr i64 %162 to ptr
  %164 = load i64, ptr %v, align 8
  %165 = inttoptr i64 %164 to ptr
  %166 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %163, ptr %165, i64 %166, i1 false)
  %167 = load i64, ptr %v, align 8
  %168 = inttoptr i64 %167 to ptr
  %169 = load i64, ptr %vp, align 8
  %170 = inttoptr i64 %169 to ptr
  %171 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %168, ptr %170, i64 %171, i1 false)
  %172 = load i64, ptr %vp, align 8
  %173 = inttoptr i64 %172 to ptr
  %174 = load i64, ptr %tv, align 8
  %175 = inttoptr i64 %174 to ptr
  %176 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %173, ptr %175, i64 %176, i1 false)
  %177 = load i64, ptr %h, align 8
  store i64 %177, ptr %th, align 8
  %178 = load ptr, ptr %hs, align 8
  %179 = load i64, ptr %pos, align 8
  %180 = getelementptr i64, ptr %178, i64 %179
  %181 = load i64, ptr %180, align 8
  store i64 %181, ptr %h, align 8
  %182 = load ptr, ptr %hs, align 8
  %183 = load i64, ptr %pos, align 8
  %184 = getelementptr i64, ptr %182, i64 %183
  %185 = load i64, ptr %th, align 8
  store i64 %185, ptr %184, align 8
  %186 = load i64, ptr %probe_distance, align 8
  store i64 %186, ptr %distance, align 8
  br label %if.done10

if.done10:                                        ; preds = %if.done9, %if.init
  %187 = load i64, ptr %pos, align 8
  %188 = add i64 %187, 1
  %189 = load i64, ptr %mask, align 8
  %190 = and i64 %188, %189
  store i64 %190, ptr %pos, align 8
  %191 = load i64, ptr %distance, align 8
  %192 = add i64 %191, 1
  store i64 %192, ptr %distance, align 8
  br label %for.body

for.done:                                         ; preds = %if.then5
  %193 = load ptr, ptr %hs, align 8
  %194 = load i64, ptr %pos, align 8
  %195 = getelementptr i64, ptr %193, i64 %194
  store i64 0, ptr %195, align 8
  store i64 1, ptr %look_ahead, align 8
  br label %for.body11

for.body11:                                       ; preds = %if.done39, %if.then13, %for.done
  %196 = load i64, ptr %pos, align 8
  %197 = load i64, ptr %look_ahead, align 8
  %198 = add i64 %196, %197
  %199 = load i64, ptr %mask, align 8
  %200 = and i64 %198, %199
  store i64 %200, ptr %la_pos, align 8
  %201 = load ptr, ptr %hs, align 8
  %202 = load i64, ptr %la_pos, align 8
  %203 = getelementptr i64, ptr %201, i64 %202
  %204 = load i64, ptr %203, align 8
  store i64 %204, ptr %element_hash12, align 8
  %205 = load i64, ptr %element_hash12, align 8
  %206 = call i8 @"runtime::map_hash_is_deleted"(i64 %205)
  %207 = icmp ne i8 %206, 0
  br i1 %207, label %if.then13, label %if.done15

if.then13:                                        ; preds = %for.body11
  %208 = load i64, ptr %look_ahead, align 8
  %209 = add i64 %208, 1
  store i64 %209, ptr %look_ahead, align 8
  %210 = load ptr, ptr %hs, align 8
  %211 = load i64, ptr %la_pos, align 8
  %212 = getelementptr i64, ptr %210, i64 %211
  store i64 0, ptr %212, align 8
  br label %for.body11

unreachable14:                                    ; No predecessors!
  br label %if.done15

if.done15:                                        ; preds = %unreachable14, %for.body11
  %213 = load i64, ptr %ks, align 8
  %214 = load ptr, ptr %7, align 8
  %215 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %214, i32 0, i32 0
  %216 = load ptr, ptr %215, align 8
  %217 = load i64, ptr %pos, align 8
  %218 = call i64 @"runtime::map_cell_index_dynamic"(i64 %213, ptr %216, i64 %217)
  store i64 %218, ptr %k_dst16, align 8
  %219 = load i64, ptr %vs, align 8
  %220 = load ptr, ptr %7, align 8
  %221 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %220, i32 0, i32 1
  %222 = load ptr, ptr %221, align 8
  %223 = load i64, ptr %pos, align 8
  %224 = call i64 @"runtime::map_cell_index_dynamic"(i64 %219, ptr %222, i64 %223)
  store i64 %224, ptr %v_dst17, align 8
  %225 = load i64, ptr %element_hash12, align 8
  %226 = call i8 @"runtime::map_hash_is_empty"(i64 %225)
  %227 = icmp ne i8 %226, 0
  br i1 %227, label %if.then18, label %if.done21

if.then18:                                        ; preds = %if.done15
  %228 = load i64, ptr %k_dst16, align 8
  %229 = inttoptr i64 %228 to ptr
  %230 = load i64, ptr %k, align 8
  %231 = inttoptr i64 %230 to ptr
  %232 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %229, ptr %231, i64 %232, i1 false)
  %233 = load i64, ptr %v_dst17, align 8
  %234 = inttoptr i64 %233 to ptr
  %235 = load i64, ptr %v, align 8
  %236 = inttoptr i64 %235 to ptr
  %237 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %234, ptr %236, i64 %237, i1 false)
  %238 = load ptr, ptr %hs, align 8
  %239 = load i64, ptr %pos, align 8
  %240 = getelementptr i64, ptr %238, i64 %239
  %241 = load i64, ptr %h, align 8
  store i64 %241, ptr %240, align 8
  %242 = load i64, ptr %result, align 8
  %243 = icmp eq i64 %242, 0
  %244 = zext i1 %243 to i8
  %245 = icmp ne i8 %244, 0
  br i1 %245, label %if.then19, label %if.done20

if.then19:                                        ; preds = %if.then18
  %246 = load i64, ptr %k_dst16, align 8
  store i64 %246, ptr %key, align 8
  %247 = load i64, ptr %v_dst17, align 8
  store i64 %247, ptr %result, align 8
  br label %if.done20

if.done20:                                        ; preds = %if.then19, %if.then18
  %248 = load i64, ptr %key, align 8
  %249 = load i64, ptr %result, align 8
  store i64 %248, ptr %key, align 8
  store i64 %249, ptr %result, align 8
  store i64 %248, ptr %5, align 8
  ret i64 %249

if.done21:                                        ; preds = %if.done15
  %250 = load i64, ptr %ks, align 8
  %251 = load ptr, ptr %7, align 8
  %252 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %251, i32 0, i32 0
  %253 = load ptr, ptr %252, align 8
  %254 = load i64, ptr %la_pos, align 8
  %255 = call i64 @"runtime::map_cell_index_dynamic"(i64 %250, ptr %253, i64 %254)
  store i64 %255, ptr %k_src, align 8
  %256 = load i64, ptr %vs, align 8
  %257 = load ptr, ptr %7, align 8
  %258 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %257, i32 0, i32 1
  %259 = load ptr, ptr %258, align 8
  %260 = load i64, ptr %la_pos, align 8
  %261 = call i64 @"runtime::map_cell_index_dynamic"(i64 %256, ptr %259, i64 %260)
  store i64 %261, ptr %v_src, align 8
  %262 = load %"runtime::Raw_Map", ptr %0, align 8
  %263 = load i64, ptr %element_hash12, align 8
  %264 = load i64, ptr %la_pos, align 8
  %265 = call i64 @"runtime::map_probe_distance"(ptr %0, i64 %263, i64 %264)
  store i64 %265, ptr %probe_distance22, align 8
  %266 = load i64, ptr %probe_distance22, align 8
  %267 = load i64, ptr %look_ahead, align 8
  %268 = icmp ult i64 %266, %267
  %269 = zext i1 %268 to i8
  %270 = icmp ne i8 %269, 0
  br i1 %270, label %if.then23, label %if.else

if.then23:                                        ; preds = %if.done21
  %271 = load i64, ptr %result, align 8
  %272 = icmp eq i64 %271, 0
  %273 = zext i1 %272 to i8
  %274 = icmp ne i8 %273, 0
  br i1 %274, label %if.then24, label %if.done25

if.then24:                                        ; preds = %if.then23
  %275 = load i64, ptr %k_dst16, align 8
  store i64 %275, ptr %key, align 8
  %276 = load i64, ptr %v_dst17, align 8
  store i64 %276, ptr %result, align 8
  br label %if.done25

if.done25:                                        ; preds = %if.then24, %if.then23
  %277 = load i64, ptr %k_dst16, align 8
  %278 = inttoptr i64 %277 to ptr
  %279 = load i64, ptr %k, align 8
  %280 = inttoptr i64 %279 to ptr
  %281 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %278, ptr %280, i64 %281, i1 false)
  %282 = load i64, ptr %v_dst17, align 8
  %283 = inttoptr i64 %282 to ptr
  %284 = load i64, ptr %v, align 8
  %285 = inttoptr i64 %284 to ptr
  %286 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %283, ptr %285, i64 %286, i1 false)
  %287 = load ptr, ptr %hs, align 8
  %288 = load i64, ptr %pos, align 8
  %289 = getelementptr i64, ptr %287, i64 %288
  %290 = load i64, ptr %h, align 8
  store i64 %290, ptr %289, align 8
  %291 = load i64, ptr %la_pos, align 8
  %292 = load i64, ptr %probe_distance22, align 8
  %293 = sub i64 %291, %292
  %294 = load i64, ptr %mask, align 8
  %295 = and i64 %293, %294
  store i64 %295, ptr %pos, align 8
  %296 = load i64, ptr %probe_distance22, align 8
  %297 = load i64, ptr %look_ahead, align 8
  %298 = sub i64 %297, %296
  store i64 %298, ptr %look_ahead, align 8
  br label %for.loop

for.loop:                                         ; preds = %if.done32, %if.done25
  %299 = load i64, ptr %probe_distance22, align 8
  %300 = icmp ne i64 %299, 0
  %301 = zext i1 %300 to i8
  %302 = icmp ne i8 %301, 0
  br i1 %302, label %for.body26, label %for.done33

for.body26:                                       ; preds = %for.loop
  %303 = load i64, ptr %ks, align 8
  %304 = load ptr, ptr %7, align 8
  %305 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %304, i32 0, i32 0
  %306 = load ptr, ptr %305, align 8
  %307 = load i64, ptr %pos, align 8
  %308 = call i64 @"runtime::map_cell_index_dynamic"(i64 %303, ptr %306, i64 %307)
  store i64 %308, ptr %k_dst16, align 8
  %309 = load i64, ptr %vs, align 8
  %310 = load ptr, ptr %7, align 8
  %311 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %310, i32 0, i32 1
  %312 = load ptr, ptr %311, align 8
  %313 = load i64, ptr %pos, align 8
  %314 = call i64 @"runtime::map_cell_index_dynamic"(i64 %309, ptr %312, i64 %313)
  store i64 %314, ptr %v_dst17, align 8
  %315 = load i64, ptr %k_dst16, align 8
  %316 = inttoptr i64 %315 to ptr
  %317 = load i64, ptr %k_src, align 8
  %318 = inttoptr i64 %317 to ptr
  %319 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %316, ptr %318, i64 %319, i1 false)
  %320 = load i64, ptr %v_dst17, align 8
  %321 = inttoptr i64 %320 to ptr
  %322 = load i64, ptr %v_src, align 8
  %323 = inttoptr i64 %322 to ptr
  %324 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %321, ptr %323, i64 %324, i1 false)
  %325 = load ptr, ptr %hs, align 8
  %326 = load i64, ptr %pos, align 8
  %327 = getelementptr i64, ptr %325, i64 %326
  %328 = load i64, ptr %element_hash12, align 8
  store i64 %328, ptr %327, align 8
  %329 = load ptr, ptr %hs, align 8
  %330 = load i64, ptr %la_pos, align 8
  %331 = getelementptr i64, ptr %329, i64 %330
  store i64 0, ptr %331, align 8
  %332 = load i64, ptr %pos, align 8
  %333 = add i64 %332, 1
  %334 = load i64, ptr %mask, align 8
  %335 = and i64 %333, %334
  store i64 %335, ptr %pos, align 8
  %336 = load i64, ptr %la_pos, align 8
  %337 = add i64 %336, 1
  %338 = load i64, ptr %mask, align 8
  %339 = and i64 %337, %338
  store i64 %339, ptr %la_pos, align 8
  %340 = load i64, ptr %la_pos, align 8
  %341 = load i64, ptr %pos, align 8
  %342 = sub i64 %340, %341
  %343 = load i64, ptr %mask, align 8
  %344 = and i64 %342, %343
  store i64 %344, ptr %look_ahead, align 8
  %345 = load ptr, ptr %hs, align 8
  %346 = load i64, ptr %la_pos, align 8
  %347 = getelementptr i64, ptr %345, i64 %346
  %348 = load i64, ptr %347, align 8
  store i64 %348, ptr %element_hash12, align 8
  %349 = load i64, ptr %element_hash12, align 8
  %350 = call i8 @"runtime::map_hash_is_empty"(i64 %349)
  %351 = icmp ne i8 %350, 0
  br i1 %351, label %if.then27, label %if.done28

if.then27:                                        ; preds = %for.body26
  %352 = load i64, ptr %key, align 8
  %353 = load i64, ptr %result, align 8
  store i64 %352, ptr %key, align 8
  store i64 %353, ptr %result, align 8
  store i64 %352, ptr %5, align 8
  ret i64 %353

if.done28:                                        ; preds = %for.body26
  %354 = load %"runtime::Raw_Map", ptr %0, align 8
  %355 = load i64, ptr %element_hash12, align 8
  %356 = load i64, ptr %la_pos, align 8
  %357 = call i64 @"runtime::map_probe_distance"(ptr %0, i64 %355, i64 %356)
  store i64 %357, ptr %probe_distance22, align 8
  %358 = load i64, ptr %probe_distance22, align 8
  %359 = icmp eq i64 %358, 0
  %360 = zext i1 %359 to i8
  %361 = icmp ne i8 %360, 0
  br i1 %361, label %if.then29, label %if.done30

if.then29:                                        ; preds = %if.done28
  %362 = load i64, ptr %key, align 8
  %363 = load i64, ptr %result, align 8
  store i64 %362, ptr %key, align 8
  store i64 %363, ptr %result, align 8
  store i64 %362, ptr %5, align 8
  ret i64 %363

if.done30:                                        ; preds = %if.done28
  %364 = load i64, ptr %probe_distance22, align 8
  %365 = load i64, ptr %look_ahead, align 8
  %366 = icmp ult i64 %364, %365
  %367 = zext i1 %366 to i8
  %368 = icmp ne i8 %367, 0
  br i1 %368, label %if.then31, label %if.done32

if.then31:                                        ; preds = %if.done30
  %369 = load i64, ptr %la_pos, align 8
  %370 = load i64, ptr %probe_distance22, align 8
  %371 = sub i64 %369, %370
  %372 = load i64, ptr %mask, align 8
  %373 = and i64 %371, %372
  store i64 %373, ptr %pos, align 8
  br label %if.done32

if.done32:                                        ; preds = %if.then31, %if.done30
  %374 = load i64, ptr %ks, align 8
  %375 = load ptr, ptr %7, align 8
  %376 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %375, i32 0, i32 0
  %377 = load ptr, ptr %376, align 8
  %378 = load i64, ptr %la_pos, align 8
  %379 = call i64 @"runtime::map_cell_index_dynamic"(i64 %374, ptr %377, i64 %378)
  store i64 %379, ptr %k_src, align 8
  %380 = load i64, ptr %vs, align 8
  %381 = load ptr, ptr %7, align 8
  %382 = getelementptr inbounds nuw %"runtime::Map_Info", ptr %381, i32 0, i32 1
  %383 = load ptr, ptr %382, align 8
  %384 = load i64, ptr %la_pos, align 8
  %385 = call i64 @"runtime::map_cell_index_dynamic"(i64 %380, ptr %383, i64 %384)
  store i64 %385, ptr %v_src, align 8
  br label %for.loop

for.done33:                                       ; preds = %for.loop
  %386 = load i64, ptr %key, align 8
  %387 = load i64, ptr %result, align 8
  store i64 %386, ptr %key, align 8
  store i64 %387, ptr %result, align 8
  store i64 %386, ptr %5, align 8
  ret i64 %387

if.else:                                          ; preds = %if.done21
  %388 = load i64, ptr %distance, align 8
  %389 = load i64, ptr %probe_distance22, align 8
  %390 = load i64, ptr %look_ahead, align 8
  %391 = sub i64 %389, %390
  %392 = icmp ult i64 %388, %391
  %393 = zext i1 %392 to i8
  %394 = icmp ne i8 %393, 0
  br i1 %394, label %if.then34, label %if.else35

if.then34:                                        ; preds = %if.else
  %395 = load i64, ptr %k_dst16, align 8
  %396 = inttoptr i64 %395 to ptr
  %397 = load i64, ptr %k_src, align 8
  %398 = inttoptr i64 %397 to ptr
  %399 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %396, ptr %398, i64 %399, i1 false)
  %400 = load i64, ptr %v_dst17, align 8
  %401 = inttoptr i64 %400 to ptr
  %402 = load i64, ptr %v_src, align 8
  %403 = inttoptr i64 %402 to ptr
  %404 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %401, ptr %403, i64 %404, i1 false)
  %405 = load ptr, ptr %hs, align 8
  %406 = load i64, ptr %pos, align 8
  %407 = getelementptr i64, ptr %405, i64 %406
  %408 = load i64, ptr %element_hash12, align 8
  store i64 %408, ptr %407, align 8
  %409 = load ptr, ptr %hs, align 8
  %410 = load i64, ptr %la_pos, align 8
  %411 = getelementptr i64, ptr %409, i64 %410
  store i64 0, ptr %411, align 8
  br label %if.done38

if.else35:                                        ; preds = %if.else
  %412 = load i64, ptr %result, align 8
  %413 = icmp eq i64 %412, 0
  %414 = zext i1 %413 to i8
  %415 = icmp ne i8 %414, 0
  br i1 %415, label %if.then36, label %if.done37

if.then36:                                        ; preds = %if.else35
  %416 = load i64, ptr %k_dst16, align 8
  store i64 %416, ptr %key, align 8
  %417 = load i64, ptr %v_dst17, align 8
  store i64 %417, ptr %result, align 8
  br label %if.done37

if.done37:                                        ; preds = %if.then36, %if.else35
  %418 = load i64, ptr %k_dst16, align 8
  %419 = inttoptr i64 %418 to ptr
  %420 = load i64, ptr %k, align 8
  %421 = inttoptr i64 %420 to ptr
  %422 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %419, ptr %421, i64 %422, i1 false)
  %423 = load i64, ptr %v_dst17, align 8
  %424 = inttoptr i64 %423 to ptr
  %425 = load i64, ptr %v, align 8
  %426 = inttoptr i64 %425 to ptr
  %427 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %424, ptr %426, i64 %427, i1 false)
  %428 = load ptr, ptr %hs, align 8
  %429 = load i64, ptr %pos, align 8
  %430 = getelementptr i64, ptr %428, i64 %429
  %431 = load i64, ptr %h, align 8
  store i64 %431, ptr %430, align 8
  %432 = load i64, ptr %k, align 8
  %433 = inttoptr i64 %432 to ptr
  %434 = load i64, ptr %k_src, align 8
  %435 = inttoptr i64 %434 to ptr
  %436 = load i64, ptr %size_of_k, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %433, ptr %435, i64 %436, i1 false)
  %437 = load i64, ptr %v, align 8
  %438 = inttoptr i64 %437 to ptr
  %439 = load i64, ptr %v_src, align 8
  %440 = inttoptr i64 %439 to ptr
  %441 = load i64, ptr %size_of_v, align 8
  call void @llvm.memcpy.p0.p0.i64(ptr %438, ptr %440, i64 %441, i1 false)
  %442 = load ptr, ptr %hs, align 8
  %443 = load i64, ptr %la_pos, align 8
  %444 = getelementptr i64, ptr %442, i64 %443
  %445 = load i64, ptr %444, align 8
  store i64 %445, ptr %h, align 8
  %446 = load ptr, ptr %hs, align 8
  %447 = load i64, ptr %la_pos, align 8
  %448 = getelementptr i64, ptr %446, i64 %447
  store i64 0, ptr %448, align 8
  %449 = load i64, ptr %probe_distance22, align 8
  %450 = load i64, ptr %look_ahead, align 8
  %451 = sub i64 %449, %450
  store i64 %451, ptr %distance, align 8
  br label %if.done38

if.done38:                                        ; preds = %if.done37, %if.then34
  br label %if.done39

if.done39:                                        ; preds = %if.done38
  %452 = load i64, ptr %pos, align 8
  %453 = add i64 %452, 1
  %454 = load i64, ptr %mask, align 8
  %455 = and i64 %453, %454
  store i64 %455, ptr %pos, align 8
  %456 = load i64, ptr %distance, align 8
  %457 = add i64 %456, 1
  store i64 %457, ptr %distance, align 8
  br label %for.body11

for.done40:                                       ; No predecessors!
  unreachable
}

define internal void @"main::alpha_add_atomic"(ptr %0, float %1, float %2, ptr noalias nonnull "captures"="none" %__.context_ptr) {
decls:
  %3 = alloca ptr, align 8
  %4 = alloca float, align 4
  %5 = alloca float, align 4
  %old_val = alloca float, align 4
  %new_val = alloca float, align 4
  %ok = alloca i8, align 1
  br label %entry

entry:                                            ; preds = %decls
  store ptr %0, ptr %3, align 8
  store float %1, ptr %4, align 4
  store float %2, ptr %5, align 4
  br label %for.body

for.body:                                         ; preds = %if.done, %entry
  %6 = load atomic volatile float, ptr %0 seq_cst, align 4
  store float %6, ptr %old_val, align 4
  %7 = load float, ptr %old_val, align 4
  %8 = fadd float %7, %1
  %9 = call float @"main::min_f32"(float %8, float %2, ptr %__.context_ptr)
  store float %9, ptr %new_val, align 4
  %10 = load float, ptr %old_val, align 4
  %11 = load float, ptr %new_val, align 4
  %12 = cmpxchg weak volatile ptr %0, float %10, float %11 seq_cst seq_cst, align 4
  %13 = extractvalue { float, i1 } %12, 0
  %14 = extractvalue { float, i1 } %12, 1
  %15 = zext i1 %14 to i8
  store i8 %15, ptr %ok, align 1
  %16 = load i8, ptr %ok, align 1
  %17 = icmp ne i8 %16, 0
  br i1 %17, label %if.then, label %if.done

if.then:                                          ; preds = %for.body
  br label %for.done

unreachable:                                      ; No predecessors!
  br label %if.done

if.done:                                          ; preds = %unreachable, %for.body
  br label %for.body

for.done:                                         ; preds = %if.then
  ret void
}

declare internal i64 @"time::time_to_unix_nano"(i64)

declare internal i8 @"runtime::string_eq"(%..string, %..string)

; Function Attrs: noinline
declare internal i32 @"reflect::write_type_writer"({ i64, i64 }, ptr, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none") #4

declare internal void @"main::try_spawn_child_adjacent_atomic"(ptr noalias sret(%"main::Spark"), ptr, i64, i64, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal void @"runtime::default_logger_proc"(ptr, i64, %..string, i16, ptr, ptr noalias nonnull "captures"="none")

declare internal void @"runtime::default_context"(ptr noalias sret(%"runtime::Context"))

; Function Attrs: alwaysinline
declare internal i8 @"runtime::string_ne"(%..string, %..string) #3

declare internal void @"sync::sema_post"(ptr, i64)

declare internal void @"runtime::[core.odin]::__init_context"(ptr)

declare internal void @"main::attempt_with_dir"(ptr noalias sret(%"main::Attempt_Result"), ptr, ptr, i64, i64, ptr noalias nonnull "captures"="none")

declare internal i64 @"fmt::wprintln"({ i64, i64 }, { ptr, i64 }, %..string, i8, ptr noalias nonnull "captures"="none")

declare internal void @"sync::sema_wait"(ptr)

; Function Attrs: noreturn
declare internal void @"runtime::default_assertion_failure_proc"(%..string, %..string, ptr, ptr noalias nonnull "captures"="none") #2

; Function Attrs: noreturn
declare internal void @"runtime::default_assertion_contextless_failure_proc"(%..string, %..string, ptr) #2

declare internal i64 @"fmt::wprintf"({ i64, i64 }, %..string, { ptr, i64 }, i8, i8, ptr noalias nonnull "captures"="none")

declare internal i64 @"runtime::cstring_len"(ptr)

declare i32 @get_nprocs()

declare internal i64 @"runtime::cstring16_len"(ptr)

declare internal i8 @"runtime::make_slice:proc(T:$[]bool,len:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(res:[]bool,err:runtime::Allocator_Error)"(i64, { i64, i64 }, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i8 @"runtime::make_dynamic_array:proc(T:$[dynamic]u8,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]u8,err:runtime::Allocator_Error)"({ i64, i64 }, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i8 @"runtime::make_dynamic_array:proc(T:$[dynamic]main::Relative_Spark,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]main::Relative_Spark,err:runtime::Allocator_Error)"({ i64, i64 }, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i8 @"runtime::make_dynamic_array:proc(T:$[dynamic]main::Pattern,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]main::Pattern,err:runtime::Allocator_Error)"({ i64, i64 }, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i8 @"runtime::make_dynamic_array_len_cap:proc(T:$[dynamic]main::Relative_Spark,len:int,cap:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]main::Relative_Spark,err:runtime::Allocator_Error)"(i64, i64, { i64, i64 }, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i8 @"runtime::make_dynamic_array_len_cap:proc(T:$[dynamic]int,len:int,cap:int,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(array:[dynamic]int,err:runtime::Allocator_Error)"(i64, i64, { i64, i64 }, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal %..string @"runtime::cstring_to_string"(ptr)

declare internal i64 @"time::[time.odin]::_time_abs"(i64)

declare internal i64 @"time::[time.odin]::_abs_date"(i64, i8, ptr noalias nonnull, ptr noalias nonnull, ptr noalias nonnull)

declare internal void @"thread::_select_context_for_thread"(ptr noalias sret(%"runtime::Context"), ptr, ptr noalias nonnull "captures"="none")

declare internal %..string16 @"runtime::cstring16_to_string16"(ptr)

declare internal i8 @"runtime::cstring_eq"(ptr, ptr)

declare internal void @"sync::futex_wait"(ptr, i32)

declare internal void @"thread::_maybe_destroy_default_temp_allocator"(ptr, ptr noalias nonnull "captures"="none")

declare internal i8 @"reflect::struct_tag_lookup"(%..string, %..string, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

; Function Attrs: alwaysinline
declare internal i8 @"runtime::cstring_ne"(ptr, ptr) #3

declare internal void @"sync::futex_signal"(ptr)

declare internal void @"sync::futex_broadcast"(ptr)

; Function Attrs: noinline
declare internal i8 @"runtime::_append_elem"(ptr, i64, i64, ptr, i8, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none") #4

declare internal i8 @"runtime::cstring16_eq"(ptr, ptr)

declare internal i64 @"os::[os_linux.odin]::_get_errno"(i64, ptr noalias nonnull "captures"="none")

; Function Attrs: alwaysinline
declare internal i8 @"runtime::cstring16_ne"(ptr, ptr) #3

; Function Attrs: alwaysinline
declare internal i64 @"runtime::map_insert_hash_dynamic"(ptr noalias, ptr noalias, i64, i64, i64, ptr noalias nonnull "captures"="none") #3

declare internal i8 @"runtime::map_grow_dynamic"(ptr noalias, ptr noalias, ptr, ptr noalias nonnull "captures"="none")

declare internal i8 @"time::is_leap_year"(i64)

declare internal i64 @"os::open"(%..string, i64, i64, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

; Function Attrs: noinline
declare internal i8 @"runtime::map_reserve_dynamic"(ptr noalias, ptr noalias, i64, ptr, ptr noalias nonnull "captures"="none") #4

; Function Attrs: noinline
declare internal i8 @"runtime::_append_elems"(ptr, i64, i64, i8, ptr, ptr, i64, ptr noalias nonnull, ptr noalias nonnull "captures"="none") #4

declare internal void @"main::try_spawn_child_adjacent"(ptr noalias sret(%"main::Spark"), ptr, i64, i64, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i64 @"os::close"(i32, ptr noalias nonnull "captures"="none")

declare internal i64 @"os::flush"(i32, ptr noalias nonnull "captures"="none")

declare internal i8 @"reflect::enum_name_from_value_any"(%..any, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i64 @"os::read"(i32, { ptr, i64 }, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal void @"main::byte_world_step"(ptr, ptr noalias nonnull "captures"="none")

declare internal i64 @"os::write"(i32, { ptr, i64 }, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i64 @"runtime::string_decode_rune"(%..string, ptr noalias nonnull)

declare internal i64 @"os::read_at"(i32, { ptr, i64 }, i64, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i64 @"os::write_at"(i32, { ptr, i64 }, i64, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i64 @"os::seek"(i32, i64, i64, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i8 @"runtime::delete_slice:proc(array:[]string,allocator:runtime::Allocator,loc:runtime::Source_Code_Location)->(:runtime::Allocator_Error)"({ ptr, i64 }, { i64, i64 }, ptr, ptr noalias nonnull "captures"="none")

declare internal i64 @"os::file_size"(i32, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

; Function Attrs: noinline
declare internal i8 @"runtime::map_free_dynamic"(ptr, ptr, ptr, ptr noalias nonnull "captures"="none") #4

declare internal i8 @"reflect::type_info_union_is_pure_maybe"(ptr, ptr noalias nonnull "captures"="none")

declare internal i8 @"fmt::_parse_int"(%..string, i64, ptr noalias nonnull, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i8 @"runtime::append_elem:proc(array:^[dynamic]main::Relative_Spark,arg:main::Relative_Spark,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr, { i64, i16 }, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i8 @"runtime::append_elem:proc(array:^[dynamic]u8,arg:u8,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr, i8, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i8 @"runtime::append_elem:proc(array:^[dynamic]int,arg:int,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr, i64, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i8 @"runtime::append_elem:proc(array:^[dynamic]main::Detected_Blob,arg:main::Detected_Blob,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr, ptr, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i8 @"runtime::append_elem:proc(array:^[dynamic]main::Pattern,arg:main::Pattern,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr, ptr, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i8 @"runtime::append_elems:proc(array:^[dynamic]u8,args:..u8,loc:runtime::Source_Code_Location)->(n:int,err:runtime::Allocator_Error)"(ptr, { ptr, i64 }, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i8 @"fmt::_arg_number"(%..string, ptr, i64, ptr noalias nonnull, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal void @"main::thread_worker"(ptr, ptr noalias nonnull "captures"="none")

declare internal i8 @"fmt::int_from_arg"({ ptr, i64 }, i64, ptr noalias nonnull, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

; Function Attrs: alwaysinline
declare internal void @"runtime::map_clear_dynamic"(ptr noalias, ptr noalias) #3

declare internal void @"fmt::fmt_bad_verb"(ptr, i32, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_bool"(ptr, i8, i32, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_write_padding"(ptr, i64, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::_fmt_int"(ptr, i64, i64, i8, i64, ptr byval(%..string) align 8, ptr noalias nonnull "captures"="none")

declare internal void @"main::attempt_with_dir_rng"(ptr noalias sret(%"main::Attempt_Result"), ptr, ptr, i64, i64, ptr, ptr noalias nonnull "captures"="none")

declare internal i8 @"runtime::__dynamic_map_check_grow"(ptr noalias, ptr noalias, ptr, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::_fmt_int_128"(ptr, i128, i64, i8, i64, ptr byval(%..string) align 8, ptr noalias nonnull "captures"="none")

; Function Attrs: noinline
declare internal i8 @"runtime::_reserve_dynamic_array"(ptr, i64, i64, i64, i8, ptr, ptr noalias nonnull "captures"="none") #4

declare internal i64 @"strings::index_byte"(%..string, i8)

declare dso_local half @__truncsfhf2(float)

declare internal void @"fmt::_fmt_memory"(ptr, i64, i8, i64, %..string, ptr noalias nonnull "captures"="none")

declare internal void @"main::byte_world_step_parallel"(ptr, ptr noalias nonnull "captures"="none")

declare internal %..string @"strconv::write_float"({ ptr, i64 }, double, i8, i64, i64, ptr noalias nonnull "captures"="none")

; Function Attrs: alwaysinline
declare internal i64 @"runtime::default_hasher"(ptr, i64, i64) #3

declare internal i64 @"strings::index"(%..string, %..string)

declare dso_local half @__truncdfhf2(double)

declare dso_local float @__gnu_h2f_ieee(half)

declare internal i8 @"reflect::as_int"(%..any, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_rune"(ptr, i32, i32, ptr noalias nonnull "captures"="none")

declare internal i64 @"os::[os_linux.odin]::_processor_core_count"(ptr noalias nonnull "captures"="none")

declare internal i8 @"reflect::as_i64"(%..any, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare dso_local half @__gnu_f2h_ieee(float)

declare dso_local float @__extendhfsf2(half)

declare dso_local double @__floattidf(i128)

declare internal i8 @"main::u8_from_f32_01"(float, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_int"(ptr, i64, i8, i64, i32, ptr noalias nonnull "captures"="none")

declare internal i32 @"main::color_from_cell_value"(i8, float, ptr noalias nonnull "captures"="none")

declare dso_local double @__floattidf_unsigned(i128)

declare internal void @"fmt::fmt_int_128"(ptr, i128, i8, i64, i32, ptr noalias nonnull "captures"="none")

declare internal void @"main::render_world_pixels"(ptr, { ptr, i64 }, ptr noalias nonnull "captures"="none")

declare internal i64 @"main::screen_to_world"(<2 x float>, i64, float, float, float, <2 x float>, float, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare dso_local i128 @__umodti3(i128, i128)

declare dso_local i128 @__udivmodti4(i128, i128, ptr)

declare internal void @"fmt::_pad"(ptr, %..string, ptr noalias nonnull "captures"="none")

declare dso_local i128 @__udivti3(i128, i128)

declare internal void @"main::save_pattern"(ptr, i64, i64, i64, i64, ptr byval(%..string) align 8, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::_fmt_float_as"(ptr, double, i64, i32, i8, i64, ptr noalias nonnull "captures"="none")

declare internal void @"runtime::assert"(i8, %..string, ptr, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_float"(ptr, double, i64, i32, ptr noalias nonnull "captures"="none")

declare internal void @"main::load_and_paste_pattern"(ptr, i64, i64, %..string, ptr noalias nonnull "captures"="none")

; Function Attrs: noreturn
declare internal void @"runtime::panic"(%..string, ptr, ptr noalias nonnull "captures"="none") #2

declare internal void @"fmt::fmt_string"(ptr, %..string, i32, ptr noalias nonnull "captures"="none")

declare internal void @"runtime::assert_contextless"(i8, %..string, ptr)

declare internal i8 @"main::load_pattern_from_file"(%..string, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare void @InitWindow(i32, i32, ptr)

declare internal void @"fmt::fmt_cstring"(ptr, ptr, i32, ptr noalias nonnull "captures"="none")

declare i8 @WindowShouldClose()

; Function Attrs: noreturn
declare internal void @"runtime::panic_contextless"(%..string, ptr) #2

declare void @CloseWindow()

declare internal void @"fmt::fmt_string16"(ptr, %..string16, i32, ptr noalias nonnull "captures"="none")

declare internal void @"main::paste_pattern_to_world"(ptr, ptr, i64, i64, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_cstring16"(ptr, ptr, i32, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_pointer"(ptr, ptr, i32, ptr noalias nonnull "captures"="none")

declare internal void @"main::init_world_from_auto_patterns"(ptr, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_soa_pointer"(ptr, %"runtime::Raw_Soa_Pointer", i32, ptr noalias nonnull "captures"="none")

declare i32 @GetScreenWidth()

declare i32 @GetScreenHeight()

declare internal i8 @"fmt::enum_value_to_string"(%..any, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal void @"main::main"(ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_enum"(ptr, %..any, i32, ptr noalias nonnull "captures"="none")

declare internal i8 @"strings::is_space"(i32, ptr noalias nonnull "captures"="none")

declare internal i8 @"fmt::stored_enum_value_to_string"(ptr, i64, i64, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal i64 @"strings::index_proc"(%..string, ptr, i8, ptr noalias nonnull "captures"="none")

declare internal i64 @"strings::last_index_proc"(%..string, ptr, i8, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_bit_set"(ptr, %..any, %..string, i32, ptr noalias nonnull "captures"="none")

declare void @ClearBackground(i32)

declare void @BeginDrawing()

declare void @EndDrawing()

declare internal %..string @"strings::trim_left_proc"(%..string, ptr, ptr noalias nonnull "captures"="none")

declare internal i64 @"math::classify_f64"(double)

declare internal %..string @"strings::trim_right_proc"(%..string, ptr, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_write_indent"(ptr, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_write_array"(ptr, ptr, i64, i64, i64, i32, ptr noalias nonnull "captures"="none")

declare internal %..string @"strings::trim_left_space"(%..string, ptr noalias nonnull "captures"="none")

declare internal %..string @"strings::trim_right_space"(%..string, ptr noalias nonnull "captures"="none")

declare internal i8 @"fmt::[fmt.odin]::handle_tag"(ptr, ptr, ptr, i64, ptr, ptr, ptr, ptr noalias nonnull "captures"="none")

declare internal %..string @"strings::trim_space"(%..string, ptr noalias nonnull "captures"="none")

declare void @SetTargetFPS(i32)

declare float @GetFrameTime()

declare void @SetConfigFlags(i32)

declare internal void @"fmt::fmt_struct"(ptr, %..any, i32, ptr, %..string, ptr noalias nonnull "captures"="none")

declare internal i32 @"linux::gettid"()

declare internal i32 @"linux::futex_wait"(ptr, i32, i32, i32, ptr)

declare internal i32 @"linux::futex_wake"(ptr, i32, i32, i32, ptr noalias nonnull)

declare internal i64 @"fmt::[fmt.odin]::search_nul_termination"(ptr, i64, i64, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_array_nul_terminated"(ptr, ptr, i64, i64, ptr, i32, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_array"(ptr, ptr, i64, i64, ptr, i32, ptr noalias nonnull "captures"="none")

declare internal %..string @"strings::partition"(%..string, %..string, ptr noalias nonnull, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare i8 @IsKeyPressed(i32)

declare i8 @IsKeyDown(i32)

declare internal void @"fmt::fmt_named"(ptr, %..any, i32, ptr, ptr noalias nonnull "captures"="none")

declare internal i32 @"linux::clock_gettime"(i64, ptr noalias nonnull)

declare internal i64 @"unix::sys_open"(ptr, i64, i64)

declare i8 @IsMouseButtonPressed(i32)

declare internal i64 @"unix::sys_close"(i64)

declare i8 @IsMouseButtonDown(i32)

declare internal i64 @"unix::sys_read"(i64, ptr, i64)

declare i8 @IsMouseButtonReleased(i32)

declare internal i64 @"unix::sys_pread"(i64, ptr, i64, i64)

declare <2 x float> @GetMousePosition()

declare internal i64 @"unix::sys_write"(i64, ptr, i64)

declare internal i64 @"unix::sys_pwrite"(i64, ptr, i64, i64)

declare float @GetMouseWheelMove()

declare internal i64 @"unix::sys_lseek"(i64, i64, i64)

declare internal i64 @"unix::sys_fstat"(i64, ptr)

declare internal void @"fmt::fmt_union"(ptr, %..any, i32, ptr, i64, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_matrix"(ptr, %..any, i32, ptr, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_bit_field"(ptr, %..any, i32, ptr, %..string, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_value"(ptr, %..any, i32, ptr noalias nonnull "captures"="none")

declare void @DrawRectangle(i32, i32, i32, i32, i32)

declare void @DrawRectangleRec({ <2 x float>, <2 x float> }, i32)

declare internal i64 @"unix::sys_fsync"(i64)

declare void @DrawRectangleLinesEx({ <2 x float>, <2 x float> }, float, i32)

declare i8 @CheckCollisionPointRec(<2 x float>, { <2 x float>, <2 x float> })

declare internal i8 @"fmt::[fmt.odin]::_cq_should_print_intermediate_plus"(ptr, double)

declare internal void @"fmt::fmt_complex"(ptr, { double, double }, i64, i32, ptr noalias nonnull "captures"="none")

declare internal void @"fmt::fmt_quaternion"(ptr, ptr, i64, i32, ptr noalias nonnull "captures"="none")

declare void @UnloadImage(ptr byval(%"raylib::Image") align 8)

declare internal void @"fmt::fmt_arg"(ptr, %..any, i32, ptr noalias nonnull "captures"="none")

declare void @GenImageColor(ptr noalias sret(%"raylib::Image"), i32, i32, i32)

declare void @LoadTextureFromImage(ptr noalias sret(%"raylib::Texture"), ptr byval(%"raylib::Image") align 8)

declare void @UnloadTexture(ptr byval(%"raylib::Texture") align 8)

declare void @UpdateTexture(ptr byval(%"raylib::Texture") align 8, ptr)

declare void @SetTextureFilter(ptr byval(%"raylib::Texture") align 8, i32)

declare void @DrawTexturePro(ptr byval(%"raylib::Texture") align 8, { <2 x float>, <2 x float> }, { <2 x float>, <2 x float> }, <2 x float>, float, i32)

declare void @DrawFPS(i32, i32)

declare void @DrawText(ptr, i32, i32, i32, i32)

declare internal ptr @"raylib::TextFormat"(ptr, { ptr, i64 }, ptr noalias nonnull "captures"="none")

declare internal { ptr, i64 } @"mem::zero_slice:proc\22contextless\22(data:[]u8)->(:[]u8)"({ ptr, i64 })

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.inline.p0.i64(ptr writeonly captures(none), i8, i64, i1 immarg) #6

; Function Attrs: cold noreturn nounwind memory(inaccessiblemem: write)
declare void @llvm.trap() #7

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.cttz.i64(i64, i1 immarg) #8

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.ctlz.i64(i64, i1 immarg) #8

declare internal i8 @"runtime::heap_allocator_proc.aligned_alloc-0"(i64, i64, ptr, i64, i8, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

declare internal void @"runtime::heap_allocator_proc.aligned_free-1"(ptr, ptr noalias nonnull "captures"="none")

declare internal i8 @"runtime::heap_allocator_proc.aligned_resize-2"(ptr, i64, i64, i64, i8, ptr noalias nonnull, ptr noalias nonnull "captures"="none")

; Function Attrs: cold noreturn
declare internal void @"runtime::bounds_check_error.handle_error-0"(%..string, i32, i32, i64, i64) #9

declare internal ptr @"thread::[thread_unix.odin]::_create.__unix_thread_entry_proc-0"(ptr)

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: write)
declare void @llvm.memset.p0.i64(ptr writeonly captures(none), i8, i64, i1 immarg) #6

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare { i64, i1 } @llvm.uadd.with.overflow.i64(i64, i64) #8

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.inline.p0.p0.i64(ptr noalias writeonly captures(none), ptr noalias readonly captures(none), i64, i1 immarg) #10

declare internal i64 @"runtime::default_random_generator_proc.read_u64-0"(ptr)

declare internal void @"runtime::default_random_generator_proc.init-1"(ptr, i64)

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memmove.p0.p0.i64(ptr writeonly captures(none), ptr readonly captures(none), i64, i1 immarg) #10

declare internal i64 @"runtime::alloc_from_memory_block.calc_alignment_offset-0"(ptr, i64)

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias writeonly captures(none), ptr noalias readonly captures(none), i64, i1 immarg) #10

declare internal i64 @"runtime::arena_alloc.align_forward_uint-0"(i64, i64)

declare internal { ptr, i64 } @"strconv::format_digits.to_bytes-0"(ptr, ptr noalias nonnull "captures"="none")

declare internal void @"strconv::format_digits.add_bytes-1"(ptr, { ptr, i64 }, ptr noalias nonnull "captures"="none")

; Function Attrs: cold noreturn
declare internal void @"runtime::matrix_bounds_check_error.handle_error-0"(%..string, i32, i32, i64, i64, i64, i64) #9

declare internal i8 @"io::write_escaped_rune.is_printable-0"(i32, ptr noalias nonnull "captures"="none")

; Function Attrs: cold noreturn
declare internal void @"runtime::type_assertion_check.handle_error-0"(%..string, i32, i32, i64, i64) #9

declare internal i64 @"runtime::type_assertion_check2.variant_type-0"(i64, ptr)

; Function Attrs: cold noreturn
declare internal void @"runtime::type_assertion_check2.handle_error-1"(%..string, i32, i32, i64, i64, ptr) #9

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i8 @llvm.vector.reduce.or.v16i8(<16 x i8>) #8

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i8 @llvm.vector.reduce.umin.v16i8(<16 x i8>) #8

; Function Attrs: cold noreturn
declare internal void @"runtime::make_slice_error_loc.handle_error-0"(ptr, i64) #9

; Function Attrs: cold noreturn
declare internal void @"runtime::make_dynamic_array_error_loc.handle_error-0"(ptr, i64, i64) #9

; Function Attrs: alwaysinline
declare internal i8 @"strconv_decimal::shift_left.prefix_less-0"({ ptr, i64 }, %..string) #3

; Function Attrs: alwaysinline
declare internal i64 @"io::write_quoted_rune._write_byte-0"({ i64, i64 }, i8, ptr noalias nonnull "captures"="none") #3

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i8 @llvm.vector.reduce.or.v8i8(<8 x i8>) #8

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i8 @llvm.vector.reduce.umin.v8i8(<8 x i8>) #8

; Function Attrs: alwaysinline
declare internal i64 @"runtime::map_total_allocation_size.round-0"(i64) #3

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(none)
declare i8 @llvm.expect.i8(i8, i8) #11

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare i64 @llvm.readcyclecounter() #12

attributes #0 = { noinline optnone }
attributes #1 = { nounwind }
attributes #2 = { noreturn }
attributes #3 = { alwaysinline }
attributes #4 = { noinline }
attributes #5 = { noinline optsize }
attributes #6 = { nocallback nofree nounwind willreturn memory(argmem: write) }
attributes #7 = { cold noreturn nounwind memory(inaccessiblemem: write) }
attributes #8 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #9 = { cold noreturn }
attributes #10 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #11 = { nocallback nofree nosync nounwind willreturn memory(none) }
attributes #12 = { nocallback nofree nosync nounwind willreturn }
